<!DOCTYPE html>
<html lang="fr">
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <meta charset="UTF-8" />

  <title>Jetpack Runner V7.4 ‚Äî Tourelles + midgame plus dur</title>

  <!-- VIEWPORT (CRITIQUE MOBILE) -->
<meta name="viewport"
content="width=device-width,
         height=device-height,
         initial-scale=1.0,
         maximum-scale=1.0,
         user-scalable=no,
         viewport-fit=cover">


  <!-- ===== PWA ===== -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#05060a">

  <!-- ===== iOS (OBLIGATOIRE) ===== -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Jetpack Runner">

  <!-- IC√îNES -->
  <link rel="icon" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- STYLE -->
  <style>

/* =========================================================================
   üåå JETPACK RUNNER ‚Äî STYLE SHEET FINAL (CLEAN V7)
========================================================================= */

/* 1. VARIABLES & RESET */
:root {
  --font-title: 'Orbitron', sans-serif;
  --font-tech:  'Rajdhani', sans-serif;
  --col-gold:   #ffd700;
  --col-glass:  rgba(0, 0, 0, 0.6);
  
  --col-common:    #b0bec5;
  --col-rare:      #29b6f6;
  --col-epic:      #ab47bc;
  --col-legendary: #ffca28;
}

* { margin:0; padding:0; box-sizing:border-box; }

html, body {
  width:100%; height:100%;
  background:#05060a; color:#fff;
  font-family: var(--font-tech);
  overflow:hidden;
  touch-action:none; overscroll-behavior:none;
}

body { position:fixed; inset:0; display:block; }

/* =========================================================================
   üéÆ GAME CONTAINER & CANVAS
========================================================================= */
#gameContainer {
  position: absolute !important;
  inset: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  overflow: hidden;
  background: #000; /* Fond noir par d√©faut */
  z-index: 0;
}

canvas#game {
  display: block;
  width: 100%; height: 100%;
  object-fit: cover;
}

/* INPUT ZONE */
#touchZone {
  position:absolute; inset:0; z-index:10;
  touch-action: none; -webkit-touch-callout: none; user-select: none;
}

/* =========================================================================
   üëÄ HUD IN-GAME (TRANSPARENT & IMMERSIF)
========================================================================= */

/* Conteneur Global (Invisible) */
#uiLayer {
  position: absolute; inset: 0;
  pointer-events: none; z-index: 100;
  background: transparent !important;
  display: flex; flex-direction: column; justify-content: space-between;
}

/* SCORE (Gros, Centr√©, Flottant) */
#ui {
  position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
  text-align: center; width: 100%; pointer-events: none;
}

#uiScore {
  font-family: var(--font-title);
  font-size: 60px; font-weight: 900; font-style: italic;
  background: linear-gradient(180deg, #ffffff 20%, #b0c4de 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 4px 0px rgba(0,0,0,0.5));
  will-change: transform;
}

/* PI√àCES (Discret Haut Gauche) */
#uiCoins {
  position: absolute; top: 20px; left: 20px;
  display: flex; align-items: center; gap: 8px;
  background: transparent !important;
}

#uiCoins .coinIcon {
  width: 24px; height: 24px;
  background: radial-gradient(circle at 30% 30%, #fff6c7, #ffb400 60%, #ff7a00);
  border-radius: 50%; box-shadow: 0 0 10px #ffd700;
}

#coinCount {
  font-family: var(--font-title); font-size: 20px; font-weight: 700;
  color: #ffd700; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

/* OVERDRIVE METER & COMBO */
#overdriveMeter {
  position: absolute; right: 22px; top: 60%; transform: translateY(-50%);
  width: 18px; height: 200px; z-index: 25; pointer-events: none;
}
#overdriveBarOuter {
  position: relative; width: 100%; height: 100%;
  border-radius: 4px; background: rgba(10, 15, 30, 0.6);
  border: 1px solid rgba(100, 180, 255, 0.3); overflow: hidden;
}
#overdriveBarInner {
  position: absolute; bottom: 0; width: 100%; height: 0%; border-radius: 2px;
  background: linear-gradient(180deg, #ffffff, #40c4ff, #2962ff);
  box-shadow: 0 0 20px rgba(41, 98, 255, 0.6); transition: height 0.1s linear;
}
body.overdriveActive #overdriveBarInner { animation: overdrivePulse 0.8s ease-in-out infinite alternate; }

#combo {
  position: absolute; right: 60px; top: 50%; transform: translateY(-50%);
  font-family: var(--font-title); font-size: 24px; font-weight: 900; font-style: italic;
  opacity: 0; color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
  transition: opacity 0.2s ease, transform 0.1s;
}
body.comboActive #combo { opacity: 1; transform: translateY(-50%) scale(1.1); }
#combo span { color: #ffeb3b; }

/* ANIMATIONS HUD */
@keyframes scorePulse { 0%{transform:scale(1);} 50%{transform:scale(1.08);} 100%{transform:scale(1);} }
@keyframes overdrivePulse { from{filter:brightness(1);} to{filter:brightness(1.3);} }

/* =========================================================================
   üè† MENU PRINCIPAL & INTRO (VERSION COMPACTE)
========================================================================= */
#menuOverlay { position: absolute; inset: 0; z-index: 26; overflow: hidden; }
#menuVideo { width: 100%; height: 100%; object-fit: contain; background: black; }
#galaxyBG, .menuParticles { position: absolute; inset: 0; pointer-events: none; }
#menuBg { position: absolute; inset: 0; z-index: 1; }

/* BOUTONS MENU (Compact & Sleek) */
#menuButtons {
  position: absolute; left: 50%; top: 65%; transform: translate(-50%, -50%);
  display: flex; flex-direction: column; gap: 12px; /* Espacement r√©duit */
  z-index: 10;
}

.menuBtn {
  min-width: 220px; /* Largeur r√©duite (√©tait 280px) */
  padding: 14px 0;  /* Hauteur r√©duite (√©tait 18px) */
  
  font-family: var(--font-title); 
  font-size: 14px; /* Police r√©duite */
  font-weight: 900; letter-spacing: 3px; text-transform: uppercase;
  color: #fff; background: rgba(6, 10, 20, 0.85);
  border: 1px solid rgba(100, 200, 255, 0.3); backdrop-filter: blur(8px);
  
  /* Coins coup√©s plus petits (15px au lieu de 20px) */
  clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
  
  cursor: pointer; transition: all 0.2s; box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}

.menuBtn:hover {
  background: rgba(100, 200, 255, 0.1); border-color: #fff; transform: scale(1.05);
  box-shadow: 0 0 30px rgba(100, 200, 255, 0.2);
}

#btnPlay { 
  background: #fff; color: #000; 
  font-size: 18px; /* R√©duit */
  padding: 18px 0; /* R√©duit */
  box-shadow: 0 0 20px rgba(255,255,255,0.25); 
}

#btnPlay:hover { 
  background: #d4eeff; transform: scale(1.05); 
  box-shadow: 0 0 50px rgba(200, 230, 255, 0.6); 
}

/* STATS MENU (Plus discr√®tes) */
#menuStats {
  position: absolute; 
  top: 5%; right: 5%; /* Plus coll√© au coin */
  display: flex; gap: 12px; 
  z-index: 12; pointer-events: none;
}

.statBox {
  background: linear-gradient(180deg, rgba(20,30,50,0.9), rgba(5,10,20,0.95));
  border: 1px solid rgba(100,180,255,0.2); 
  border-radius: 8px; /* Arrondi r√©duit */
  padding: 6px 12px; /* Padding r√©duit */
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
}

.statBox.coins { border-color: rgba(255, 215, 0, 0.3); }

.statLabel { 
  font-family: var(--font-tech); font-weight: 700; 
  font-size: 10px; /* R√©duit */
  opacity: 0.7; 
}

.statValue { 
  font-family: var(--font-title); font-weight: 700; 
  font-size: 18px; /* R√©duit (√©tait 24px) */
  color: #fff; 
}

.statBox.coins .statValue { color: var(--col-gold); text-shadow: 0 0 10px rgba(255, 180, 0, 0.4); }
/* =========================
   INTRO ‚Äî PLEIN √âCRAN TOTAL (WALLPAPER MODE)
========================== */

#overlayIntro {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 100000;
  background: #000;
  overflow: hidden;
}

/* Le conteneur prend toute la place */
#overlayIntro #introLogo {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1; /* Derri√®re le texte */
}

/* L'IMAGE DOIT REMPLIR TOUT L'√âCRAN */
#overlayIntro #introLogo img {
  display: block;
  width: 100%;
  height: 100%;
  
  /* C'est la commande CRUCIALE : */
  /* "Cover" dit √† l'image de couvrir toute la zone, quitte √† couper les bords qui d√©passent */
  object-fit: cover; 
  
  /* On centre l'image pour que la coupe se fasse √©quitablement sur les c√¥t√©s */
  object-position: center center;
  
  /* Reset des marges */
  margin: 0;
  padding: 0;
}

/* LE TEXTE "TAP TO START" (Par dessus l'image) */
#overlayIntro .introHint {
  position: absolute;
  bottom: 10%; /* Plac√©e en bas */
  left: 0;
  width: 100%;
  text-align: center;
  z-index: 10; /* Devant l'image */
  
  font-family: var(--font-title, sans-serif);
  font-size: 24px;
  font-weight: 900;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: #fff;
  
  /* Grosse ombre pour √™tre lisible sur n'importe quel fond */
  text-shadow: 
    0 2px 4px rgba(0,0,0,0.9),
    0 0 20px rgba(0,0,0,0.8);
    
  animation: tapPulse 1.5s ease-in-out infinite;
  pointer-events: none;
}

@keyframes tapPulse {
  0%, 100% { opacity: 0.6; transform: scale(0.95); }
  50% { opacity: 1; transform: scale(1.05); }
}
/* =========================================================================
   üõçÔ∏è SHOP SYSTEM V7 (ZOOM HD & DYNAMIC)
========================================================================= */
#shopPanel {
  position: absolute; inset: 0; width: 100vw; height: 100vh; z-index: 500;
  background: #020408;
  /* Transition douce pour le changement de couleur de fond */
  transition: background 0.4s ease, opacity 0.3s ease;
  display: none; opacity: 0; pointer-events: none; overflow: hidden;
}
#shopPanel.visible { display: block !important; opacity: 1; pointer-events: auto; }

/* ZONE CENTRALE */
.shopContentZone {
  position: absolute; top: 70px; bottom: 0; width: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}
.skinCard {
  flex-grow: 1; width: 100%; display: flex; justify-content: center; align-items: center;
  position: relative; animation: skinFloat 5s ease-in-out infinite;
}
@keyframes skinFloat { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-15px); } }

/* CANVAS HD */
#shopHeroCanvas {
  height: 65vh; width: auto; max-width: 90vw;
  object-fit: contain; filter: drop-shadow(0 20px 50px rgba(0,0,0,0.6));
}

/* INFOS */
.skinInfoZone {
  position: absolute; bottom: 20px; left: 0; right: 0;
  display: flex; flex-direction: column; align-items: center; z-index: 20;
  background: linear-gradient(to top, #000 20%, transparent 100%);
  padding-bottom: 30px; padding-top: 40px;
}
.skinName {
  font-family: var(--font-title); font-size: 38px; font-weight: 900; margin:0; text-transform:uppercase;
  background:linear-gradient(180deg,#fff,#a0c4ff); -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  text-shadow:0 5px 15px rgba(0,0,0,1);
}
.skinPrice { font-family:var(--font-title); font-size:18px; margin-bottom:12px; text-shadow:0 2px 5px #000; }

/* BOUTON ACTION */
.skinButton {
  min-width: 220px; padding: 14px 0; border: none; cursor: pointer;
  font-family: var(--font-title); font-size: 16px; font-weight: 900; text-transform: uppercase;
  background: #fff; color: #000; box-shadow: 0 0 30px rgba(0,0,0,0.5);
  clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
}
.skinButton.adCTA { background:linear-gradient(135deg, #00e676, #00c853); color:#002500; animation:pulseCTA 1.2s infinite; }
.skinButton.owned { background: #a0c0ff; color: #000; }
.skinButton.equipped { background: transparent; border: 1px solid #8aff8a; color: #8aff8a; }

/* HEADER SHOP */
#shopBackBtn {
  position: absolute; top: 20px; left: 20px; z-index: 600; cursor: pointer;
  font-family: var(--font-tech); font-weight: 700; color: rgba(255,255,255,0.7);
  padding: 8px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
}
#shopBalanceDisplay {
  position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 600;
  display: flex; align-items: center; gap: 8px;
  padding: 8px 20px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 30px;
}
#shopTotalCoins { font-family: var(--font-title); font-size: 24px; font-weight: 900; color: #ffd700; }
#shopBalanceDisplay .coinIcon { width: 20px; height: 20px; background: #ffd700; border-radius: 50%; box-shadow: 0 0 8px #ffd700; }

#shopAdBlock {
  position: absolute; top: 20px; right: 20px; z-index: 600;
  background: rgba(0, 40, 20, 0.95); border: 1px solid #00e676;
  padding: 6px 14px; border-radius: 8px; text-align: right; cursor: pointer;
  animation: pulseAdBlock 2s infinite;
}
.adHint { font-family: var(--font-tech); font-size: 9px; color: #b9f6ca; }
#shopAdBtn { font-family: var(--font-title); font-size: 12px; font-weight: 900; color: #fff; text-decoration: underline; }

/* FL√àCHES */
#shopPanel .navArrow {
  position:absolute; top:50%; transform:translateY(-50%); width:80px; height:100%;
  display:flex; align-items:center; justify-content:center;
  font-size:50px; color:rgba(255,255,255,0.3); cursor:pointer; z-index:100;
}
#shopPanel .navArrow:hover { color:#fff; background:linear-gradient(90deg,transparent,rgba(255,255,255,0.1)); }
#shopPanel .navArrow.left { left:0; } 
#shopPanel .navArrow.right { right:0; }

/* =========================================================================
   ‚öôÔ∏è OPTIONS & POPUPS
========================================================================= */
#optionsPanel {
  position:absolute; inset:0; display:none; flex-direction:column; z-index:10000;
  background: radial-gradient(circle at 50% 40%, rgba(0,220,255,.10), rgba(0,0,0,0) 48%), linear-gradient(180deg, rgba(5,10,25,.92), rgba(0,0,0,.75));
  backdrop-filter:blur(10px); align-items:center; justify-content:center; pointer-events:auto;
}
#optionsPanel .optionsBox {
  width:100%; max-width:440px; padding:42px 38px;
  background:linear-gradient(180deg, rgba(12,20,48,.72), rgba(6,10,26,.62));
  border-radius:20px; border:1px solid rgba(140,200,255,0.18); color:#cfe9ff;
}
.optRow { margin-bottom:20px; }
#optBack { width:100%; margin-top:26px; }

/* MENU AD POPUP */
#menuAdPopup {
  position: absolute; top: -100px; left: 50%; transform: translateX(-50%);
  width: 260px; padding: 12px 16px; border-radius: 14px;
  background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 10px 40px rgba(0,0,0,0.5); text-align: center;
  z-index: 999; transition: top 0.5s, opacity 0.5s; opacity: 0; pointer-events: auto;
}
#menuAdPopup.visible { top: 90px; opacity: 1; }

/* =========================================================================
   üíÄ GAME OVER
========================================================================= */
#overlayGameOver {
  position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
  background: radial-gradient(circle at 50% 40%, rgba(20, 30, 60, 0.4), rgba(0, 0, 0, 0.95));
  backdrop-filter: blur(8px); visibility: hidden; opacity: 0; pointer-events: none; z-index: 100;
  transition: opacity 0.35s ease;
}
#overlayGameOver.visible { visibility: visible; opacity: 1; pointer-events: auto; }

.gameOverCard {
  min-width: 300px; padding: 40px; display: flex; flex-direction: column; align-items: center; gap: 20px;
  background: rgba(10, 15, 30, 0.85); border: 1px solid rgba(100, 180, 255, 0.2);
  clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
}
.gameOverTitle {
  font-family: var(--font-title); font-size: 38px; font-weight: 900; margin: 0; text-transform: uppercase;
  background: linear-gradient(180deg, #fff, #ff4081); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.gameOverStats { width: 100%; display: flex; flex-direction: column; gap: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding: 20px 0; }
.gameOverStats p { display:flex; justify-content:space-between; font-family:var(--font-tech); font-size:18px; color:#a0b0c0; }
.gameOverActions { display: flex; gap: 16px; width: 100%; }
.gameOverActions .bigButton {
  flex: 1; padding: 16px; font-family: var(--font-title); font-weight: 700; text-transform: uppercase;
  border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: #fff; cursor: pointer;
}
#restartBtn { background: #fff; color: #000; border: none; }

/* =========================================================================
   üì± MEDIA QUERIES & FIXES
========================================================================= */
/* Cache le menu quand on joue (CORRIG√â) */
body.playing #menuOverlay,
body.playing #menuVideo,
body.playing #galaxyBG,
body.playing .menuParticles {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

/* Mobile Landscape Shop Fix */
@media (max-height: 550px) {
    #shopHeroCanvas { height: 50vh; }
    .shopContentZone { top: 50px; }
    .skinInfoZone { bottom: 10px; padding-top: 10px; padding-bottom: 10px; }
    .skinName { font-size: 24px; }
    .skinButton { padding: 10px 0; min-width: 180px; font-size: 14px; }
}

/* Rotate Overlay */
#rotateOverlay {
  position:fixed; inset:0; background:#05060a; z-index:999999;
  display:none; align-items:center; justify-content:center;
}
#rotateOverlay .rotateBox { color:white; font-size:22px; font-weight:900; text-align:center; opacity:.9; }
</style>

</head>
<body>

  <audio id="musicMenu" src="audio/Menu.ogg" loop preload="auto"></audio>
  <audio id="musicGame" src="audio/game.ogg" loop preload="auto"></audio>
  <audio id="sfxDeath" src="audio/death.ogg" preload="auto"></audio>
  <audio id="sfxIntro" src="audio/intro_burst.mp3" preload="auto"></audio>
  <audio id="sfxOverdrive" src="audio/overdrive_start.mp3" preload="auto"></audio>

  <div id="overlayIntro">
    <canvas id="introEmbers"></canvas>
    <div class="introContent">
      <div id="introLogo" class="introHero">
        <img src="./assets/MJLogo.png" alt="Logo"> 
      </div>
      <div class="introHint">TAP TO START</div>
    </div>
  </div>

  <div id="transitionFX"></div>

  <div id="menuOverlay">
    <canvas id="galaxyBG"></canvas>
    <div class="menuParticles"></div>

    <video id="menuVideo" muted loop playsinline preload="none" data-src="./assets/menu_bg.mp4"></video>

    <div id="menuAdPopup" style="
        position:absolute; top:-80px; left:50%; transform:translateX(-50%);
        width:260px; padding:12px 16px; border-radius:14px;
        background:linear-gradient(180deg, rgba(20,32,70,.95), rgba(8,14,32,.95));
        box-shadow:0 12px 40px rgba(40,90,160,.45); text-align:center;
        z-index:120; transition:top .6s ease, opacity .6s ease;
        opacity:0; pointer-events:auto;">
      
      <div style="font-size:14px; font-weight:700; color:#cfe8ff;">üéÅ Watch an ad</div>
      <div style="font-size:12px; opacity:.8; margin:4px 0 10px;">Get <b>49 coins</b> instantly</div>
      <button id="menuAdBtn" class="bigButton" style="padding:8px 18px; font-size:13px;">Watch ad (+49)</button>
      <div id="menuAdCount" style="margin-top:6px; font-size:11px; opacity:.6;">5 / 5 ads left</div>
    </div>

    <div id="menuStats">
      <div class="statBox best">
        <div class="statLabel">BEST</div>
        <div class="statValue" id="menuBest">0</div>
      </div>
      <div class="statBox coins">
        <div class="statLabel">COINS</div>
        <div class="statValue" id="menuCoins">0</div>
      </div>
    </div>

    <div id="menuButtons">
      <button id="btnPlay" class="menuBtn">PLAY</button>
      <button id="btnShop" class="menuBtn">SHOP</button>
      <button id="btnOptions" class="menuBtn">SETTINGS</button>
    </div>

    <div id="shopBackBtn">‚Üê</div>
<div class="navArrow left" onclick="shopNav(-1)">‚Äπ</div>

<div class="navArrow right" onclick="shopNav(1)">‚Ä∫</div>
  

    <div id="shopPanel"></div>
  </div>

  <div id="optionsPanel">
    <div class="optionsBox">
      <h2>SETTINGS</h2>
      <div class="optRow">
        <label>üéµ Music</label>
        <input id="optMusic" type="range" min="0" max="100">
      </div>
      <div class="optRow">
        <label>üîä Effects</label>
        <input id="optSfx" type="range" min="0" max="100">
      </div>
      <div class="optRow">
        <label><input id="optMute" type="checkbox"> üîá Mute</label>
      </div>
      <button id="optBack" class="menuBtn">BACK</button>
    </div>
  </div>

  <div id="gameContainer">
    <canvas id="game" width="720" height="405"></canvas>

    <div id="uiLayer">
      <div id="uiCoins">
        <div class="coinIcon"></div> <div class="coinValue" id="coinCount">0</div>
      </div>

      <div id="ui">
        <div id="uiScore">0</div>
      </div>

      <div id="overdriveMeter">
        <div id="overdriveLabel">BOOST</div>
        <div id="overdriveBarOuter">
          <div id="overdriveBarInner"></div>
        </div>
      </div>

      <div id="combo">x<span id="comboVal">1</span></div>

      <div id="continuePopup" style="
          position:absolute; bottom:42%; left:50%; transform:translateX(-50%);
          display:none; z-index:210; pointer-events:auto;">
        
        <div style="width:180px; padding:12px 12px 10px; border-radius:14px;
            background:radial-gradient(120% 140% at 50% 0%, rgba(140,200,255,.18), transparent 60%), linear-gradient(180deg, rgba(18,30,76,.98), rgba(8,14,36,.98));
            box-shadow:0 0 0 1px rgba(255,255,255,.05) inset, 0 12px 36px rgba(40,90,160,.5);
            text-align:center; animation:reviveIn .18s cubic-bezier(.2,.8,.2,1) forwards; transform-origin:center bottom;">
          
          <div style="font-size:14px; font-weight:900; margin-bottom:3px; color:#f5f9ff;">‚ö° Second chance</div>
          <div style="font-size:11.5px; opacity:.85; margin-bottom:8px; color:#d6e2ff;">Keep your run alive</div>
          
          <div id="continueAdBtn" style="
              display:inline-flex; align-items:center; justify-content:center; gap:6px;
              padding:8px 14px; border-radius:999px; background:linear-gradient(180deg, #a6f3ff, #56c6ff);
              color:#03121c; font-size:12.5px; font-weight:900; cursor:pointer;
              box-shadow:0 0 0 1px rgba(255,255,255,.35) inset, 0 0 18px rgba(140,230,255,.9); margin-bottom:5px;">
            ‚ö° Continue
          </div>

          <div id="continueTimer" style="font-size:10px; opacity:.45; color:#c6d6ff;">
            <span id="continueSeconds">4</span>s left
          </div>
        </div>
      </div>

      <div id="overlayGameOver">
        <div class="gameOverCard">
          <div id="newRecord" style="
              font-size:48px; font-weight:900; color:#ffd700; text-shadow:0 0 25px #ffea00;
              opacity:0; transform:scale(0.6); transition:opacity .5s, transform .5s; display:none;">
            NEW RECORD !
          </div>

          <h2 class="gameOverTitle">Game Over !</h2>

          <div class="gameOverStats">
            <p>Score <span id="finalScore">0</span></p>
            <p>Best Score <span id="finalBest">0</span></p>
            <p>Coins <span id="finalCoins">0</span></p>
          </div>

          <div class="gameOverActions">
            <button id="restartBtn" class="bigButton">Play Again</button>
            <button id="menuBtn" class="bigButton">Main Menu</button>
          </div>
        </div>
      </div>

      <div id="touchZone" style="position:absolute; inset:0; z-index:10;"></div>
    </div>
  </div>

  <div id="rotateOverlay">
    <div class="rotateBox">
      üîÑ<br>Rotate your phone
    </div>
  </div>

</body>

<script>
/* =========================================================
   GLOBAL STATE ‚Äî SAFE BOOTSTRAP
========================================================= */

// ================= GAME CORE =================
let gameState = "intro";
let gameRunning = true; // üî• UNIQUE source de v√©rit√© (NE PAS red√©clarer ailleurs)

let equippedSkin = "moony";
// ================= TRAIL TIMING =================

let skinId = localStorage.getItem("currentSkin") || "solar";
let t = 0; // temps global logique
let gameOverTriggered = false;
let isTouch = false;
let noiseCanvas = null;
let moonyExpr = 0;
let lastFrameTime = performance.now();
let worstDelta = 0;
let lastOverdrivePct = -1;
let reviveInvincible = false;
let reviveInvTimer = 0;
let overdriveEndingFlag = false;
// ================= BACKGROUND =================
const bgCanvas = document.createElement("canvas");
const bgCtx = bgCanvas.getContext("2d");

// ================= CANVAS =================
const canvas = document.getElementById("game");
if (!canvas) throw new Error("Canvas #game introuvable");

const ctx = canvas.getContext("2d");
if (!ctx) throw new Error("Contexte 2D impossible");

// ================= WORLD / CAMERA =================
const BASE_W = 810; // üëà Modifi√© pour le ratio 2:1 (Fullscreen mobile)
const BASE_H = 405;

let bgScroll = 0;
let currentScale = 1;
let currentDPR   = 1;

let cameraScale   = 1;
let cameraOffsetX = 0;
let cameraOffsetY = 0;

// ================= PATH CACHES (iOS SAFE) =================
const _arcPathCache  = new Map();
const _rectPathCache = new Map();

// ================= FRAME / FX =================
let frameCount = 0;
let fxCalm = 1;

const OVERDRIVE_CALM = {
  glow: 0.65,
  blur: 0.6,
  alpha: 0.7
};
// --- GLOBAL SPAWN VARIABLES ---
let lastSpawnTime = 0;
let lastBarTime   = 0;

// --- CONFIG ---
const SPAWN_MARGIN_X = 100; // Distance off-screen where things spawn
/* =========================================================
   FX QUALITY MANAGER ‚Äî SINGLE INSTANCE
========================================================= */

const FXQuality = (() => {

  let tier = 2; // 0..3
  let scene = "game";
  let forceTier = null;

  let lastT = 0;
  let emaDt = 16.67;
  let emaFps = 60;
  const alpha = 0.08;

  let cooldown = 0;
  const UP_COOLDOWN = 0.9;

  const isMobile =
    (typeof navigator !== "undefined" &&
     /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) ||
    (typeof matchMedia !== "undefined" &&
     matchMedia("(pointer: coarse)").matches);

  function setScene(s){
    scene = s || "game";
  }

  function setForceTier(v){
    forceTier = (v === 0 || v === 1 || v === 2 || v === 3) ? v : null;
  }

  function update(ts){
    if (!lastT){
      lastT = ts;
      return;
    }

    const dt = ts - lastT;
    lastT = ts;
    if (dt > 1200) return;

    emaDt  += (dt - emaDt) * alpha;
    emaFps  = 1000 / Math.max(1, emaDt);

    if (forceTier !== null){
      tier = forceTier;
      return;
    }

    let down45 = 48, down35 = 38, up55 = 57, up60 = 61;

    if (scene === "menu"){
      down45 = 43; down35 = 33; up55 = 53; up60 = 58;
    } else if (scene === "shop"){
      down45 = 46; down35 = 36; up55 = 56; up60 = 60;
    }

    if (isMobile){
      up60 -= 6;
      up55 -= 4;
      down45 += 1;
      down35 += 1;
    }

    if (cooldown > 0){
      cooldown -= dt * 0.001;
    }

    if (emaFps < down35){
      tier = Math.max(0, tier - 2);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (emaFps < down45){
      tier = Math.max(0, tier - 1);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (cooldown <= 0){
      if (emaFps > up60){
        tier = Math.min(3, tier + 1);
      } else if (emaFps > up55 && tier < 2){
        tier = Math.min(2, tier + 1);
      }
    }
  }

  function q(){ return tier; }
  function fps(){ return emaFps; }

  function scaleCount(base, minFactor = 0.35){
    const f = tier === 3 ? 1 : tier === 2 ? 0.85 : tier === 1 ? 0.65 : 0.45;
    return Math.max(1, Math.round(base * Math.max(minFactor, f)));
  }

  function scaleAlpha(base){
    const f = tier === 3 ? 1 : tier === 2 ? 0.92 : tier === 1 ? 0.78 : 0.65;
    return base * f;
  }

  function allowHeavy(){
    if (tier === 0) return false;
    if (tier === 1 && scene === "shop") return false;
    return true;
  }

  return {
    update,
    setScene,
    setForceTier,
    q,
    fps,
    isMobile,
    scaleCount,
    scaleAlpha,
    allowHeavy
  };

})();

// ================= GLOBAL FX FLAGS =================
const IS_MOBILE = FXQuality.isMobile;
const USE_PATH  = !IS_MOBILE;

// üîí mobile = LOW forc√© (une seule fois)
if (IS_MOBILE){
  FXQuality.setForceTier(0);
}

/* =========================================================
   ORIENTATION / ROTATION ‚Äî SAFE
========================================================= */

function checkOrientation(){
  const overlay = document.getElementById("rotateOverlay");
  if (!overlay) return;

  const w = window.innerWidth  || 0;
  const h = window.innerHeight || 0;
  if (!w || !h) return;

  const portrait = h > w;
  overlay.style.display = portrait ? "flex" : "none";
  gameRunning = !portrait;
}

window.addEventListener("resize", checkOrientation, { passive:true });
window.addEventListener("orientationchange", () => {
  setTimeout(checkOrientation, 120);
}, { passive:true });

setTimeout(checkOrientation, 0);

function lockLandscape(){
  if (!window.screen || !screen.orientation || !screen.orientation.lock) return;
  try { screen.orientation.lock("landscape").catch(()=>{}); } catch(e){}
}

window.addEventListener("pointerdown", lockLandscape, { once:true });


/* =========================================================
   MENU / VIDEO / AUDIO ‚Äî SAFE & MOBILE FRIENDLY
========================================================= */

// ================= MENU VIDEO =================
const menuVideo = document.getElementById("menuVideo") || null;

let menuVideoStarted = false;
let menuVideoWarmed  = false;

// ================= MENU FLOW =================
async function showMenu(){

  // üîí STOP JEU PROPREMENT
  gameRunning = false;
  if (typeof accTime !== "undefined") accTime = 0;
  if (typeof lastFrame !== "undefined") lastFrame = null;

  fxCalm = 0;

  // üß≠ UI
  if (typeof menuOverlay !== "undefined" && menuOverlay){
    menuOverlay.style.display = "flex";
  }

  // üéûÔ∏è VIDEO MENU
  if (menuVideo){
    try {
      menuVideo.pause();
      menuVideo.currentTime = 0;

      requestAnimationFrame(() => {
        menuVideo.play().catch(()=>{});
      });
    } catch(e){}
  }

  // üéµ MUSIQUE MENU
  loadMenuMusic(); // fire & forget
  setTimeout(() => {
    playMenuMusic();
  }, 150);
}

function hideMenu(){
  if (typeof menuOverlay !== "undefined" && menuOverlay){
    menuOverlay.style.display = "none";
  }
  stopMenuMusic();
}

// ================= VIDEO WARMUP (iOS SAFE) =================
function warmupMenuVideo(){
  if (!menuVideo || menuVideoWarmed) return;

  try {
    menuVideo.style.visibility = "hidden";
    menuVideo.currentTime = 0;

    menuVideo.play().then(() => {
      setTimeout(() => {
        try {
          menuVideo.pause();
          menuVideo.currentTime = 0;
          menuVideo.style.visibility = "visible";

          menuVideo.loop = true;
          menuVideo.play().catch(()=>{});
          menuVideoWarmed = true;
        } catch(e){}
      }, 300);
    }).catch(()=>{});
  } catch(e){}
}

// =========================================================
// AUDIO (WEB AUDIO ‚Äî SAFE)
// =========================================================

let audioCtx = null;
try {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
} catch(e){
  audioCtx = null;
}

let menuMusicBuffer = null;
let menuMusicSource = null;

async function loadMenuMusic(){
  if (!audioCtx || menuMusicBuffer) return;

  try {
    const res = await fetch("audio/Menu.ogg");
    if (!res.ok) throw new Error("HTTP " + res.status);

    const arr = await res.arrayBuffer();
    menuMusicBuffer = await audioCtx.decodeAudioData(arr);

  } catch(e){
    console.warn("Menu music disabled:", e.message);
    menuMusicBuffer = null;
  }
}

function playMenuMusic(){
  if (!audioCtx || !menuMusicBuffer || menuMusicSource) return;

  try {
    const src = audioCtx.createBufferSource();
    src.buffer = menuMusicBuffer;
    src.loop = true;
    src.connect(audioCtx.destination);
    src.start(0);
    menuMusicSource = src;
  } catch(e){}
}

function stopMenuMusic(){
  if (!menuMusicSource) return;

  try {
    menuMusicSource.stop();
    menuMusicSource.disconnect();
  } catch(e){}
  menuMusicSource = null;
}

// =========================================================
// ADS (SAFE GUARDS)
// =========================================================

const USE_REAL_ADS = true;
let adBusy = false;

function showRewardedAd(onSuccess, onFail){
  if (adBusy) return;
  adBusy = true;

  // DEV MODE
  if (!USE_REAL_ADS){
    setTimeout(() => {
      adBusy = false;
      onSuccess && onSuccess();
    }, 800);
    return;
  }

  // PROD
  if (!window.UnityAds || !UnityAds.isReady || !UnityAds.isReady("rewardedVideo")){
    adBusy = false;
    onFail && onFail("not_ready");
    return;
  }

  UnityAds.show("rewardedVideo", {
    onComplete(){
      adBusy = false;
      onSuccess && onSuccess();
    },
    onSkip(){
      adBusy = false;
      onFail && onFail("skipped");
    },
    onError(e){
      adBusy = false;
      onFail && onFail(e);
    }
  });
}

// =========================================================
// FX STATE (SINGLE SOURCE)
// =========================================================

const FX = {
  level: 1,
  preview: false,
  overdrive: false,
  intensity: 1
};

function updateFXState(){
  if (typeof uiState !== "undefined" && uiState === "shop"){
    FX.preview   = true;
    FX.overdrive = false;
    FX.level     = 0;
    FX.intensity = 0.3;
    return;
  }

  FX.preview = false;

  if (gameState === "playing"){
    FX.overdrive = document.body.classList.contains("overdriveActive");
    FX.level     = FX.overdrive ? 2 : 1;
    FX.intensity = FX.overdrive ? 1 : 0.6;
    return;
  }

  FX.level = 0;
  FX.intensity = 0;
  FX.overdrive = false;
}

function updateFXCalm(delta){
  if (delta > 20){
    fxCalm = Math.max(0.55, fxCalm - 0.08);
  } else {
    fxCalm = Math.min(1, fxCalm + 0.05);
  }
}

// =========================================================
// CANVAS QUALITY (SAFE)
// =========================================================

if (ctx){
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
}

// =========================================================
// UI REFERENCES (SAFE INIT)
// =========================================================

const UI = {
  score: null,
  best: null,
  coins: null,
  combo: null,
  overCount: null,
  overFill: null
};

/* =========================
   VIEWPORT (SAFE)
========================= */
function getViewport(){
  // visualViewport peut √™tre instable sur iOS ‚Üí fallback propre
  const vv = window.visualViewport;
  if (vv && typeof vv.width === "number" && typeof vv.height === "number"){
    return { w: vv.width, h: vv.height };
  }
  return { w: window.innerWidth || 0, h: window.innerHeight || 0 };
}

/* =========================
   RESIZE (DPR + CANVAS) ‚Äî SAFE
========================= */
function resizeCanvas(){
  if (!canvas) return;

  const { w, h } = getViewport();
  if (!w || !h) return;

  // DPR plafonn√© (mobile/iOS safe)
  const dpr = window.devicePixelRatio || 1;
  currentDPR = Math.min(dpr, 1.5);

  const cw = Math.round(w * currentDPR);
  const ch = Math.round(h * currentDPR);

  if (canvas.width !== cw)  canvas.width  = cw;
  if (canvas.height !== ch) canvas.height = ch;

  canvas.style.width  = Math.round(w) + "px";
  canvas.style.height = Math.round(h) + "px";

  updateCamera(w, h);
}

/* =========================
   CAMERA (FIT STRICT + LETTERBOX)
========================= */
let VIEW_W = 0;
let VIEW_H = 0;
let OFF_X  = 0;
let OFF_Y  = 0;

function updateCamera(vw, vh){
  if (!vw || !vh) return;

  const scaleX = vw / BASE_W;
  const scaleY = vh / BASE_H;

  // gameplay non d√©form√©
  cameraScale = Math.min(scaleX, scaleY);

  cameraOffsetX = (vw - BASE_W * cameraScale) * 0.5;
  cameraOffsetY = (vh - BASE_H * cameraScale) * 0.5;

  // dimensions visibles en coordonn√©es monde
  VIEW_W = vw / cameraScale;
  VIEW_H = vh / cameraScale;

  // zones hors gameplay (bandes)
  OFF_X = Math.max(0, (VIEW_W - BASE_W) * 0.5);
  OFF_Y = Math.max(0, (VIEW_H - BASE_H) * 0.5);
}

/* =========================
   LISTENERS RESIZE (SAFE)
========================= */
window.addEventListener("resize", resizeCanvas, { passive:true });

if (window.visualViewport){
  window.visualViewport.addEventListener("resize", resizeCanvas, { passive:true });
}

resizeCanvas();

/* =========================
   UI BINDING (SAFE)
========================= */
let uiBound = false;

function bindUI(){
  if (uiBound) return;
  uiBound = true;

  UI.score     = document.getElementById("uiScore")        || null;
  UI.best      = document.getElementById("uiBest")         || null;
  UI.coins     = document.getElementById("coinCount")      || null;
  UI.combo     = document.getElementById("comboVal")       || null;
  UI.overCount = document.getElementById("overdriveCount") || null;
  UI.overFill  = document.getElementById("overdriveBarInner") || null;
}

function safeText(el, value){
  if (el) el.textContent = value;
}

/* =========================
   INPUT ZONE (POINTER SAFE)
========================= */
const touchZone = document.getElementById("touchZone");

if (touchZone){

  // d√©tecte environnement tactile une seule fois
  window.addEventListener("touchstart", () => {
    isTouch = true;
  }, { once:true, passive:true });

  let lastPointerTime = 0;

  // PRESS ‚Üí jet ON
  touchZone.addEventListener("pointerdown", (e) => {
    if (uiState !== "playing") return;

    const now = performance.now();
    if (now - lastPointerTime < 220){
      e.preventDefault();
      return;
    }
    lastPointerTime = now;

    e.preventDefault();
    jetStart();
  });

  // bloque dblclick desktop
  touchZone.addEventListener("dblclick", e => {
    e.preventDefault();
  });

  // RELEASE ‚Üí jet OFF
  function stopJet(e){
    if (uiState !== "playing") return;
    if (e && e.preventDefault) e.preventDefault();
    jetStop();
  }

  touchZone.addEventListener("pointerup", stopJet);
  touchZone.addEventListener("pointercancel", stopJet);
  touchZone.addEventListener("pointerleave", stopJet);
  touchZone.addEventListener("pointerout", stopJet);
}




/* ============================
   AUDIO MANAGER (STABLE)
============================ */

// üî¥ supprim√© : gameMusicStopTimer (inutile, jamais utilis√©)

const musicMenu = document.getElementById("musicMenu");
const musicGame = document.getElementById("musicGame");
const sfxDeath  = document.getElementById("sfxDeath");
const sfxOverdrive = document.getElementById("sfxOverdrive");

const audioSettings =
  JSON.parse(localStorage.getItem("audioSettings") || "null")
  || { music:70, sfx:80, mute:false };

// volumes fixes
if (sfxOverdrive) sfxOverdrive.volume = 0.3;

// üîê verrou navigateur (iOS / Chrome mobile)
let audioUnlocked = false;
let currentMusic = "none"; // "menu" | "game" | "none"

function clamp01(v){
  return Math.max(0, Math.min(1, v));
}

/* =========================
   AUDIO UNLOCK (CRITIQUE)
========================= */
function unlockAudio(){
  if (audioUnlocked) return;
  audioUnlocked = true;

  // ‚ö†Ô∏è d√©verrouille HTMLAudio
  [musicMenu, musicGame, sfxDeath, sfxOverdrive].forEach(a => {
    if (!a) return;
    try {
      a.muted = true;
      a.play().then(() => {
        a.pause();
        a.currentTime = 0;
        a.muted = false;
      }).catch(()=>{});
    } catch(e){}
  });

  // ‚ö†Ô∏è d√©verrouille AudioContext (menu video / music)
  if (window.audioCtx && audioCtx.state === "suspended"){
    audioCtx.resume().catch(()=>{});
  }

  // reprend la musique demand√©e
  if (currentMusic !== "none"){
    playMusic(currentMusic);
  }
}

// üëÜ UN SEUL gesture suffit
window.addEventListener("pointerdown", unlockAudio, { once:true });
window.addEventListener("touchstart", unlockAudio, { once:true });

/* =========================
   SETTINGS
========================= */
function applyAudioSettings(){
  const m = audioSettings.mute ? 0 : clamp01(audioSettings.music / 100);
  const s = audioSettings.mute ? 0 : clamp01(audioSettings.sfx / 100);

  if (musicMenu) musicMenu.volume = m * 0.9;
  if (musicGame) musicGame.volume = m;
  if (sfxDeath)  sfxDeath.volume  = s;
}

/* =========================
   CORE CONTROL
========================= */
function stopMusic(track){
  if (!track) return;
  try { track.pause(); } catch(e){}
  try { track.currentTime = 0; } catch(e){}
}

function playMusic(which){
  currentMusic = which;

  if (!audioUnlocked) return;

  if (audioSettings.mute){
    stopMusic(musicMenu);
    stopMusic(musicGame);
    return;
  }

  applyAudioSettings();

  if (which === "menu"){
    stopMusic(musicGame);
    if (musicMenu){
      musicMenu.loop = true;
      musicMenu.volume = clamp01(audioSettings.music/100) * 0.9;
      musicMenu.play().catch(()=>{});
    }
    return;
  }

  if (which === "game"){
    stopMusic(musicMenu);
    if (musicGame){
      musicGame.loop = true;
      musicGame.volume = clamp01(audioSettings.music/100);
      musicGame.play().catch(()=>{});
    }
    return;
  }

  stopMusic(musicMenu);
  stopMusic(musicGame);
}

/* =========================
   FADE (OPTIONNEL, SAFE)
========================= */
function fadeAudio(audio, targetVolume, duration = 260){
  if (!audio || audioSettings.mute) return;

  const start = audio.volume;
  const delta = targetVolume - start;
  const startTime = performance.now();

  function step(now){
    const t = Math.min(1, (now - startTime) / duration);
    audio.volume = start + delta * t;
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================
   UI OPTIONS
========================= */
const optMusic = document.getElementById("optMusic");
const optSfx   = document.getElementById("optSfx");
const optMute  = document.getElementById("optMute");

if (optMusic && optSfx && optMute){

  optMusic.value  = audioSettings.music;
  optSfx.value    = audioSettings.sfx;
  optMute.checked = audioSettings.mute;

  optMusic.addEventListener("input", () => {
    audioSettings.music = +optMusic.value;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
    applyAudioSettings();
    playMusic(currentMusic);
  });

  optSfx.addEventListener("input", () => {
    audioSettings.sfx = +optSfx.value;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
    applyAudioSettings();
  });

  optMute.addEventListener("change", () => {
    audioSettings.mute = optMute.checked;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));

    if (audioSettings.mute){
      playMusic("none");
    } else {
      if (gameState === "playing") playMusic("game");
      else playMusic("menu");
    }
  });
}

applyAudioSettings();
bindUI();


/* =========================
   GAME OVER / CORE STATE
========================== */

// --- GAME OVER UI ---
const finalScoreEl = document.getElementById("finalScore");
const finalBestEl  = document.getElementById("finalBest");
const finalCoinsEl = document.getElementById("finalCoins");

// --- OVERLAYS ---
const overlayMenu     = document.getElementById("menuOverlay");
const overlayGameOver = document.getElementById("overlayGameOver");

// --- INPUT ---
const restartBtn = document.getElementById("restartBtn");

// --- OVERDRIVE UI ---
const OVERDRIVE_MAX = 20;
const overdriveBar     = document.getElementById("overdriveBarInner");
const overdriveCountEl = document.getElementById("overdriveCount");

// --- FX / HUD ---
const tint     = document.getElementById("tint");
const comboVal = document.getElementById("comboVal");

// --- MENUS / PANELS ---
const overlayIntro   = document.getElementById("overlayIntro");
const optionsPanelEl = document.getElementById("optionsPanel");
const transitionFX   = document.getElementById("transitionFX");

// --- AUDIO ---
const sfxIntro = document.getElementById("sfxIntro");

/* =========================
   UI SAFETY
========================= */

function safeStyle(el, prop, value){
  if (el) el.style[prop] = value;
}

/* =========================
   OVERDRIVE LOGIC
========================= */
function addOverdrive(amount){
  if (overdriveActive) return;

  overdrive += amount;

  if (overdrive >= OVERDRIVE_THRESHOLD){
    overdrive = 0;
    activateOverdrive();
  }

  updateOverdriveUI();
}

function activateOverdrive(){
  if (overdriveActive) return;
  overdriveEndingFlag = false;

  overdriveActive = true;
  overdriveTimer = overdriveDuration;

  document.body.classList.add("overdriveActive");
  document.body.classList.remove("overdriveEnding");

  if (sfxOverdrive && !audioSettings.mute){
    sfxOverdrive.volume = clamp01(audioSettings.sfx / 100);
    sfxOverdrive.currentTime = 0;
    sfxOverdrive.play().catch(()=>{});
  }
}

function deactivateOverdrive(){
  overdriveActive = false;
  overdriveTimer = 0;
  overdrive = 0;

  document.body.classList.remove("overdriveActive");
  document.body.classList.remove("overdriveEnding");

  updateOverdriveUI();
}

function updateOverdriveUI(){
  if (overdriveActive) return;

  const ratio = Math.min(1, overdrive / OVERDRIVE_THRESHOLD);
  if (UI.overFill)  UI.overFill.style.height = (ratio * 100) + "%";
  if (UI.overCount) UI.overCount.textContent = Math.floor(overdrive);
}

/* =========================
   INTRO TRANSITION (SAFE)
========================= */
function playIntroTransition(){
  if (!overlayIntro) return;

  // ‚ùå PAS DE audioUnlocked = true ICI

  overlayIntro.classList.add("fx-impact");
  transitionFX?.classList.add("flash");

  if (!audioSettings.mute && sfxIntro){
    sfxIntro.currentTime = 0;
    sfxIntro.volume = clamp01(audioSettings.sfx / 100);
    sfxIntro.play().catch(()=>{});
  }

  setTimeout(() => {
    playMusic("menu");
  }, 120);

  setTimeout(() => {
    overlayIntro.style.display = "none";
    overlayMenu.style.display = "flex";
    transitionFX?.classList.remove("flash");
  }, 420);
}

if (overlayIntro){
  overlayIntro.addEventListener("pointerdown", playIntroTransition, { once:true });
  overlayIntro.addEventListener("touchstart", playIntroTransition, { passive:true, once:true });
}

/* =========================
   PERF MODE (FIXED)
========================= */
let PERF_MODE = "HIGH"; // HIGH | MED | LOW

function updatePerf(){
  const f = FXQuality.fps();
  if (f < 42) PERF_MODE = "LOW";
  else if (f < 55) PERF_MODE = "MED";
  else PERF_MODE = "HIGH";
}

/* =========================
   PLAYER / WORLD STATE
========================= */
const player = { x:100, y:BASE_H/2, width:36, height:32, vy:0 };
const BASE_PLAYER_W = 36;
const BASE_PLAYER_H = 32;

const GRAVITY = 0.42;
const THRUST  = -0.8;
let jetOn = false;

let obstacles = [];
let coins     = [];
let bullets   = [];

let obstacleSpeed = 3.8;
let lastSpawn = 0;
let score = 0;
// ================= PERF MEMORY (ANTI-LAG) =================
let _lastScore = -1;
let _lastCoins = -1;
let _lastCombo = -1;
let coinsCollected = 0;
let pendingCoins   = 0;

let newRecordThisRun = false;
/* =========================================================
   üíæ DATA & SKIN ENGINE V2 (ROBUSTE)
========================================================= */

// 1. CONFIGURATION DES SKINS (Source de v√©rit√© unique)
const SKINS_DB = {
  moony: {
    name: "Moony", category: "common", price: 0,
    trail: { color: "rgba(235,230,200,0.95)", glow: 6, size: 1.8, shape: "round" }
  },
  forest: {
    name: "Forest", category: "common", price: 350,
    trail: { color: "rgba(150,200,120,0.85)", glow: 6, size: 1.6, shape: "round" }
  },
  arctic: {
    name: "Arctic", category: "rare", price: 900,
    trail: { color: "rgba(210,235,255,0.95)", glow: 8, size: 1.5, shape: "snow" }
  },
  solar: {
    name: "Solar", category: "rare", price: 900,
    trail: { color: "rgba(255,200,80,0.95)", glow: 10, size: 1.9, shape: "spark" }
  },
  inferno: {
    name: "Inferno", category: "epic", price: 1600,
    trail: { color: "rgba(255,120,60,0.95)", glow: 14, size: 2.0, shape: "ember" }
  },
  neon: {
    name: "Neon", category: "epic", price: 2200,
    trail: { color: "rgba(0,255,255,0.95)", glow: 12, size: 1.6, shape: "line" }
  },
  voidwalker: {
    name: "Voidwalker", category: "legendary", price: 3500,
    trail: { color: "rgba(160,120,220,0.8)", glow: 16, size: 2.2, shape: "void" }
  }
};

const SKIN_KEYS = Object.keys(SKINS_DB);

// 2. √âTAT DU JOUEUR (Chargement s√©curis√©)
let Player = {
  coins: 0,
  bestScore: 0,
  unlocked: ["moony"], // IDs des skins poss√©d√©s
  equipped: "moony",   // ID du skin actuel
  
  load: function(){
    try {
      this.coins = Number(localStorage.getItem("coinsBank") || 0);
      this.bestScore = Number(localStorage.getItem("bestScore") || 0);
      
      const savedSkins = JSON.parse(localStorage.getItem("ownedSkins") || '["moony"]');
      this.unlocked = Array.isArray(savedSkins) ? savedSkins : ["moony"];
      
      const savedEquip = localStorage.getItem("currentSkin");
      this.equipped = (savedEquip && SKINS_DB[savedEquip]) ? savedEquip : "moony";
      
    } catch(e){ console.warn("Save reset", e); }
  },
  
  save: function(){
    localStorage.setItem("coinsBank", this.coins);
    localStorage.setItem("bestScore", this.bestScore);
    localStorage.setItem("ownedSkins", JSON.stringify(this.unlocked));
    localStorage.setItem("currentSkin", this.equipped);
    
    // Met √† jour l'UI globale
    updateMenuStats(); 
  },
  
  buy: function(skinId){
    const skin = SKINS_DB[skinId];
    if (!skin) return false;
    if (this.coins >= skin.price){
      this.coins -= skin.price;
      this.unlocked.push(skinId);
      this.equipped = skinId; // Auto-equip
      this.save();
      return true;
    }
    return false;
  },
  
  equip: function(skinId){
    if (this.unlocked.includes(skinId)){
      this.equipped = skinId;
      this.save();
      return true;
    }
    return false;
  }
};

// Initialisation imm√©diate
Player.load();

// Variables globales de compatibilit√© (pour le reste du jeu)
let currentSkin = Player.equipped; // Alias pour le moteur de jeu
let coinsBank = Player.coins;      // Alias
let bestScore = Player.bestScore;  // Alias

/* =========================
   OVERDRIVE / RUN STATE
========================= */
let overdriveActive = false;
let overdriveTimer  = 0;

const OVERDRIVE_DURATION_BASE = 3000;
let overdriveDuration = OVERDRIVE_DURATION_BASE;

const OVERDRIVE_THRESHOLD = 20;
let overdrive = 0; // charge actuelle

let dyingTimer = 0;
let dyingFromCircle = null;

let lastType = null;
let lastIntensity = 0;

// combo
let combo = 1;
let lastCoinTime = 0;

// FX collision
let particles = [];
let shake = 0;
let shockwave = null;
let bloom = null;
let deathOrigin = null; // {x,y}
let lastShakeX = 0;
let lastShakeY = 0;

/* =========================================================
   ENGINE v1.0 ‚Äî PHASES / RYTHME / SPAWN
   (API FROZEN ‚Äî AUCUN HACK RUNTIME)
========================================================= */

/* =========================
   PHASES & RYTHME GLOBAL
========================= */

// seuils score ‚Üí phase
const PHASE_LIMITS = [8000, 22000, 45000, 85000];

// param√®tres globaux par phase
const PACE_MULT = [1.0, 1.25, 1.55, 1.9, 2.3];
const SPAWN_MS  = [1120, 940, 780, 660, 560];
const MOVE_AMP  = [20, 48, 78, 105, 130];

/* =========================
   PHASE DETECTION
========================= */
function phase(score){
  if (score < PHASE_LIMITS[0]) return 0; // onboarding
  if (score < PHASE_LIMITS[1]) return 1; // flow
  if (score < PHASE_LIMITS[2]) return 2; // pression
  if (score < PHASE_LIMITS[3]) return 3; // chaos contr√¥l√©
  return 4;                              // endgame
}

/* =========================
   ACC√àS RAPIDES (SANS ALLOC)
========================= */
function paceMultiplier(score){
  return PACE_MULT[phase(score)];
}

function currentSpawnInterval(score){
  return SPAWN_MS[phase(score)];
}

function movingAmplitude(score){
  return MOVE_AMP[phase(score)];
}

/* =========================
   FREQUENCES OBSTACLES
========================= */
const FREQ = {
  0: { rotbar:0.08, circle:0.18, turret:0.00, mover:0.16, sweeper:0.06, gap:0.52, chicane:0.00, zig:0.00 },
  1: { rotbar:0.17, circle:0.18, turret:0.08, mover:0.20, sweeper:0.08, gap:0.23, chicane:0.04, zig:0.02 },
  2: { rotbar:0.21, circle:0.18, turret:0.13, mover:0.20, sweeper:0.09, gap:0.12, chicane:0.04, zig:0.03 },
  3: { rotbar:0.24, circle:0.18, turret:0.17, mover:0.20, sweeper:0.10, gap:0.07, chicane:0.03, zig:0.01 },
  4: { rotbar:0.26, circle:0.18, turret:0.20, mover:0.20, sweeper:0.10, gap:0.04, chicane:0.01, zig:0.01 }
};

function currentFreq(score){
  return FREQ[phase(score)];
}

/* =========================
   POIDS OBSTACLES (DENSIT√â)
========================= */
const OBSTACLE_WEIGHT = {
  gap:     0,
  circle:  1,
  mover:   1,
  sweeper: 1,
  turret:  2,
  rotbar:  2
};

/* =========================
   HELPERS G√âN√âRAUX
========================= */
function randomRange(a,b){
  return a + Math.random() * (b - a);
}

function clamp(v,a,b){
  return Math.max(a, Math.min(b, v));
}

/* =========================
   MONDE & CAMERA
========================= */
const WORLD_W = BASE_W;
const WORLD_H = BASE_H;

// distance de spawn anticip√© (API v1.0)
const SAFE_SPAWN_AHEAD = BASE_W * 1.3;

/* =========================
   FAR RIGHT CACHE (SPAWN SAFE)
========================= */
let farRightCache = 0;
let farRightFrame = -1;

function farRightX(){
  if (farRightFrame === frameCount) return farRightCache;

  let mx = -1e9;

  for (const ob of obstacles){
    let right;

    switch (ob.kind){
      case 'rotbar':
        right = ob.cx + ob.len;
        break;
      case 'circle':
        right = ob.x + ob.r;
        break;
      default:
        right = (ob.x || 0) + (ob.width || 0);
        break;
    }

    if (right > mx) mx = right;
  }

  farRightCache = mx + 60; // marge SAFE moteur
  farRightFrame = frameCount;
  return farRightCache;
}

/* =========================
   COLLISION ‚Äî AABB vs OBB
========================= */
function aabbVsOBB(ax,ay,aw,ah, cx,cy, halfW, halfH, angle){
  const c = Math.cos(angle);
  const s = Math.sin(angle);

  const dax = (ax + aw * 0.5) - cx;
  const day = (ay + ah * 0.5) - cy;

  const lx =  dax * c + day * s;
  const ly = -dax * s + day * c;

  const ex = Math.abs(aw * 0.5 * c) + Math.abs(ah * 0.5 * s);
  const ey = Math.abs(aw * 0.5 * s) + Math.abs(ah * 0.5 * c);

  const skin = 1.5;

  return (
    Math.abs(lx) <= (halfW - skin) + ex &&
    Math.abs(ly) <= (halfH - skin) + ey
  );
}

/* =========================
   COINS ‚Äî SPAWN ENGINE v1.0
========================= */
/*
  R√àGLE FONDAMENTALE :
  - aucun spawn li√© √† la visibilit√©
  - spawn TOUJOURS anticip√© (SAFE_SPAWN_AHEAD)
  - draw() ne fait QUE dessiner
*/

function pushCoinsAround(x, y, r, base, extra = 0){
  const n = base + extra;

  for (let i = 0; i < n; i++){
    const ang  = (Math.PI * 2 * i / n) + randomRange(-0.1, 0.1);
    const dist = r + randomRange(20, 34);

    coins.push({
      x: x + Math.cos(ang) * dist,
      y: y + Math.sin(ang) * dist,
      r: 7
    });
  }
}


/* =========================
   GAP
========================= */
function spawnGap(ph){
  const gapH = 120 + Math.random() * 60;

  const minY = 40;
  const maxY = WORLD_H - 40 - gapH;
  if (maxY <= minY) return;

  const gapY = minY + Math.random() * (maxY - minY);
  const w = 44;
  const x = WORLD_W + SPAWN_MARGIN_X;

  // s√©curit√© rotbar
  for (const ob of obstacles){
    if (ob.kind === "rotbar"){
      const right = ob.cx + ob.len;
      if (right > WORLD_W - 120 && right < WORLD_W + SPAWN_MARGIN_X + 200){
        return;
      }
    }
  }

  obstacles.push({ kind:"rect", x, y:0, width:w, height:gapY, type:"top" });
  obstacles.push({
    kind:"rect",
    x,
    y:gapY + gapH,
    width:w,
    height:WORLD_H - (gapY + gapH),
    type:"bottom"
  });

  const count = 4 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++){
    coins.push({
      x: x + 80 + i * 34,
      y: clamp(gapY + gapH * 0.5 + Math.sin(i) * gapH * 0.35, 30, WORLD_H - 30),
      r: 7
    });
  }
}


/* =========================
   CIRCLE
========================= */
function spawnCircle(ph){
  const r  = randomRange(42, 58);
  const cy = randomRange(70, WORLD_H - 70);
  const cx = WORLD_W + SPAWN_MARGIN_X;

  obstacles.push({
    kind:"circle",
    x:cx,
    y:cy,
    r,
    rot:0,
    t:Math.random() * Math.PI * 2
  });

  pushCoinsAround(cx, cy, r, 3, (ph >= 2) + (ph >= 3));
}

/* =========================
   MOVER
========================= */
function spawnMover(ph){
  const w = 42;
  const h = randomRange(90, 180);

  const baseY = Math.random() < 0.5 ? 0 : WORLD_H - h;
  const speed = randomRange(1.0, 1.9) * (1 + ph * 0.15);
  const x = WORLD_W + SPAWN_MARGIN_X;

  obstacles.push({
    kind:"movingRect",
    x,
    y:baseY,
    width:w,
    height:h,
    baseY,
    t:Math.random() * Math.PI * 2,
    amp:movingAmplitude(score),
    speed
  });

  coins.push({
    x:x + 90,
    y:clamp(baseY === 0 ? h + 50 : baseY - 50, 30, WORLD_H - 30),
    r:7
  });
}


/* =========================
   ROTBAR
========================= */
function spawnRotbar(ph){
  const now = renderTime;
  const minGapMs = (ph <= 1) ? 24000 : 19000;

  if (now - lastBarTime < minGapMs && Math.random() < 0.7) return;

  for (const ob of obstacles){
    if (ob.kind === "rotbar"){
      if (ob.cx + ob.len > WORLD_W - 120) return;
    }
  }

  lastBarTime = now;

  const len = randomRange(95, 140);
  const cx  = WORLD_W + SPAWN_MARGIN_X + 200;
  const cy  = randomRange(80, WORLD_H - 80);

  obstacles.push({
    kind: "rotbar",
    cx,
    cy,
    len,
    angle: Math.random() * Math.PI,
    speed: randomRange(0.019, 0.055) * (1 + ph * 0.25),
    half: 7
  });

  for (let i = 0; i < 3; i++){
    coins.push({
      x: cx + Math.cos(i - 1) * (len + 28),
      y: cy + Math.sin(i - 1) * (len + 28),
      r: 7
    });
  }
}



/* =========================
   SWEEPER
========================= */
function spawnSweeper(ph){
  const w = 32;
  const h = randomRange(110, 180);

  const x = WORLD_W + SPAWN_MARGIN_X;
  const y = randomRange(0, WORLD_H - h);

  obstacles.push({
    kind: "sweeper",
    x,
    y,
    width: w,
    height: h,
    vy: randomRange(1.2, 2.0) * (Math.random() < 0.5 ? 1 : -1) * (1 + ph * 0.18)
  });

  for (let i = 0; i < 3; i++){
    coins.push({
      x: x + 80 + i * 22,
      y: y + i * 14,
      r: 7
    });
  }
}


/* =========================
   TURRET
========================= */
function canPlaceTurret(){
  const limit = WORLD_W + OFF_X + 280;

  for(const ob of obstacles){
    const right = (ob.kind==='rotbar')
      ? ob.cx + ob.len
      : (ob.kind==='circle')
        ? ob.x + ob.r
        : (ob.x||0) + (ob.width||0);

    if (right > WORLD_W && right < limit){
      if (ob.kind==='movingRect' || ob.kind==='sweeper' || ob.kind==='rotbar'){
        return false;
      }
    }
  }
  return true;
}
/* =========================
   TURRET PARAMETERS (COMPATIBLE AVEC TON MOTEUR)
========================= */
function turretParams(ph){
  // ph est d√©j√† re√ßu depuis spawn(), pas besoin de recalculer le score
  const phase = ph || 0;

  return {
    // Noms de propri√©t√©s align√©s avec spawnTurret :
    bullet: 3.8 + (phase * 0.6),            // Ton code attend .bullet
    fireMs: Math.max(700, 2200 - (phase * 300)),
    reposition: Math.max(1200, 3500 - (phase * 400)), // Ton code attend .reposition
    spread: 30 + (phase * 5)                // Ton code attend .spread
  };
}
function spawnTurret(ph){
  if (ph === 0) return;

  // ‚úÖ FIX: Check if we have space before spawning
  if (!canPlaceTurret()) {
      // If we can't place a turret, spawn a gap or circle instead to keep flow
      if(Math.random() < 0.5) spawnGap(ph); 
      else spawnCircle(ph);
      return;
  }

  const x = WORLD_W + SPAWN_MARGIN_X;
  const y = clamp(player.y + randomRange(-60,60), 60, WORLD_H - 60);
  const p = turretParams(ph);

  obstacles.push({
    kind:"turret",
    x, y,
    w:36, h:26,
    t:0,
    next:p.fireMs * 0.6,
    fireMs:p.fireMs,
    bulletSpeed:p.bullet,
    reTimer:p.reposition,
    reBase:p.reposition,
    spread:p.spread
  });

  for(let i=0;i<3;i++){
    coins.push({ x:x+70+i*22, y:y+(i-1)*14, r:7 });
  }
}

/* =========================
   BULLET
========================= */
function spawnBullet(tx, ty, speed){
  bullets.push({
    x: tx - 6,
    y: ty,
    r: 5,
    vx: -speed
  });
}

/* =========================
   DISPATCHER (FIT 16:9 SAFE)
========================= */
function spawn(){
  const now = renderTime;
  const ph  = phase(score);
  const minGap = 90 - ph * 8;
  const overlapTolerance = Math.max(140, 420 - ph * 70);

  if (farRightX() > WORLD_W + SPAWN_MARGIN_X + minGap){
    if (now - lastSpawnTime < overlapTolerance) return;
  }

  const freq = FREQ[ph];
  const entries = Object.entries(freq);

  let r = Math.random();
  let sum = 0;
  for (const [, p] of entries) sum += p;

  let pick = null;
  let acc  = 0;

  for (const [name, p] of entries){
    acc += p;
    if (r * sum <= acc){
      pick = name;
      break;
    }
  }

  if (pick === lastType && Math.random() < 0.6){
    pick = "gap";
  }
  lastType = pick;

  const intensity = OBSTACLE_WEIGHT[pick] || 0;

  if (typeof lastIntensity !== "undefined"){
    if (lastIntensity >= 2 && intensity >= 2){
      pick = "gap";
    }
    if ((intensity - lastIntensity) >= 2 && Math.random() < 0.6){
      pick = "circle";
    }
  }
  lastIntensity = intensity;

  lastSpawnTime = now;

  switch (pick){
    case "gap":     spawnGap(ph);     break;
    case "circle":  spawnCircle(ph);  break;
    case "mover":   spawnMover(ph);   break;
    case "rotbar":  spawnRotbar(ph);  break;
    case "sweeper": spawnSweeper(ph); break;
    case "turret":  spawnTurret(ph);  break;
    default:        spawnGap(ph);
  }
}






// death / FX
function startDeath(fromCircle, circle, typeTag=null){
  if (gameState === 'dying' || gameState === 'gameover') return;

  gameState = 'dying';
  dyingTimer = 520;
  gameOverTriggered = false;

  // ‚úÖ origine FIXE (ne suivra plus les modifs de player.x/y/scale pendant dying)
  const px = player.x + player.width/2;
  const py = player.y + player.height/2;
  deathOrigin = { x:px, y:py };

  // ‚úÖ SAFE : si circle est null, on √©vite le crash
  dyingFromCircle = (fromCircle && circle) ? { x: circle.x, y: circle.y } : null;

  // --- AUDIO MORT ---
  if (typeof musicGame !== "undefined" && musicGame) {
    fadeAudio(musicGame, 0.2, 220);
  }
  if (typeof sfxDeath !== "undefined" && sfxDeath) {
    try{
      sfxDeath.currentTime = 0;
      sfxDeath.volume = audioSettings.mute ? 0 : clamp01(audioSettings.sfx / 100);
      sfxDeath.play().catch(()=>{});
    }catch(e){}
  }

  // --- PARTICULES ---
  particles.length = 0;
  const n = 26;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = fromCircle ? randomRange(1.2,2.1) : randomRange(1.8,3.2);
    const life = randomRange(420,700);
    const col = typeTag==='bullet'
      ? 'rgba(255,255,255,0.9)'
      : (fromCircle ? 'rgba(255,128,96,0.9)' : 'rgba(255,200,80,0.9)');

    particles.push({
      x:px,y:py,
      vx:Math.cos(ang)*spd,
      vy:Math.sin(ang)*spd,
      life,age:0,col,
      sz:randomRange(2,4)
    });
  }

  // --- SHOCKWAVE / BLOOM ---
  shockwave = { x:px, y:py, r:0, alpha:1, max:180 };
  bloom = { x:px, y:py, a:0.6 };
}
// ================================
// DAILY ADS SYSTEM (SAFE + CLEAN)
// ================================

const ADS_MAX_PER_DAY    = 5;
const AD_REWARD_COINS   = 49;

// üîí √©tat journalier
let adsDate             = "";
let adsWatchedToday     = 0;
let isWatchingDailyAd   = false;

// ================================
// DATE UTILS (YYYY-MM-DD, LOCAL SAFE)
// ================================
function getTodayKey(){
  const d = new Date();
  return (
    d.getFullYear() + "-" +
    String(d.getMonth()+1).padStart(2,"0") + "-" +
    String(d.getDate()).padStart(2,"0")
  );
}

// ================================
// INIT / RESET JOURNALIER
// ================================
function initDailyAds(){
  const today = getTodayKey();

  adsDate = localStorage.getItem("adsDate");
  adsWatchedToday = Number(localStorage.getItem("adsCount") || 0);

  if (adsDate !== today){
    adsDate = today;
    adsWatchedToday = 0;
    localStorage.setItem("adsDate", today);
    localStorage.setItem("adsCount", "0");
  }
}

// ================================
// SAVE
// ================================
function saveDailyAds(){
  localStorage.setItem("adsCount", String(adsWatchedToday));
}

// ================================
// HELPERS
// ================================
function adsLeftToday(){
  return Math.max(0, ADS_MAX_PER_DAY - adsWatchedToday);
}

function canWatchAd(){
  return adsLeftToday() > 0 && !isWatchingDailyAd;
}

// ================================
// WATCH AD FOR COINS
// ================================
function watchAdForCoins(source = "menu"){
  if (!canWatchAd()) return;

  isWatchingDailyAd = true;
  updateAdButtonState(source, "loading");

  showRewardedAd(
    () => {
      // ‚úÖ SUCC√àS
      coinsBank += AD_REWARD_COINS;
      adsWatchedToday++;

      saveDailyAds();
      localStorage.setItem("coinsBank", String(coinsBank));

      updateCoinsUI();
      updateDailyAdsUI();
      updateAdButtonState(source, "ready");
      closeAdOffer(source);

      isWatchingDailyAd = false;
    },
    () => {
      // ‚ùå √âCHEC
      isWatchingDailyAd = false;
      updateAdButtonState(source, "ready");
      console.warn("[ADS] rewarded ad failed");
    }
  );
}

// ================================
// UI ‚Äî COINS
// ================================
function updateCoinsUI(){
  safeText(document.getElementById("menuCoins"), coinsBank.toLocaleString());
  safeText(document.getElementById("shopCoins"), coinsBank.toLocaleString());
}

// ================================
// UI ‚Äî BUTTON STATE
// ================================
function updateAdButtonState(source, state){
  const btn = document.querySelector(
    source === "shop" ? "#shopAdBtn" : "#menuAdBtn"
  );
  if (!btn) return;

  if (state === "loading"){
    btn.textContent = "Loading ad...";
    btn.disabled = true;
    return;
  }

  if (!canWatchAd()){
    btn.textContent = "No ads left today";
    btn.disabled = true;
    return;
  }

  btn.textContent = `Watch ad +${AD_REWARD_COINS} coins`;
  btn.disabled = false;
}

// ================================
// UI ‚Äî DAILY COUNTER
// ================================
function updateDailyAdsUI(){
  const left = adsLeftToday();

  const menuCount = document.getElementById("menuAdCount");
  if (menuCount){
    menuCount.textContent = `${left} / ${ADS_MAX_PER_DAY} ads left`;
  }

  const shopCount = document.getElementById("shopAdCount");
  if (shopCount){
    shopCount.textContent = `${left} / ${ADS_MAX_PER_DAY} ads left today`;
  }

  ["menuAdBtn", "shopAdBtn"].forEach(id => {
    const b = document.getElementById(id);
    if (!b) return;

    if (left <= 0){
      b.disabled = true;
      b.textContent = "No ads left today";
    }
  });
}

// ================================
// MENU AD POPUP (SAFE)
// ================================
let menuAdTimeout   = null;
let menuAdMenuCount = 0;

function showMenuAdPopup(){
  if (uiState !== "menu") return;
  if (gameState !== "menu") return;
  if (!canWatchAd()) return;

  // üëâ 1 fois sur 2 passages menu
  menuAdMenuCount++;
  if (menuAdMenuCount % 2 !== 0) return;

  const el = document.getElementById("menuAdPopup");
  if (!el) return;

  clearTimeout(menuAdTimeout);

  el.style.top = "14px";
  el.style.opacity = "1";

  menuAdTimeout = setTimeout(hideMenuAdPopup, 4000);
}

function hideMenuAdPopup(){
  const el = document.getElementById("menuAdPopup");
  if (!el) return;

  el.style.opacity = "0";
  el.style.top = "-80px";
}




// ================================
// CONTINUE POPUP (AD OFFER) ‚Äî API
// ================================
let canContinueThisRun = true;   // 1 fois par run
let isWatchingAd = false;

let continueTimeout = null;
let continueInterval = null;

function _getContinueEls(){
  return {
    popup: document.getElementById("continuePopup"),
    btn:   document.getElementById("continueAdBtn"),
    secs:  document.getElementById("continueSeconds"),
    timer: document.getElementById("continueTimer")
  };
}

function hideContinuePopup(){
  const { popup } = _getContinueEls();

  if (continueTimeout){
    clearTimeout(continueTimeout);
    continueTimeout = null;
  }
  if (continueInterval){
    clearInterval(continueInterval);
    continueInterval = null;
  }

  if (popup) popup.style.display = "none";
}
function showContinuePopup(durationSec = 2.5){
  const { popup, btn, secs, timer } = _getContinueEls();
  if (!popup || !btn || !secs || !timer) return;

  // s√©curit√© : uniquement en game over
  if (gameState !== "gameover") return;
  if (!canContinueThisRun) return;

  hideContinuePopup();

  popup.style.display = "flex";
  timer.style.display = "block";     // üî• MANQUANT
  timer.style.opacity = "0.7";       // üî• visibilit√©

  btn.disabled = false;
  btn.textContent = "Watch Ad & Continue";

  let timeLeft = durationSec;
  secs.textContent = timeLeft;

  continueInterval = setInterval(() => {
    timeLeft--;
    if (timeLeft < 0) timeLeft = 0;
    secs.textContent = timeLeft;

    if (timeLeft <= 0){
      hideContinuePopup();
    }
  }, 630);

  continueTimeout = setTimeout(() => {
    hideContinuePopup();
  }, durationSec * 630);
}


// ================================
// CLICK ‚Äî WATCH AD
// ================================
function handleContinueAd(){
  if (isWatchingAd) return;
  if (!canContinueThisRun) return;

  isWatchingAd = true;
  canContinueThisRun = false;

  const { btn } = _getContinueEls();
  if (!btn) return;

  btn.textContent = "Loading ad...";
  btn.disabled = true;

  // üéØ VRAIE PUB ICI
  showRewardedAd(
    () => {
      // ‚úÖ PUB COMPL√âT√âE ‚Üí REVIVE
      isWatchingAd = false;
      revivePlayerAfterAd();
    },
    () => {
      // ‚ùå PUB √âCHOU√âE / SKIP / NO FILL
      isWatchingAd = false;

      btn.textContent = "‚ö° Continue";
      btn.disabled = false;

      console.warn("revive ad failed");
    }
  );
}

// ================================
// REVIVE (FORCE SAFE)
// ================================
function revivePlayerAfterAd(){
  hideContinuePopup();

  // =====================
  // üßπ HIDE GAME OVER
  // =====================
  if (overlayGameOver){
    overlayGameOver.classList.remove("visible");
    overlayGameOver.style.display = "none";
    overlayGameOver.style.pointerEvents = "none";
    overlayGameOver.style.opacity = "0";
  }

  // =====================
  // üî• REVIVE STATE
  // =====================
  gameOverTriggered = false;
  gameState = "playing";
  gameRunning = true;

  // =====================
  // üéØ SAFE REPOSITION
  // =====================
  player.x  = 120;
player.y = BASE_H * 0.5;
  player.vy = 0;

  // =====================
  // üõ°Ô∏è INVINCIBILITY (SINGLE SOURCE)
  // =====================
  player.invincible = true;

  setTimeout(() => {
    player.invincible = false;
  }, 3500);

  // =====================
  // üßπ CLEAN DANGERS (IMPORTANT)
  // =====================
  obstacles = obstacles.filter(o => o.x > player.x + 550);
  bullets   = bullets.filter(b => b.x > player.x + 550);

  // =====================
  // ‚ú® RESET DEATH FX
  // =====================
  dyingTimer = 0;
  particles.length = 0;
  shockwave = null;
  bloom = null;
  shake = 0;

  // =====================
  // üéµ AUDIO
  // =====================
  if (musicGame && !audioSettings.mute){
    musicGame.play().catch(()=>{});
  }

  // =====================
  // ‚ñ∂Ô∏è LOOP
  // =====================
  resumeLoop();
}


// ================================
// GAME OVER (COMPLET + SAVE DEDANS)
// ================================
function handleGameOver(){
  if (gameOverTriggered) return;
  gameOverTriggered = true;

  // --- Reset Overdrive ---
  overdriveActive = false;
  overdriveTimer = 0;
  overdrive = 0;
  document.body.classList.remove("overdriveActive");
  if (UI?.overFill) UI.overFill.style.height = "0%";
  if (UI?.overCount) UI.overCount.textContent = "0";

  // --- Audio ---
  stopMusic(musicGame);
  currentMusic = "none";

  // --- State ---
  gameState = "gameover";
  pauseLoop();

  const s = Math.floor(score);

  // --- New Record Check ---
  if (s > bestScore){
    bestScore = s;
    const nr = document.getElementById("newRecord");
    if (nr){
      nr.style.display = "block";
      requestAnimationFrame(() => {
        nr.style.opacity = "1";
        nr.style.transform = "scale(1.2)";
        setTimeout(() => nr.style.transform = "scale(1)", 300);
      });
    }
  }

  // --- UI Game Over ---
  safeText(finalScoreEl, s.toLocaleString());
  safeText(finalBestEl, bestScore.toLocaleString());
  safeText(finalCoinsEl, coinsCollected.toLocaleString());

  if (overlayGameOver){
    overlayGameOver.classList.add("visible");
    overlayGameOver.style.display = "flex";
    overlayGameOver.style.visibility = "visible";
    overlayGameOver.style.opacity = "1";
    overlayGameOver.style.pointerEvents = "auto";
  }

  // ‚úÖ CORRECTION MAJEURE : SYNCHRONISATION & SAUVEGARDE
  coinsBank += coinsCollected; // Ajoute les pi√®ces gagn√©es au global
  
  // 1. On met √† jour l'objet Player avec les valeurs globales
  Player.coins = coinsBank;
  Player.bestScore = bestScore;
  
  // 2. On sauvegarde proprement via l'objet Player
  Player.save();

  // 3. On force la mise √† jour imm√©diate de l'affichage du Menu Principal
  // (Comme √ßa, quand on clique sur "Menu", c'est d√©j√† √† jour)
  updateMenuStats(); 

  deathOrigin = null;

  // Popup continue
  setTimeout(() => {
    showContinuePopup(4);
  }, 1200);
}
function updateRoulette(list){
  const rect = list.getBoundingClientRect();
  const center = rect.left + rect.width / 2;

  list.querySelectorAll(".skinCard").forEach(card=>{
    const r = card.getBoundingClientRect();
    const cardCenter = r.left + r.width / 2;
    const d = (cardCenter - center) / rect.width;

    const scale = 1 - Math.abs(d) * 0.4;
    const rotateY = d * 28;
    const opacity = 1 - Math.abs(d) * 0.6;

    card.style.transform =
      `scale(${scale}) rotateY(${rotateY}deg)`;
    card.style.opacity = opacity;
  });
}
function initSkinRoulette(){
  document.querySelectorAll(".skinList").forEach(list=>{
    const onScroll = ()=>{
      requestAnimationFrame(()=>updateRoulette(list));
    };
    list.addEventListener("scroll", onScroll, { passive:true });
    updateRoulette(list);
  });
}
// ================= PARTICLES GLOBALS (OBLIGATOIRES) =================
const PARTICLE_POOL_SIZE = FXQuality?.isMobile ? 80 : 160;

const particlePool = [];
const playerParticles = [];

let poolIndex = 0;
let lastTrailSpawn = 0;
for (let i = 0; i < PARTICLE_POOL_SIZE; i++){
  particlePool.push({
    active:false,
    x:0, y:0,
    vx:0, vy:0,
    life:0, lifeMax:0,
    size:0, glow:0,
    seed:0,
    shape:"default",
    color:"#fff",
    jx:null, js:null
  });
}
/* =========================
   SPAWN PLAYER TRAIL (POOL SAFE / FINAL)
========================= */
function spawnPlayerTrail(x, y, skin){
  const now = renderTime || performance.now();

  // üîí throttle CRITIQUE (mobile / FX heavy)
  const delay = FXQuality.isMobile ? 24 : 16;
  if (now - lastTrailSpawn < delay) return;
  lastTrailSpawn = now;

  // üîí pool circulaire (AUCUNE ALLOC)
  const p = particlePool[poolIndex];
  poolIndex = (poolIndex + 1) % PARTICLE_POOL_SIZE;

  // ===== RESET COMPLET =====
  p.active  = true;
  p.x = x;
  p.y = y;

  p.vx = -1.4 - Math.random() * 0.6;
  p.vy = (Math.random() - 0.5) * 0.6;

  p.life    = 26;
  p.lifeMax = 26;

  p.seed = Math.random() * 999;
  p.jx = null;
  p.js = null;

  p.size = overdriveActive ? 2.6 : 3.6;
  p.glow = overdriveActive ? 8 : 14;

  p.shape = "default";
  p.color = "rgba(230,240,255,0.9)";

  // ===== SKIN VARIANTS =====
  switch (skin){
    case "solar":
      p.shape = "solar";
      p.color = "rgba(255,210,90,1)";
      p.glow  = overdriveActive ? 10 : 18;
      break;

    case "neon":
      p.shape = "line";
      p.color = "rgba(120,220,255,1)";
      p.glow  = 12;
      break;

    case "inferno":
      p.shape = "ember";
      p.color = "rgba(255,120,40,1)";
      p.glow  = 16;
      break;

    case "arctic":
      p.shape = "snow";
      p.color = "rgba(220,245,255,1)";
      p.glow  = 6;
      break;

    case "forest":
      p.shape = "leaf";
      p.color = "rgba(120,200,120,1)";
      p.glow  = 6;
      break;

    case "voidwalker":
      p.shape = "void";
      p.color = "rgba(140,110,220,1)";
      p.glow  = 14;
      break;
  }

  // ===== REGISTER (SANS DUPLICAT) =====
  if (!p._inList){
    p._inList = true;
    playerParticles.push(p);
  }
}


// ================= CAMERA SHAKE (GLOBAL SAFE) =================
let shakeX = 0, shakeY = 0;
let shakeTime = 0, shakePower = 0;

function triggerShake(power = 6, duration = 120){
  shakePower = Math.max(shakePower, power);
  shakeTime = duration;
}

function updateShake(delta){
  if (shakeTime > 0){
    const prev = shakeTime;
    shakeTime -= delta;

    const p = shakePower * (shakeTime / Math.max(1, prev));
    const nx = (Math.random() * 2 - 1) * p;
    const ny = (Math.random() * 2 - 1) * p;

    shakeX = shakeX * 0.6 + nx * 0.4;
    shakeY = (shakeY * 0.6 + ny * 0.4) * 0.75;

    if (shakeTime <= 0){
      shakeX = 0;
      shakeY = 0;
      shakePower = 0;
    }
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}

/* =========================
   UTILS
========================= */
function aabbVsRect(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function isOptionsOpen(){
  return optionsPanelEl && optionsPanelEl.style.display === "flex";
}



let _lastLagLog = 0;

function debugLag(delta){
  const now = performance.now();
  if (delta > 22 && now - _lastLagLog > 1200){
    _lastLagLog = now;
    console.warn(
      "LAG",
      delta.toFixed(1),
      "score:", Math.floor(score),
      "obs:", obstacles.length,
      "fx:", particles.length
    );
  }
}

let _fxGC = 0;

function fxGarbageCollect(){
  _fxGC++;
  if (_fxGC < 600) return; // ~10s
  _fxGC = 0;

  if (_arcPathCache.size > 64) _arcPathCache.clear();
  if (_rectPathCache.size > 64) _rectPathCache.clear();

  for (const k in _obFX){
    if (_obFX[k].size > 64) _obFX[k].clear();
  }
}

/* =========================
   UPDATE (CLEAN / SAFE)
========================= */
/* =========================
   UPDATE (CLEAN / SAFE / OPTIMIZED UI)
========================= */
function update(delta, ts){

  // ---------- PERF / FX ----------
  updateFXCalm(delta);
  updateShake(delta);

  // temps moteur unique
  const now = renderTime;

  // heavy FX skip flag
  skipHeavyFX = (delta > 24);

  // expression
  const target = jetOn ? 1 : 0;
  moonyExpr += (target - moonyExpr) * 0.08;

  // ---------- OPTIONS ----------
  if (isOptionsOpen()){
    jetOn = false;
    player.vy = 0;
    return;
  }

  // ---------- DYING ----------
  if (gameState === "dying"){
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02;
      p.age += delta;
      if (p.age >= p.life) particles.splice(i, 1);
    }

    if (shockwave){
      shockwave.r += 6;
      shockwave.alpha *= 0.95;
      if (shockwave.r > (shockwave.max || 180) || shockwave.alpha < 0.02){
        shockwave = null;
      }
    }

    if (bloom){
      bloom.a *= 0.92;
      if (bloom.a < 0.02) bloom = null;
    }

    if (dyingFromCircle){
      const cx = dyingFromCircle.x;
      const cy = dyingFromCircle.y;
      const pcx = player.x + player.width  * 0.5;
      const pcy = player.y + player.height * 0.5;

      player.x += (cx - pcx) * 0.06;
      player.y += (cy - pcy) * 0.06;

      player.width  *= 0.992;
      player.height *= 0.992;
    }

    dyingTimer -= delta;
    if (dyingTimer <= 0) handleGameOver();
    return;
  }

  if (gameState !== "playing") return;

// ---------- OVERDRIVE (CORRIG√â & OPTIMIS√â) ----------
  if (overdriveActive){
    // 1. FIX TEMPS : On utilise le vrai delta pour que √ßa dure bien 3s (pas de ralenti)
    overdriveTimer -= delta;

    const pct = Math.max(0, overdriveTimer / overdriveDuration);
    const pctInt = (pct * 100) | 0;

    // Mise √† jour Barre (D√©j√† optimis√©e, parfait)
    if (pctInt !== lastOverdrivePct){
      lastOverdrivePct = pctInt;
      safeStyle(UI.overFill, "height", pctInt + "%");
    }

    // 2. FIX DOM : On n'ajoute la classe qu'UNE SEULE FOIS
    if (pct < 0.35 && !overdriveEndingFlag){
      overdriveEndingFlag = true;
      document.body.classList.add("overdriveEnding");
    }

    if (overdriveTimer <= 0) deactivateOverdrive();
  }

  // ---------- PLAYER ----------
  player.vy += (jetOn ? THRUST : GRAVITY);
  player.vy = clamp(player.vy, -8, 8);
  player.y  += player.vy;

  const SAFE_TOP    = OFF_Y;
  const SAFE_BOTTOM = WORLD_H - OFF_Y - player.height;

  if (player.y < SAFE_TOP){
    player.y = SAFE_TOP;
    player.vy = 0;
  } else if (player.y > SAFE_BOTTOM){
    player.y = SAFE_BOTTOM;
    player.vy = 0;
  }

  // ---------- TRAIL ----------
  if ((jetOn || Math.abs(player.vy) > 0.25) && (now - lastTrailSpawn) > 40){
    spawnPlayerTrail(
      player.x + player.width  * 0.5,
      player.y + player.height * 0.65,
      currentSkin || "moony"
    );
    lastTrailSpawn = now;
  }

  // ---------- SPAWN ----------
  const sp = obstacleSpeed;
  bgScroll += 0.6;

  if ((now - lastSpawn) > currentSpawnInterval(score)){
    spawn();
    lastSpawn = now;
  }

  // ---------- OBSTACLES ----------
  const rx = player.x, ry = player.y, rw = player.width, rh = player.height;
  const cxp = rx + rw * 0.5, cyp = ry + rh * 0.5;
  const DESPAWN_X = -OFF_X - 80;

  for (let i = obstacles.length - 1; i >= 0; i--){
    const ob = obstacles[i];

    if (ob.kind === "rotbar"){
      ob.cx -= sp;
      ob.angle += ob.speed;
    } else {
      ob.x -= sp;
    }

    if (ob.kind === "movingRect"){
      ob.t += ob.speed * 0.05;
      const range = ob.amp || movingAmplitude(score);
      const baseY = (ob.baseY != null) ? ob.baseY : OFF_Y;
      ob.y = clamp(baseY - Math.sin(ob.t) * range, SAFE_TOP, SAFE_BOTTOM);
    }

    if (ob.kind === "turret"){
      ob.t += delta;
      ob.reTimer -= delta;
      if (ob.reTimer <= 0){
        ob.reTimer = ob.reBase;
        ob.y = clamp(
          player.y + randomRange(-ob.spread, ob.spread),
          SAFE_TOP + 20,
          SAFE_BOTTOM - 20
        );
      }
      ob.next -= delta;
      if (ob.next <= 0){
        ob.next = ob.fireMs;
        if (!ob.safeFirst) spawnBullet(ob.x, ob.y, ob.bulletSpeed);
        ob.safeFirst = false;
      }
    }

    const rightEdge =
      (ob.kind === "rotbar") ? (ob.cx + ob.len) :
      (ob.kind === "circle") ? (ob.x + ob.r) :
      (ob.kind === "turret") ? (ob.x + (ob.w || 0)) :
                               (ob.x + (ob.width || 0));

    if (rightEdge < DESPAWN_X){
      obstacles.splice(i, 1);
      continue;
    }

    if (!overdriveActive && !player.invincible){
      const ox = (ob.kind === "rotbar") ? ob.cx : ob.x;
      if (Math.abs(ox - cxp) <= 180){
        if (
          (ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "sweeper") &&
          aabbVsRect(rx, ry, rw, rh, ob.x, ob.y, ob.width, ob.height)
        ) return startDeath(false, null, "rect");

        if (ob.kind === "circle"){
          const dx = cxp - ob.x, dy = cyp - ob.y;
          const rr = (ob.r * 0.9) + (ob.pulse || 0);
          if (dx*dx + dy*dy < rr*rr) return startDeath(true, ob, "circle");
        }

        if (ob.kind === "rotbar"){
          if (aabbVsOBB(rx, ry, rw, rh, ob.cx, ob.cy, (ob.half || 7), ob.len, ob.angle)){
            return startDeath(false, null, "bar");
          }
        }

        if (ob.kind === "turret"){
          if (aabbVsRect(rx, ry, rw, rh, ob.x - 2, ob.y - 2, (ob.w || 0) + 4, (ob.h || 0) + 4)){
            return startDeath(false, null, "turret");
          }
        }
      }
    }
  }

  // ---------- BULLETS ----------
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx - (overdriveActive ? 1 : 0);

    if (b.x + b.r < -OFF_X - 40){
      bullets.splice(i, 1);
      continue;
    }

    if (!overdriveActive){
      const cx = clamp(b.x, rx, rx + rw);
      const cy = clamp(b.y, ry, ry + rh);
      const dx = b.x - cx, dy = b.y - cy;
      if (dx*dx + dy*dy <= b.r*b.r) return startDeath(false, null, "bullet");
    }
  }

  // ---------- COINS ----------
  for (let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= sp;

    if (c.x + c.r < -OFF_X - 40){
      coins.splice(i, 1);
      continue;
    }

    const cx = clamp(c.x, rx, rx + rw);
    const cy = clamp(c.y, ry, ry + rh);
    const dx = c.x - cx, dy = c.y - cy;

    if (dx*dx + dy*dy <= c.r*c.r){
      coins.splice(i, 1);
      coinsCollected++;
      combo = ((now - lastCoinTime) < 1600) ? (combo + 1) : 1;
      lastCoinTime = now;
      addOverdrive(1);

      const base = overdriveActive ? 400 : 200;
      score += base + Math.floor(base * 0.1 * Math.max(0, combo - 1));
    }
  }

  // ---------- SCORE + UI (OPTIMIS√â : NO DOM THRASHING) ----------
  score += delta * 0.24 * paceMultiplier(score) * (overdriveActive ? 2 : 1);

  if ((frameCount & 3) === 0){
    
    // 1. SCORE : On ne touche au DOM que si l'entier change
    const sInt = score | 0;
    if (_lastScore !== sInt) {
      if (UI.score) UI.score.textContent = sInt;
      _lastScore = sInt;
    }

    // 2. COINS
    if (_lastCoins !== coinsCollected) {
      if (UI.coins) UI.coins.textContent = coinsCollected;
      _lastCoins = coinsCollected;
    }

    // 3. COMBO
    if (_lastCombo !== combo) {
      if (UI.combo) UI.combo.textContent = combo;
      _lastCombo = combo;
    }
  }

  // ---------- DIFFICULTY ----------
  obstacleSpeed = 3.8 + Math.pow(score / 8000, 0.9);

  // ---------- GC ----------
  fxGarbageCollect();
}




// =========================
// DEATH ORIGIN (SAFE)
// =========================
function getDeathXY(){
  if (deathOrigin) return deathOrigin;
  return {
    x: player.x + player.width  * 0.5,
    y: player.y + player.height * 0.5
  };
}


/* =========================================================
   üåå BACKGROUND V9 ‚Äî PARALLAX ENGINE (STANDARD INDUSTRY)
========================================================= */

// --- 1. G√âN√âRATION DES CALQUES (ASSETS VIRTUELS) ---
// On dessine le d√©cor UNE SEULE FOIS dans des canvas cach√©s.
// C'est comme si on chargeait des images PNG, mais on les cr√©e ici.

function createLayer(w, h, type) {
    const cvs = document.createElement('canvas');
    cvs.width = w;
    cvs.height = h;
    const c = cvs.getContext('2d');

    if (type === 'deep_space') {
        // FOND : D√©grad√© Sombre + Bruit (Grain)
        const g = c.createLinearGradient(0, 0, 0, h);
        g.addColorStop(0, "#050510"); // Haut noir
        g.addColorStop(1, "#151530"); // Bas bleu nuit
        c.fillStyle = g;
        c.fillRect(0, 0, w, h);
        
        // Ajout de grain pour la texture (Anti-vide)
        for(let i=0; i<400; i++) {
            c.fillStyle = `rgba(255,255,255, ${Math.random()*0.1})`;
            c.fillRect(Math.random()*w, Math.random()*h, 2, 2);
        }
    }
    
    if (type === 'stars_far') {
        // ETOILES LOINTAINES (Petites, statiques)
        for(let i=0; i<200; i++) {
            c.fillStyle = "white";
            c.globalAlpha = Math.random() * 0.5 + 0.2;
            c.beginPath();
            c.arc(Math.random()*w, Math.random()*h, Math.random()*1.5, 0, Math.PI*2);
            c.fill();
        }
    }

    if (type === 'stars_near') {
        // PREMIER PLAN (Plus gros, plus rare)
        for(let i=0; i<50; i++) {
            c.fillStyle = "#aaddff"; // Bleut√©
            c.globalAlpha = Math.random() * 0.4 + 0.3;
            c.beginPath();
            c.arc(Math.random()*w, Math.random()*h, Math.random()*2 + 1, 0, Math.PI*2);
            c.fill();
        }
    }

    return cvs;
}

// --- 2. INITIALISATION ---
let layerFar, layerMid, layerNear;
let bgInitialized = false;

function initParallax(w, h) {
    // On cr√©e des calques plus larges que l'√©cran pour scroller
    layerFar  = createLayer(w, h, 'deep_space');
    layerMid  = createLayer(w, h, 'stars_far');
    layerNear = createLayer(w, h, 'stars_near');
    bgInitialized = true;
}

// --- 3. RENDU DU JEU ---
function drawBG(scroll) {
    if (!ctx) return;
    const W = ctx.canvas.width;
    const H = ctx.canvas.height;

    // Init si la taille change ou premier lancement
    if (!bgInitialized || layerFar.width !== W || layerFar.height !== H) {
        initParallax(W, H);
    }

    // A. DESSIN DU FOND FIXE (Ne bouge pas)
    ctx.drawImage(layerFar, 0, 0);

    // B. DESSIN DE LA PLAN√àTE G√âANTE (√âl√©ment Iconique)
    // On la dessine directement ici pour qu'elle soit derri√®re les √©toiles mais devant le fond
    const planetX = W * 0.7 - (scroll * 0.02); // Bouge tr√®s lentement
    const planetY = H * 0.4;
    const planetR = H * 0.35;
    
    // Si la plan√®te est visible
    if (planetX > -planetR*2 && planetX < W+planetR*2) {
        const pg = ctx.createRadialGradient(planetX - planetR*0.4, planetY - planetR*0.4, 0, planetX, planetY, planetR);
        pg.addColorStop(0, "#4fa"); // Lumi√®re Cyan
        pg.addColorStop(0.5, "#05a"); // Ombre Bleue
        pg.addColorStop(1, "rgba(0,0,0,0)"); // Fondu

        ctx.fillStyle = pg;
        ctx.beginPath();
        ctx.arc(planetX, planetY, planetR, 0, Math.PI*2);
        ctx.fill();
    }

    // C. PARALLAX INFINI (La technique Pro)
    // Pour faire un scroll infini, on dessine l'image deux fois c√¥te √† c√¥te
    
    // Couche Moyenne (Vitesse 0.1)
    let xMid = -(scroll * 0.1) % W;
    if (xMid > 0) xMid -= W;
    ctx.drawImage(layerMid, xMid, 0);
    ctx.drawImage(layerMid, xMid + W, 0);

    // Couche Proche (Vitesse 0.5)
    let xNear = -(scroll * 0.5) % W;
    if (xNear > 0) xNear -= W;
    ctx.drawImage(layerNear, xNear, 0);
    ctx.drawImage(layerNear, xNear + W, 0);
    
    // D. VIGNETTE (Finition)
    const vig = ctx.createRadialGradient(W/2, H/2, H*0.6, W/2, H/2, H);
    vig.addColorStop(0, "rgba(0,0,0,0)");
    vig.addColorStop(1, "rgba(0,0,0,0.5)");
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);
}

/* =========================================================
   üî• AAA PARTICLE SYSTEM (Optimized & Cached)
========================================================= */

// √âtat global des particules
const activeParticles = [];
const solarGradCache  = new Map(); // Cache pour les d√©grad√©s complexes

// CLASSE PARTICULE
class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type || "fire"; // fire, smoke, neon, void
        this.life = 1.0;
        this.maxLife = 1.0;
        
        // Physique al√©atoire selon le type
        const spread = 1.5;
        this.vx = (Math.random() - 0.5) * spread;
        this.vy = (Math.random() * 2) + 2; // Tombe vers le bas (jetpack pousse vers le haut)
        
        this.size = (Math.random() * 6) + 4;
        this.decay = (Math.random() * 0.03) + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.95; // R√©tr√©cit avec le temps
    }

    draw(ctx) {
        if (this.life <= 0) return;
        
        ctx.globalAlpha = this.life;
        
        // Rendu optimis√© via Cache de Gradient (comme ton id√©e originale)
        // On g√©n√®re une cl√© unique bas√©e sur la taille et la couleur
        const grad = getParticleGradient(ctx, this.size, this.life, this.type);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1.0;
    }
}

// CACHE INTELLIGENT (Inspir√© de ton code "Solar")
function getParticleGradient(ctx, r, life, type){
    // On arrondit le rayon pour limiter le nombre de cl√©s en cache
    const q = Math.max(2, (r * 2) | 0);
    // On segmente la vie (High, Mid, Low) pour varier les couleurs
    const tier = life > 0.6 ? 1 : life > 0.3 ? 2 : 3;
    const key = `${type}|${q}|${tier}`;

    let g = solarGradCache.get(key);
    if (g) return g;

    // Cr√©ation du gradient si pas en cache
    g = ctx.createRadialGradient(0, 0, 0, 0, 0, r);

    // PALETTES DE COULEURS SELON LE SKIN
    if (type === "neon") {
        // Cyan / Electric Blue
        g.addColorStop(0, `rgba(200, 255, 255, 1)`);
        g.addColorStop(0.5, `rgba(0, 255, 255, 0.5)`);
        g.addColorStop(1, `rgba(0, 100, 255, 0)`);
    } else if (type === "void") {
        // Violet / Dark Matter
        g.addColorStop(0, `rgba(255, 200, 255, 1)`);
        g.addColorStop(0.5, `rgba(180, 0, 255, 0.5)`);
        g.addColorStop(1, `rgba(50, 0, 100, 0)`);
    } else {
        // Default Fire (Orange/Jaune)
        g.addColorStop(0, `rgba(255, 255, 200, 1)`);
        g.addColorStop(0.4, `rgba(255, 160, 0, 0.6)`);
        g.addColorStop(1, `rgba(255, 50, 0, 0)`);
    }

    // Limite de taille du cache pour √©viter fuite m√©moire
    if (solarGradCache.size > 100) solarGradCache.clear();
    
    solarGradCache.set(key, g);
    return g;
}

// FONCTION MANAGER (√Ä appeler dans GameLoop)
function updateAndDrawParticles(ctx) {
    // 1. Nettoyage (supprimer les mortes)
    for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        p.update();
        if (p.life <= 0) {
            activeParticles.splice(i, 1);
        } else {
            p.draw(ctx);
        }
    }
}

// FONCTION SPAWNER (√Ä appeler quand JetOn = true)
function spawnJetParticles(x, y, skinId) {
    // D√©termine le type de particule selon le skin
    let type = "fire";
    if (skinId === "neon") type = "neon";
    if (skinId === "voidwalker") type = "void";

    // Ajoute 2 particules par frame pour un effet dense
    activeParticles.push(new Particle(x, y, type));
    activeParticles.push(new Particle(x + (Math.random()*10 - 5), y, type));
}

/* =========================
   DRAW PLAYER PARTICLES (OPTIMIS√â MOBILE / SKINS)
========================= */
function drawPlayerParticles(ctx){
  const arr = playerParticles;
  if (!arr.length) return;

  const isMobile = FXQuality.isMobile; // üî• D√©tection Mobile
  const allowGlow = (!isMobile && fps > 48 && fxCalm > 0.01);

  ctx.save();

  for (let i = arr.length - 1; i >= 0; i--){
    const p = arr[i];

    // ===== UPDATE =====
    p.x += p.vx;
    p.y += p.vy;
    p.life--;

    if (p.life <= 0){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    const lifeRatio = p.life / p.lifeMax;
    if (lifeRatio <= 0.02){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    ctx.globalAlpha = lifeRatio;

    // ‚ö° OPTIMISATION : Pas de shadowBlur sur mobile (trop lourd)
    if (allowGlow && p.glow > 0){
      ctx.shadowColor = p.color;
      ctx.shadowBlur  = p.glow * fxCalm;
    } else {
      ctx.shadowBlur = 0;
    }

    const x = p.x, y = p.y, s = p.size;

    switch (p.shape){

      // ===== DEFAULT (Moony) =====
      default:{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;
        // Simplification math√©matique du rayon
        const r = s * (0.8 + lifeRatio * 0.6); 
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== LEAF (Forest) =====
      case "leaf":{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.ellipse(x, y, s * 1.1, s * 0.6, p.life * 0.15, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== SOLAR (Optimis√© Mobile) =====
      case "solar":{
        ctx.globalCompositeOperation = "lighter";
        const rr = s * (0.9 + lifeRatio * 0.9);

        ctx.save();
        ctx.translate(x, y);

        if (isMobile) {
          // üî• MOBILE : Pas de gradient, juste un cercle solide rapide
          ctx.fillStyle = "rgba(255, 200, 50, 0.6)"; 
          ctx.beginPath();
          ctx.arc(0, 0, rr * 2.5, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // üíª PC : Le beau gradient co√ªteux
          ctx.fillStyle = getSolarGradient(ctx, rr, lifeRatio);
          ctx.beginPath();
          ctx.arc(0, 0, rr * 3.1, 0, Math.PI * 2);
          ctx.fill();
        }

        // Coeur blanc (pour les deux)
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(0, 0, rr, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== SNOW (Arctic) =====
      case "snow":{
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1;
        const ss = s * 1.4 * lifeRatio;
        ctx.beginPath();
        ctx.moveTo(x - ss, y);
        ctx.lineTo(x + ss, y);
        ctx.moveTo(x, y - ss);
        ctx.lineTo(x, y + ss);
        ctx.stroke();
      } break;

      // ===== EMBER (Inferno) =====
      case "ember":{
        if (p.jx == null){
          p.jx = (Math.random() - 0.5) * 1.2;
          p.js = 0.5 + Math.random() * 0.6;
        }
        ctx.globalCompositeOperation = "source-over"; // Pas de lighter sur Inferno mobile ?
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(x + p.jx, y - (1 - lifeRatio) * 2, s * p.js, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== LINE (Neon) =====
      case "line":{
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - p.vx * 2, y - p.vy * 2);
        ctx.stroke();
        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== VOID (Voidwalker - Optimis√© Mobile) =====
      case "void":{
        ctx.globalCompositeOperation = "lighter";

        // üî• MOBILE : On saute le gros halo violet pour gagner 50% de perf
        if (!isMobile) {
            ctx.fillStyle = "rgba(120,90,180,0.75)";
            ctx.beginPath();
            ctx.arc(x, y, s * (0.9 + lifeRatio), 0, Math.PI * 2);
            ctx.fill();
        }

        // Coeur sombre (Toujours dessin√©)
        ctx.fillStyle = "rgba(15,8,25,0.9)";
        ctx.beginPath();
        ctx.arc(x, y, s * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = "source-over";
      } break;
    }
  }

  ctx.restore();
}






/* =========================
   FACE DISPATCH (SINGLE SOURCE)
========================= */
const FACE_FN = {
  moony:      drawMoonyFace,
  solar:      drawSolarFace,
  forest:     drawForestFace,
  arctic:     drawArcticFace,
  neon:       drawNeonFace,
  inferno:    drawInfernoFace,
  voidwalker: drawVoidFace
};

function getFaceFn(skinId){
  return FACE_FN[skinId] || drawMoonyFace;
}

/* =========================
   PLAYER ‚Äî RENDER (CLEAN / ORDER SAFE)
   - FX back
   - FACE (DEVANT)
   - FX front optionnel
========================= */



function drawPlayer(){
  const bx = player.x;
  const by = player.y;
  const bw = player.width;
  const bh = player.height;
  const vy = player.vy || 0;

  const skinId = currentSkin || "moony";
  const fxBack = SKIN_FX_BACK[skinId];
  const faceFn = getFaceFn(skinId);

  const VISUAL_SCALE = 1.42;

  ctx.save();

  // invincibility alpha
  if (player.invincible){
    ctx.globalAlpha = 0.7 + Math.sin(renderTime * 0.02) * 0.15;
  }

  // ===== TRANSFORM =====
ctx.translate((bx + bw * 0.5) | 0, (by + bh * 0.5) | 0);
  ctx.scale(VISUAL_SCALE, VISUAL_SCALE);

  const tilt = clamp(-vy * 0.04, -0.35, 0.35);
  ctx.rotate(tilt);
  ctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  // ===== SHIELD =====
  if (player.invincible){
    ctx.save();
    ctx.globalCompositeOperation = "screen";

    const r = bw * 0.65;
    const g = ctx.createRadialGradient(hx, hy, r * 0.2, hx, hy, r);
    g.addColorStop(0, "rgba(160,220,255,0.35)");
    g.addColorStop(1, "rgba(160,220,255,0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // ===== FX BACK (CORRIG√â : renderTime en ms) =====
  if (fxBack){
    // ‚úÖ ICI : On envoie renderTime (ms) au lieu de fxTime (s)
    fxBack(ctx, 0, 0, bw, bh, renderTime, false);
  }

  // ===== FACE (Utilise fxTime global) =====
  faceFn(ctx, hx, hy, headR, vy);

  // ===== FX FRONT (CORRIG√â : renderTime en ms) =====
  if (skinId === "voidwalker"){
    // ‚úÖ ICI : On envoie renderTime (ms)
    drawVoidwalkerFrontFX(ctx, 0, 0, bw, bh, renderTime);
  }

  ctx.restore();
}

/* =========================
   SHOP PREVIEW ‚Äî MIRROR SAFE
========================= */
function drawPlayerPreview(pctx, skinId, t){
  const w = pctx.canvas.width;
  const h = pctx.canvas.height;

  const bw = 36;
  const bh = 32;
  const bx = (w - bw) * 0.5;
  const by = (h - bh) * 0.5 + 6;

  const fxBack = SKIN_FX_BACK[skinId] || drawMoonyFX;
  const faceFn = getFaceFn(skinId);

  pctx.save();
  pctx.translate(bx + bw * 0.5, by + bh * 0.5);
  pctx.scale(1.35, 1.35);
  pctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  fxBack(pctx, 0, 0, bw, bh, t, true);
  faceFn(pctx, hx, hy, headR, 0);

  pctx.restore();
}

/* =========================================================
   üé® SKIN ROUTERS (LE PONT ENTRE LE SHOP ET LE DESSIN)
   Ces fonctions permettent au Shop d'appeler le bon dessin
   sans conna√Ætre les d√©tails techniques du jeu.
========================================================= */

// 1. ROUTEUR DE VISAGE (FACE)
function getFaceFn(skinId){
  // Associe le nom du skin √† la fonction de visage existante dans ton jeu
  switch(skinId){
    case "moony":      return drawMoonyFace;   // V√©rifie que ces noms existent bien
    case "solar":      return drawSolarFace;
    case "forest":     return drawForestFace;
    case "arctic":     return drawArcticFace;
    case "inferno":    return drawInfernoFace;
    case "neon":       return drawNeonFace;
    case "voidwalker": return drawVoidFace;    // Souvent appel√© drawVoidFace ou drawVoidwalkerFace
    default:           return drawMoonyFace;
  }
}

// 2. ROUTEUR FX ARRI√àRE (BACK)
// On cr√©e une map pour √©viter un switch g√©ant si possible, ou on garde le switch
const SKIN_FX_BACK = {
  "moony":      drawMoonyFX,
  "solar":      drawSolarFX,
  "forest":     drawForestFX,
  "arctic":     drawArcticFX,
  "inferno":    drawInfernoFX,
  "neon":       drawNeonFX,
  "voidwalker": drawVoidwalkerFX
};

// 3. ROUTEUR FX G√âN√âRAL (Appel√© par le preview)
function drawSkinFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  if (skipHeavyFX) return;


  
  if (fxFunc) {
    fxFunc(ctx, bx, by, bw, bh, t, isPreview);
  }
}

// 4. ROUTEUR FX AVANT (FRONT - Masques, lueurs par dessus le visage)
function drawSkinFrontFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  // Seuls certains skins ont des effets par dessus le visage
  if (skinId === "voidwalker"){
    // V√©rifie si cette fonction existe dans ton code, sinon commente la ligne
    if (typeof drawVoidwalkerFrontFX === "function") {
      drawVoidwalkerFrontFX(ctx, bx, by, bw, bh, t);
    }
  }
  // Tu peux ajouter d'autres skins ici si besoin (ex: lunettes pour Neon ?)
}

// ===== GLOBAL VARS =====
let moonyBlink = 1;
let nextBlink  = 0;
let blinkPhase = 0;

// ===== FONCTION MOONY "LIVING GUMMY" (AAA KAWAII) =====
function drawMoonyFace(ctx, hx, hy, r, vy){
  const t = fxTime;
  const isHappy = player.invincible; // Expression sp√©ciale quand invincible

  // --- 1. SQUASH & STRETCH (PHYSIQUE) ---
  // Plus fluide : on amortit la d√©formation
  const stretch = Math.max(-0.25, Math.min(0.25, vy * 0.015)); 
  const sx = 1 - stretch; 
  const sy = 1 + stretch;

  ctx.save();
  ctx.translate(hx, hy);
  ctx.scale(sx, sy);

  // --- 2. CORPS "GUMMY" (LUMI√àRE INTERNE) ---
  // On simule une mati√®re semi-transparente qui capte la lumi√®re
  const bodyGrad = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
  bodyGrad.addColorStop(0, "#ffffff");   // Highlight z√©nithal
  bodyGrad.addColorStop(0.4, "#ffffff"); // Corps blanc pur
  bodyGrad.addColorStop(0.85, "#ddeeff"); // L√©g√®re teinte bleut√©e (subsurface)
  bodyGrad.addColorStop(1, "#bbccee");    // Ombre de contour douce
  
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI*2);
  ctx.fill();

  // Contour interne "Gel√©e" (Inner Glow)
  // √áa donne l'√©paisseur du mat√©riau
  const innerGlow = ctx.createRadialGradient(0, -r*0.2, r*0.8, 0, 0, r);
  innerGlow.addColorStop(0.8, "rgba(255,255,255,0)");
  innerGlow.addColorStop(1, "rgba(255,255,255,0.6)");
  ctx.fillStyle = innerGlow;
  ctx.fill();

  // --- 3. REBONDISSEMENT DU VISAGE (Face Lag) ---
  // Le visage a un l√©ger retard sur le corps pour l'inertie
  const faceY = r * 0.1 + (vy * 0.02); 

  // --- 4. JOUES (BREATHING) ---
  const breath = Math.sin(t * 2) * 0.05;
  const cheekY = faceY + r * 0.15;
  const cheekX = r * 0.55 + breath; // Les joues bougent avec la respiration
  
  ctx.fillStyle = "rgba(255, 120, 150, 0.5)"; // Rose soft
  ctx.beginPath(); ctx.ellipse(-cheekX, cheekY, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cheekX, cheekY, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.fill();

  // --- 5. YEUX (REGARD DYNAMIQUE) ---
  // Calcul du regard (Look At)
  const lookY = Math.max(-r*0.15, Math.min(r*0.15, vy * 0.05)); // Regarde haut/bas
  
  // Gestion clignement
  if (!isHappy) { // On ne cligne pas si on fait l'expression "Happy"
      if (t > nextBlink && blinkPhase === 0) blinkPhase = 0.01;
      if (blinkPhase > 0) {
          blinkPhase += 0.25;
          moonyBlink = Math.abs(Math.cos(blinkPhase));
          if (blinkPhase > Math.PI) {
              blinkPhase = 0;
              moonyBlink = 1;
              nextBlink = t + 2 + Math.random() * 3;
          }
      }
  } else {
      moonyBlink = 1; // Yeux forc√©s ouverts pour dessiner l'arc
  }

  const eyeBaseY = faceY - r * 0.1;
  const eyeX = r * 0.26;
  const eyeSize = r * 0.24;

  if (isHappy) {
      // EXPRESSION : HAPPY (^ ^)
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.strokeStyle = "#151525";
      
      // Oeil Gauche ^
      ctx.beginPath();
      ctx.moveTo(-eyeX - eyeSize/2, eyeBaseY);
      ctx.lineTo(-eyeX, eyeBaseY - eyeSize/2);
      ctx.lineTo(-eyeX + eyeSize/2, eyeBaseY);
      ctx.stroke();

      // Oeil Droit ^
      ctx.beginPath();
      ctx.moveTo(eyeX - eyeSize/2, eyeBaseY);
      ctx.lineTo(eyeX, eyeBaseY - eyeSize/2);
      ctx.lineTo(eyeX + eyeSize/2, eyeBaseY);
      ctx.stroke();

  } else {
      // EXPRESSION : STANDARD (Yeux ouverts avec regard)
      ctx.fillStyle = "#151525"; // Noir doux

      // Oeil Gauche
      ctx.save();
      ctx.translate(-eyeX, eyeBaseY + lookY); // Ajout du lookY
      ctx.scale(1, moonyBlink);
      ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
      // Gros reflet
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill();
      // Petit reflet bas
      ctx.beginPath(); ctx.arc(eyeSize*0.2, eyeSize*0.3, eyeSize*0.15, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Oeil Droit
      ctx.fillStyle = "#151525";
      ctx.save();
      ctx.translate(eyeX, eyeBaseY + lookY); // Ajout du lookY
      ctx.scale(1, moonyBlink);
      ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
      // Gros reflet
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill();
      // Petit reflet bas
      ctx.beginPath(); ctx.arc(eyeSize*0.2, eyeSize*0.3, eyeSize*0.15, 0, Math.PI*2); ctx.fill();
      ctx.restore();
  }

  // --- 6. BOUCHE (R√âACTIVE) ---
  // La bouche change de forme selon l'effort
  // Si on monte fort (vy < 0) -> Petite bouche "o" (Effort)
  // Si on plane/tombe -> Sourire ":3"
  
  const mouthY = faceY + r * 0.28;
  ctx.lineCap = "round";
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 2.5;
  ctx.beginPath();

  if (vy < -2) {
      // Effort (Petit rond)
      ctx.arc(0, mouthY, r*0.06, 0, Math.PI*2);
  } else {
      // Normal (Petit sourire mignon)
      // Forme en W tr√®s doux
      const w = r * 0.1;
      ctx.moveTo(-w, mouthY - w*0.3);
      ctx.quadraticCurveTo(0, mouthY + w*0.8, w, mouthY - w*0.3);
  }
  ctx.stroke();

  ctx.restore(); // Fin Squash
}

/* =========================================================
   üõ†Ô∏è GLOBAL HELPERS (ESSENTIEL POUR √âVITER LES CRASH)
   D√©finis une seule fois ici pour tout le monde.
========================================================= */

// Quantize (Arrondir par pas pour les cl√©s de cache)
window._q = function(v, step){ return Math.round(v / step) * step; };

// Quantize 0..1 vers un index entier
window._qi01 = function(v, steps){
  const x = v < 0 ? 0 : (v > 1 ? 1 : v);
  return (x * steps) | 0;
};

// --- HELPER KAWAII (Pour Forest & Arctic uniquement) ---
function drawKawaiiFaceFeatures(ctx, r, t, isInvincible, vy) {
  // Gestion clignement global
  if (typeof window.blinkGlobal === 'undefined') { window.blinkGlobal = 1; window.nextBlinkGlobal = 0; window.blinkPhaseGlobal = 0; }
  
  if (!isInvincible) {
      if (t > window.nextBlinkGlobal && window.blinkPhaseGlobal === 0) window.blinkPhaseGlobal = 0.01;
      if (window.blinkPhaseGlobal > 0) {
          window.blinkPhaseGlobal += 0.25;
          window.blinkGlobal = Math.abs(Math.cos(window.blinkPhaseGlobal));
          if (window.blinkPhaseGlobal > Math.PI) {
              window.blinkPhaseGlobal = 0;
              window.blinkGlobal = 1;
              window.nextBlinkGlobal = t + 2 + Math.random() * 3;
          }
      }
  } else { window.blinkGlobal = 1; }

  const blink = window.blinkGlobal;
  const lookY = Math.max(-r*0.15, Math.min(r*0.15, vy * 0.05));
  const eyeX = r * 0.28;
  const eyeY = -r * 0.05;
  const eyeSize = r * 0.22;

  // Yeux
  if (isInvincible) {
      ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.strokeStyle = "#151525";
      ctx.beginPath(); ctx.moveTo(-eyeX - eyeSize/2, eyeY); ctx.lineTo(-eyeX, eyeY - eyeSize/2); ctx.lineTo(-eyeX + eyeSize/2, eyeY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(eyeX - eyeSize/2, eyeY); ctx.lineTo(eyeX, eyeY - eyeSize/2); ctx.lineTo(eyeX + eyeSize/2, eyeY); ctx.stroke();
  } else {
      ctx.fillStyle = "#151525";
      const drawEye = (x) => {
          ctx.save(); ctx.translate(x, eyeY + lookY); ctx.scale(1, blink);
          ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = "#fff";
          ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill(); // Reflet
          ctx.restore();
      };
      drawEye(-eyeX); drawEye(eyeX);
  }
  // Bouche
  const mouthY = r * 0.25;
  ctx.lineCap = "round"; ctx.strokeStyle = "#151525"; ctx.lineWidth = 2.5;
  ctx.beginPath();
  if (vy < -2) ctx.arc(0, mouthY, r*0.06, 0, Math.PI*2);
  else { ctx.moveTo(-r*0.1, mouthY-r*0.03); ctx.quadraticCurveTo(0, mouthY+r*0.08, r*0.1, mouthY-r*0.03); }
  ctx.stroke();
  // Joues
  ctx.fillStyle = "rgba(255, 120, 150, 0.4)";
  ctx.beginPath(); ctx.arc(-r*0.55, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(r*0.55, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
}

/* =========================================================
   üõ†Ô∏è GLOBAL HELPERS
========================================================= */
window._q = function(v, step){ return Math.round(v / step) * step; };
window._qi01 = function(v, steps){ const x = v < 0 ? 0 : (v > 1 ? 1 : v); return (x * steps) | 0; };
function lerpColor(r1, g1, b1, r2, g2, b2, factor) {
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    return `rgb(${r}, ${g}, ${b})`;
}

/* =========================================================
   üîÆ NEON FACE ‚Äî HD & CLEAN EXPRESSIONS
   - Traits fins et pr√©cis
   - Bouche bien s√©par√©e des yeux
   - Expressions digitales claires
========================================================= */
const _neonFaceState = { idx: 0, nextT: 0 };

function drawNeonFace(ctx, hx, hy, r, vy){
  const t = performance.now();
  // Clignotement l√©ger du contour uniquement
  const flicker = 0.9 + Math.random() * 0.1;

  ctx.save();
  ctx.translate(hx, hy);

  // 1. CASQUE (Fond sombre propre)
  ctx.fillStyle = "#050510"; 
  ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

  // Contour N√©on (Fin et brillant)
  ctx.globalAlpha = flicker;
  ctx.strokeStyle = "#0ff"; 
  ctx.lineWidth = 2; 
  ctx.shadowColor = "#0ff"; ctx.shadowBlur = 10;
  ctx.beginPath(); ctx.arc(0, 0, r*0.92, 0, Math.PI*2); ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1.0; 

  // 2. GESTION DES EXPRESSIONS
  if (t > _neonFaceState.nextT) {
      // Choix al√©atoire : 0=Normal, 1=Happy, 2=Skeptic, 3=Glitch
      const rand = Math.random();
      if(rand < 0.5) _neonFaceState.idx = 0;
      else if(rand < 0.75) _neonFaceState.idx = 1;
      else if(rand < 0.9) _neonFaceState.idx = 2;
      else _neonFaceState.idx = 3;
      
      _neonFaceState.nextT = t + 2000 + Math.random() * 2000;
  }

  // Configuration du trait (FIN et NET)
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = r * 0.08; // Trait proportionnel et fin (~1.5px)
  
  // Pas de shadowBlur sur le visage pour garder la nettet√©
  // ou tr√®s l√©ger
  ctx.shadowColor = "#0ff"; ctx.shadowBlur = 2;

  // Coordonn√©es espac√©es
  const eyeY = -r * 0.15;  // Yeux plus haut
  const mouthY = r * 0.35; // Bouche plus bas
  const ex = r * 0.32;     // Ecartement X
  const es = r * 0.18;     // Taille symbole

  switch(_neonFaceState.idx) {
      case 0: // NORMAL [  ]  [  ] + Trait
          // Yeux (Rectangles vides nets)
          ctx.strokeRect(-ex - es, eyeY - es/2, es*1.2, es);
          ctx.strokeRect(ex - es*0.2, eyeY - es/2, es*1.2, es);
          // Bouche (Trait simple)
          ctx.beginPath(); ctx.moveTo(-ex/2, mouthY); ctx.lineTo(ex/2, mouthY); ctx.stroke();
          break;

      case 1: // HAPPY ^  ^ + Sourire
          // Oeil G
          ctx.beginPath(); 
          ctx.moveTo(-ex - es, eyeY); ctx.lineTo(-ex - es/2, eyeY - es); ctx.lineTo(-ex, eyeY); 
          ctx.stroke();
          // Oeil D
          ctx.beginPath(); 
          ctx.moveTo(ex, eyeY); ctx.lineTo(ex + es/2, eyeY - es); ctx.lineTo(ex + es, eyeY); 
          ctx.stroke();
          // Bouche (U)
          ctx.beginPath(); ctx.arc(0, mouthY - es/2, es, 0.2, Math.PI-0.2); ctx.stroke();
          break;

      case 2: // SKEPTIC -  O + Bouche d√©cal√©e
          // Oeil G (Trait)
          ctx.beginPath(); ctx.moveTo(-ex - es, eyeY); ctx.lineTo(-ex, eyeY); ctx.stroke();
          // Oeil D (Rond)
          ctx.beginPath(); ctx.arc(ex + es/2, eyeY, es/2, 0, Math.PI*2); ctx.stroke();
          // Bouche (Petit trait c√¥t√©)
          ctx.beginPath(); ctx.moveTo(0, mouthY); ctx.lineTo(ex, mouthY); ctx.stroke();
          break;
      
      case 3: // GLITCH >  < + Zigzag
          ctx.strokeStyle = "#f0f"; ctx.shadowColor = "#f0f";
          // Yeux > <
          ctx.beginPath(); ctx.moveTo(-ex - es, eyeY - es/2); ctx.lineTo(-ex, eyeY); ctx.lineTo(-ex - es, eyeY + es/2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(ex + es, eyeY - es/2); ctx.lineTo(ex, eyeY); ctx.lineTo(ex + es, eyeY + es/2); ctx.stroke();
          // Bouche W
          ctx.beginPath(); 
          ctx.moveTo(-ex/2, mouthY); 
          ctx.lineTo(-ex/4, mouthY+es/2); ctx.lineTo(0, mouthY); ctx.lineTo(ex/4, mouthY+es/2); ctx.lineTo(ex/2, mouthY);
          ctx.stroke();
          break;
  }
  ctx.shadowBlur = 0;
  ctx.restore();
}

/* =========================================================
   üåø FOREST FACE (Kawaii Helper)
========================================================= */
const _forestGrad = new Map();
function drawForestFace(ctx, hx, hy, r, vy) {
    const t = performance.now() / 1000;
    const stretch = Math.max(-0.2, Math.min(0.2, vy * 0.015));
    ctx.save(); ctx.translate(hx, hy); ctx.scale(1 - stretch, 1 + stretch);
    let grad = _forestGrad.get("body");
    if(!grad){
        grad = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
        grad.addColorStop(0, "#ddffdd"); grad.addColorStop(1, "#448844");
        _forestGrad.set("body", grad);
    }
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(0, -r * 0.9); ctx.rotate(Math.sin(t * 2) * 0.1);
    ctx.fillStyle = "#22aa22"; ctx.beginPath(); ctx.ellipse(0, -r*0.2, r*0.15, r*0.3, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    drawKawaiiFaceFeatures(ctx, r, t, player.invincible, vy);
    ctx.restore();
}

/* =========================================================
   ‚ùÑÔ∏è ARCTIC FACE (NOUVEAU DESIGN SPHERE)
========================================================= */
const _arcticGradBody = new Map();
function drawArcticFace(ctx, hx, hy, r, vy) {
    const t = performance.now() / 1000;
    const hover = Math.sin(t * 1.5) * 2;
    ctx.save(); ctx.translate(hx, hy + hover);
    const rq = _q(r, 0.5);
    let grad = _arcticGradBody.get(rq);
    if(!grad){
        grad = ctx.createRadialGradient(-rq*0.3, -rq*0.3, rq*0.1, 0, 0, rq);
        grad.addColorStop(0, "#ffffff"); grad.addColorStop(0.4, "#d0f0ff"); grad.addColorStop(1, "#60a0ff");
        _arcticGradBody.set(rq, grad);
    }
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#e0ffff"; ctx.beginPath();
    ctx.moveTo(-r*0.6, -r*0.5); ctx.lineTo(-r*0.4, -r*0.9); ctx.lineTo(-r*0.2, -r*0.6); 
    ctx.lineTo(0, -r*1.0); ctx.lineTo(r*0.2, -r*0.6); ctx.lineTo(r*0.4, -r*0.9); ctx.lineTo(r*0.6, -r*0.5); ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r*0.85, Math.PI, Math.PI*1.5); ctx.stroke();
    const lookY = vy * 0.05;
    ctx.fillStyle = "#004488"; ctx.beginPath(); ctx.ellipse(-r*0.25, -r*0.05+lookY, r*0.12, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.05+lookY, r*0.12, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#004488"; ctx.beginPath(); ctx.arc(0, r*0.3, r*0.06, 0, Math.PI*2); ctx.fill(); 
    const breath = (Math.sin(t * 3) + 1) * 0.5; 
    if (breath > 0.2) {
        ctx.fillStyle = `rgba(255, 255, 255, ${breath * 0.4})`;
        ctx.beginPath(); ctx.arc(0, r*0.4 + breath*5, r*0.15 * breath, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

/* =========================================================
   üî• INFERNO FACE (CRESCENDO)
========================================================= */
const _infernoGradSkin = new Map();
function drawInfernoFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  const rawHeat = Math.sin(t * 2); 
  const heat = (rawHeat + 1) * 0.5;
  ctx.save(); ctx.translate(hx, hy);
  const rq = _q(r, 0.5);
  const hIdx = Math.floor(heat * 20); 
  const key = rq + "_" + hIdx;
  let skin = _infernoGradSkin.get(key);
  if (!skin){
      skin = ctx.createRadialGradient(-rq*0.2, -rq*0.2, rq*0.1, 0, 0, rq);
      if (heat < 0.5) {
          const f = heat * 2; 
          skin.addColorStop(0, lerpColor(150,0,0, 255,60,0, f));
          skin.addColorStop(0.5, lerpColor(100,0,0, 200,20,0, f));
          skin.addColorStop(1, "#220000");
      } else {
          const f = (heat - 0.5) * 2; 
          skin.addColorStop(0, lerpColor(255,60,0, 255,255,200, f)); 
          skin.addColorStop(0.5, lerpColor(200,20,0, 255,150,0, f)); 
          skin.addColorStop(1, lerpColor(34,0,0, 100,20,0, f)); 
      }
      _infernoGradSkin.set(key, skin);
  }
  ctx.fillStyle = skin; ctx.beginPath();
  for(let i=0; i<8; i++){
      const a = (Math.PI*2*i)/8; const d = r * (0.92 + Math.cos(i*10)*0.08); 
      if (i===0) ctx.moveTo(Math.cos(a)*d, Math.sin(a)*d); else ctx.lineTo(Math.cos(a)*d, Math.sin(a)*d);
  }
  ctx.fill();
  ctx.strokeStyle = (heat > 0.8) ? "#fff" : "rgba(255, 100, 0, 0.8)"; ctx.lineWidth = 2;
  if(heat > 0.3) { ctx.shadowColor = "#ff4400"; ctx.shadowBlur = heat * 20; }
  ctx.beginPath(); ctx.moveTo(-r*0.4, -r*0.4); ctx.lineTo(0, -r*0.1); ctx.lineTo(r*0.3, -r*0.5);
  ctx.moveTo(-r*0.1, r*0.5); ctx.lineTo(r*0.2, r*0.2); ctx.stroke(); ctx.shadowBlur = 0;
  ctx.fillStyle = (heat > 0.9) ? "#fff" : "#ffcc00"; 
  const lookY = vy * 0.05;
  ctx.beginPath(); ctx.moveTo(-r*0.6, -r*0.25+lookY); ctx.lineTo(-r*0.2, -r*0.25+lookY); ctx.lineTo(-r*0.4, -r*0.05+lookY); ctx.fill();
  ctx.beginPath(); ctx.moveTo(r*0.6, -r*0.25+lookY); ctx.lineTo(r*0.2, -r*0.25+lookY); ctx.lineTo(r*0.4, -r*0.05+lookY); ctx.fill();
  ctx.restore();
}

/* =========================================================
   ‚òÄÔ∏è SOLAR & üï≥Ô∏è VOID (Gard√©s tels quels)
========================================================= */
const _solarGradCorona = new Map();
const _solarGradSkin = new Map();
function drawSolarFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  const vib = Math.sin(t * 30) * 0.03; 
  ctx.save(); ctx.translate(hx, hy); ctx.scale(1 + vib, 1 - vib);
  const rq = _q(r, 0.5); 
  ctx.save(); ctx.rotate(t * 1.5); 
  let coronaGrad = _solarGradCorona.get(rq);
  if (!coronaGrad){
      coronaGrad = ctx.createRadialGradient(0, 0, rq*0.8, 0, 0, rq*1.6);
      coronaGrad.addColorStop(0, "rgba(255, 200, 0, 0.9)"); coronaGrad.addColorStop(1, "rgba(255, 50, 0, 0)");
      _solarGradCorona.set(rq, coronaGrad);
  }
  ctx.fillStyle = coronaGrad;
  const spikes = 10; ctx.beginPath();
  for(let i=0; i<spikes*2; i++){
      const a = (Math.PI*2 * i) / (spikes*2); const d = (i%2===0) ? rq*1.5 : rq*1.1;
      ctx.lineTo(Math.cos(a)*d, Math.sin(a)*d);
  }
  ctx.fill(); ctx.restore();
  let skinGrad = _solarGradSkin.get(rq);
  if (!skinGrad){
      skinGrad = ctx.createRadialGradient(-rq*0.2, -rq*0.3, rq*0.1, 0, 0, rq);
      skinGrad.addColorStop(0, "#fff"); skinGrad.addColorStop(0.3, "#fc0"); skinGrad.addColorStop(0.8, "#f50"); skinGrad.addColorStop(1, "#a00");
      _solarGradSkin.set(rq, skinGrad);
  }
  ctx.fillStyle = skinGrad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
  const lookY = vy * 0.05;
  ctx.fillStyle = "#fff"; ctx.shadowColor = "#f00"; ctx.shadowBlur = 15;
  ctx.beginPath(); ctx.ellipse(-r*0.3, -r*0.05 + lookY, r*0.22, r*0.15, 0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.3, -r*0.05 + lookY, r*0.22, r*0.15, -0.2, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0; ctx.restore();
}

const _voidDiskCache = new Map();
function drawVoidFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  ctx.save(); ctx.translate(hx, hy);
  const rq = _q(r, 0.5);
  ctx.save(); ctx.rotate(t * 2); 
  let diskGrad = _voidDiskCache.get(rq);
  if (!diskGrad) {
      diskGrad = ctx.createRadialGradient(0, 0, rq*0.5, 0, 0, rq*1.2);
      diskGrad.addColorStop(0, "rgba(0,0,0,0)"); diskGrad.addColorStop(0.6, "rgba(75, 0, 130, 0.8)"); diskGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
      _voidDiskCache.set(rq, diskGrad);
  }
  ctx.fillStyle = diskGrad; ctx.beginPath(); ctx.arc(0, 0, r*1.2, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "#fff";
  for(let i=0; i<6; i++) {
     const angle = (i * Math.PI / 3); const dist = r * 0.9;
     ctx.beginPath(); ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 2, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
  ctx.shadowColor = "#fff"; ctx.shadowBlur = 10; ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0, 0, r*0.65, 0, Math.PI*2); ctx.stroke(); ctx.shadowBlur = 0;
  ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, r*0.6, 0, Math.PI*2); ctx.fill();
  const lookY = vy * 0.05;
  ctx.fillStyle = "#fff"; ctx.shadowColor = "#a0f"; ctx.shadowBlur = 15;
  ctx.beginPath(); ctx.ellipse(-r*0.25, -r*0.05 + lookY, r*0.1, r*0.25, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.05 + lookY, r*0.1, r*0.25, 0, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0; ctx.restore();
}

/* =========================================================
   MOONY FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache OK
   ‚úî FIX MAJEUR : ctx.restore() GARANTI
========================================================= */

const _moonyHaloCache = new Map();

function drawMoonyFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è restore toujours garanti
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.5 + bh * 0.1;

  // pulsation douce (inchang√©e)
  const pulse = 0.85 + Math.sin(t * 1.8) * 0.15;

  /* =========================
     HALO LUNAIRE ARRI√àRE
  ========================= */
  const rY = bh * (isPreview ? 1.05 : 1.25);
  const rX = bw * 1.05;

  // cl√© stable (pas de float instable)
  const key = bw + "|" + bh + "|" + (isPreview ? 1 : 0);
  let g = _moonyHaloCache.get(key);

  if (!g){
    g = ctx.createRadialGradient(
      cx, cy, bh * 0.15,
      cx, cy, rY
    );
    g.addColorStop(0.0, "rgba(255,245,210,0.55)");
    g.addColorStop(0.45,"rgba(180,200,255,0.25)");
    g.addColorStop(1.0, "rgba(0,0,0,0)");

    if (_moonyHaloCache.size > 12) _moonyHaloCache.clear();
    _moonyHaloCache.set(key, g);
  }

  ctx.globalAlpha = pulse * (isPreview ? 0.55 : 0.85);
  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.ellipse(cx, cy, rX, rY, 0, 0, Math.PI * 2);
  ctx.fill();

  /* =========================
     PARTICULES ORBITALES
     (runtime uniquement)
  ========================= */
  if (!isPreview){
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = "rgba(255,250,230,0.95)";

    const baseA = t * 0.6;
    const r = bw * 0.55;

    // 4 particules fixes ‚Üí stable / zero random
    for (let i = 0; i < 4; i++){
      const a = baseA + i * (Math.PI * 0.5);
      const px = cx + Math.cos(a) * r;
      const py = cy + Math.sin(a) * r * 0.7;

      ctx.beginPath();
      ctx.arc(px, py, 1.1, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}





/* =========================================================
   FOREST FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache conserv√©
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
========================================================= */

const _forestGradCache = new Map();

function _getForestGrad(ctx, key, maker){
  let g = _forestGradCache.get(key);
  if (!g){
    g = maker();
    if (_forestGradCache.size > 24) _forestGradCache.clear();
    _forestGradCache.set(key, g);
  }
  return g;
}

function drawForestFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.82;

  const time = t * 0.001; // t = fxTime unifi√©
  const I = isPreview ? 0.65 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => Math.max(0, Math.min(1, v));
  const pulse = (s, ph=0)=> 0.5 + 0.5*Math.sin(time*s + ph);
  const hash = n => { const x = Math.sin(n*127.1)*43758.5453; return x - Math.floor(x); };

  function runeStroke(c, x, y, s, rot){
    c.save();
    c.translate(x,y);
    c.rotate(rot);
    c.lineWidth = 1.15 * I;
    c.lineCap = "round";
    c.beginPath();
    c.moveTo(-s*0.6, -s*0.25);
    c.lineTo( s*0.25, -s*0.25);
    c.lineTo( s*0.25,  s*0.55);
    c.moveTo(-s*0.2,  s*0.1);
    c.lineTo( s*0.6,  s*0.1);
    c.stroke();
    c.restore();
  }

  /* ===== 0) FOG / AURA ===== */
  const breathe = 0.86 + 0.14*Math.sin(time*1.7);
  const fog = _getForestGrad(
    ctx,
    `fog_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.10, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(220,255,235,${0.18*I})`);
      g.addColorStop(0.28, `rgba(130,220,170,${0.18*I})`);
      g.addColorStop(0.60, `rgba(35,110,75,${0.20*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = breathe;
  ctx.fillStyle = fog;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 1) VORTEX ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.55 * I;

  const swirl = _getForestGrad(
    ctx,
    `swirl_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0.00, "rgba(255,255,255,0)");
      g.addColorStop(0.35, `rgba(150,255,205,${0.18*I})`);
      g.addColorStop(0.70, `rgba(80,190,130,${0.14*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.save();
  ctx.translate(
    cx + Math.sin(time*1.2)*R*0.02,
    cy + Math.cos(time*1.0)*R*0.02
  );
  ctx.rotate(time*0.22);
  ctx.scale(1.05, 0.82);
  ctx.fillStyle = swirl;
  ctx.beginPath();
  ctx.arc(0, 0, R*1.05, 0, TAU);
  ctx.fill();
  ctx.restore();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 2) RING ===== */
  const ringRot = time * 0.35;
  const ringPulse = 0.75 + 0.25*pulse(2.6, 0.4);

  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = (isPreview ? 0.38 : 0.62) * I * ringPulse;
  ctx.lineWidth = 2.4 * I;

  const ringG = _getForestGrad(
    ctx,
    `ring_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.70, cx, cy, R*1.02);
      g.addColorStop(0.0, `rgba(170,255,220,${0.10*I})`);
      g.addColorStop(0.55,`rgba(110,235,170,${0.42*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.strokeStyle = ringG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.92, 0, TAU);
  ctx.stroke();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 3) RUNES ===== */
  const runeCount = isPreview ? 10 : 16;
  ctx.globalAlpha = (isPreview ? 0.42 : 0.70) * I;
  ctx.strokeStyle = "rgba(200,255,230,0.85)";
  for(let i=0;i<runeCount;i++){
    const a = ringRot + i*(TAU/runeCount);
    runeStroke(
      ctx,
      cx + Math.cos(a)*R*0.83,
      cy + Math.sin(a)*R*0.83*0.86,
      R*(0.06 + 0.01*Math.sin(time*3 + i)),
      a + Math.PI/2
    );
  }

  /* ===== 4) LUCIOLES ===== */
  ctx.globalCompositeOperation = "screen";
  const fireflies = isPreview ? 6 : 14;

  for(let i=0;i<fireflies;i++){
    const seed = i*19.73;
    const a = time*(0.7 + 0.03*i) + seed;
    const rr = R*(0.20 + 0.55*hash(seed+1));
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a*1.18)*rr*0.78;
    const tw = clamp01(0.25 + 0.75*pulse(5.0, i*1.4));
    const r = (isPreview ? 1.4 : 2.0) * (0.7 + tw) * I;

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.fillStyle = "rgba(210,255,235,1)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, TAU);
    ctx.fill();

    ctx.globalAlpha *= 0.25;
    ctx.beginPath();
    ctx.arc(x, y, r*3.0, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) CORE ===== */
  ctx.globalCompositeOperation = "screen";
  const corePulse = 0.55 + 0.45*Math.sin(time*3.1);

  const coreG = _getForestGrad(
    ctx,
    `core_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.46);
      g.addColorStop(0.0, `rgba(235,255,245,${0.22*corePulse*I})`);
      g.addColorStop(0.35,`rgba(170,255,215,${0.14*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = coreG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.46, 0, TAU);
  ctx.fill();

  ctx.restore();
}


/* =========================================================
   SOLAR FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */

const _solarGradCache = new Map();

function _getSolarGrad(key, maker){
  let g = _solarGradCache.get(key);
  if (!g){
    g = maker();
    if (_solarGradCache.size > 32) _solarGradCache.clear();
    _solarGradCache.set(key, g);
  }
  return g;
}

function drawSolarFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.80;

  const time = t * 0.001; // t = fxTime unifi√© (ms)
  const I = isPreview ? 0.65 : 1.0;

  const TAU = Math.PI*2;
  const clamp01 = v => Math.max(0, Math.min(1, v));
  const n1 = x => Math.sin(x)*0.5 + Math.sin(x*2.3+1.2)*0.25 + Math.sin(x*4.7+2.6)*0.15;

  /* ===== 0) SHIMMER ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.10 * I;

  const shimmer = _getSolarGrad(
    `shimmer_${bw}_${bh}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0,   "rgba(120,200,255,0.00)");
      g.addColorStop(0.5, "rgba(255,180,60,0.10)");
      g.addColorStop(1,   "rgba(255,120,20,0.00)");
      return g;
    }
  );

  ctx.fillStyle = shimmer;
  ctx.beginPath();
  ctx.arc(
    cx + Math.sin(time*2.1)*R*0.015,
    cy + Math.cos(time*1.7)*R*0.015,
    R*1.05, 0, TAU
  );
  ctx.fill();

  /* ===== 1) HALOS ===== */
  const breath = 0.78 + 0.22 * (0.5 + 0.5*Math.sin(time*2.2));

  const halo1 = _getSolarGrad(
    `halo1_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.12, cx, cy, R*1.05);
      g.addColorStop(0.00, `rgba(255,255,235,${0.75*I})`);
      g.addColorStop(0.30, `rgba(255,210,120,${0.55*I})`);
      g.addColorStop(0.62, `rgba(255,140,35,${0.32*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 0.95 * breath * (isPreview ? 0.75 : 1);
  ctx.fillStyle = halo1;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.05, 0, TAU);
  ctx.fill();

  const halo2 = _getSolarGrad(
    `halo2_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.35, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(255,180,70,${0.12*I})`);
      g.addColorStop(0.60, `rgba(255,120,25,${0.10*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = halo2;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 2) COURONNE ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.lineCap = "round";

  const coronaPts = isPreview ? 26 : 34;
  const rot = time*0.65;
  const ampBase = isPreview ? 0.055 : 0.085;

  for(let pass=0; pass<2; pass++){
    ctx.lineWidth = (pass===0 ? 2.6 : 1.2) * I;
    ctx.globalAlpha = (pass===0 ? 0.22 : 0.55) * I;
    ctx.strokeStyle = pass===0
      ? "rgba(255,150,35,0.85)"
      : "rgba(255,220,140,0.95)";

    ctx.beginPath();
    for(let i=0;i<=coronaPts;i++){
      const u = i/coronaPts;
      const ang = u*TAU + rot;
      const spiky = Math.max(0, n1(time*2.8 + u*12.0)) * (isPreview?0.5:1.0);
      const wave  = n1(time*1.6 + u*7.5);
      const amp = ampBase + spiky*0.06;
      const rr  = R * (0.90 + wave*amp + Math.sin(time*3.3 + u*TAU*2.0)*0.015);
      const x = cx + Math.cos(ang) * rr;
      const y = cy + Math.sin(ang) * rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  /* ===== 3) RAYONS ===== */
  const rays = isPreview ? 7 : 12;
  const rayBase = time*0.55;

  for(let i=0;i<rays;i++){
    const u = i/rays;
    const ang = rayBase + u*TAU;
    const pulseV = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*3.2 + i*1.7));
    const jitter = n1(time*5.0 + i*2.0) * 0.06;

    const len = R * (1.05 + pulseV*0.55);
    const inner = R * (0.45 + jitter*0.15);

    const x1 = cx + Math.cos(ang)*inner;
    const y1 = cy + Math.sin(ang)*inner;
    const x2 = cx + Math.cos(ang)*len;
    const y2 = cy + Math.sin(ang)*len;

    const g = _getSolarGrad(
      `ray_${bw}_${bh}_${i}`, // (identique)
      ()=> {
        const gg = ctx.createLinearGradient(x1,y1,x2,y2);
        gg.addColorStop(0.00, "rgba(255,230,160,0.00)");
        gg.addColorStop(0.25, `rgba(255,210,110,${0.65*I})`);
        gg.addColorStop(0.55, `rgba(255,140,45,${0.35*I})`);
        gg.addColorStop(1.00, "rgba(255,120,25,0.00)");
        return gg;
      }
    );

    ctx.strokeStyle = g;
    ctx.globalAlpha = (isPreview ? 0.42 : 0.75) * pulseV * I;
    ctx.lineWidth = (isPreview ? 2.0 : 2.8) * I;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.globalAlpha *= 0.75;
    ctx.lineWidth = (isPreview ? 0.9 : 1.3) * I;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(
      x2 + Math.cos(ang-0.9)*R*0.020,
      y2 + Math.sin(ang-0.9)*R*0.020
    );
    ctx.stroke();
  }

  /* ===== 4) PARTICULES ===== */
  const pCount = isPreview ? 6 : 14;
  ctx.fillStyle = "rgba(255,235,180,1)";
  for(let i=0;i<pCount;i++){
    const k = i + 1;
    const a = time*(0.9 + k*0.03) + k*1.85;
    const o = R * (0.52 + 0.18*Math.sin(time*1.3 + k));
    const sx = cx + Math.cos(a) * o;
    const sy = cy + Math.sin(a*1.06) * (o*0.78);
    const tw = 0.35 + 0.65*clamp01(0.5 + 0.5*Math.sin(time*6.2 + k*2.1));
    const rr = (isPreview ? 1.3 : 1.8) * I * (0.8 + tw*0.6);

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.beginPath();
    ctx.arc(sx, sy, rr, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) COEUR ===== */
  const corePulse = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*4.6));

  const core = _getSolarGrad(
    `core_${bw}_${bh}_${I}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.40);
      g.addColorStop(0.00, `rgba(255,255,255,${0.22*I*corePulse})`);
      g.addColorStop(0.25, `rgba(255,245,210,${0.18*I})`);
      g.addColorStop(1.00, "rgba(255,255,255,0)");
      return g;
    }
  );

  ctx.globalAlpha = (isPreview ? 0.55 : 0.9) * I;
  ctx.fillStyle = core;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.40, 0, TAU);
  ctx.fill();

  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}




/* =========================================================
   ARCTIC FX ‚Äî CLEAN / SAFE / MOBILE
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî pas de return apr√®s save()
========================================================= */

const _arcticGradCache = new Map();

function _getArcticGrad(key, maker){
  let g = _arcticGradCache.get(key);
  if (!g){
    g = maker();
    if (_arcticGradCache.size > 24) _arcticGradCache.clear();
    _arcticGradCache.set(key, g);
  }
  return g;
}

function drawArcticFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  /* ===== PREVIEW SAFE (ULTRA LIGHT) ===== */
  if (isPreview){
    c.save();
    c.globalAlpha = 0.6;
    c.fillStyle = "rgba(180,220,255,0.35)";
    c.beginPath();
    c.arc(bx + bw/2, by + bh/2, bw*0.6, 0, Math.PI*2);
    c.fill();
    c.restore();
    return;
  }

  c.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.58;

  /* ===== AURA POLAIRE ===== */
  const breath = Math.sin(time * 1.6) * 0.08;

  const halo = _getArcticGrad(
    `halo_${bw}_${bh}`,
    () => {
      const g = c.createRadialGradient(
        cx, cy, bw * 0.1,
        cx, cy, bw * (1.15 + breath)
      );
      g.addColorStop(0,   "rgba(250,255,255,0.95)");
      g.addColorStop(0.25,"rgba(210,240,255,0.65)");
      g.addColorStop(0.6, "rgba(140,200,255,0.28)");
      g.addColorStop(1,   "rgba(0,0,0,0)");
      return g;
    }
  );

  c.globalCompositeOperation = "screen";
  c.globalAlpha = 1;
  c.fillStyle = halo;
  c.beginPath();
  c.ellipse(cx, cy, bw * 1.15, bh * 1.35, 0, 0, Math.PI * 2);
  c.fill();

  c.globalCompositeOperation = "source-over";

  /* ===== FLOCON ===== */
  function drawSnowflake(x, y, r, rot, seed){
    c.save();
    c.translate(x, y);
    c.rotate(rot);

    const arms = 5 + (seed % 3);
    c.strokeStyle = "rgba(245,252,255,0.95)";
    c.lineWidth = 0.9 + Math.sin(seed) * 0.4;

    for (let a = 0; a < arms; a++){
      c.rotate((Math.PI * 2) / arms);
      const len = r * (0.6 + Math.sin(seed + a) * 0.35);

      c.beginPath();
      c.moveTo(0, 0);
      c.lineTo(0, len);

      if (Math.sin(seed * 1.7 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(len * 0.2, len * 0.65);
      }
      if (Math.cos(seed * 1.3 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(-len * 0.22, len * 0.7);
      }
      c.stroke();
    }

    c.restore();
  }

  /* ===== TEMP√äTE (OPTIMIS√âE) ===== */
  const stormCount = 18;
  for (let i = 0; i < stormCount; i++){
    const seed = i * 13.13;

    const x =
      cx +
      Math.sin(time * 1.7 + seed) * bw * (0.18 + Math.sin(seed) * 0.3) +
      Math.sin(time * 5.5 + seed) * 10;

    const y =
      cy +
      Math.cos(time * 1.3 + seed) * bh * (0.15 + Math.cos(seed) * 0.25) +
      Math.sin(time * 3.8 + seed) * 8;

    const r   = 2.2 + Math.sin(time * 3 + seed) * 1.4;
    const rot = time * (0.35 + Math.sin(seed) * 0.35) + seed;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== BLIZZARD (OPTIMIS√â) ===== */
  c.globalAlpha = 0.8;
  const blizzardCount = 22;

  for (let i = 0; i < blizzardCount; i++){
    const seed = i * 21.7;
    const rise = (time * 48 + seed * 26) % (bh * 1.3);

    const x =
      cx +
      Math.sin(rise * 0.018 + seed) * bw * (0.22 + Math.sin(seed) * 0.3) +
      Math.sin(time * 4.5 + seed) * 12;

    const y =
      by + bh - rise +
      Math.sin(time * 2.8 + seed) * 10;

    const r   = 2 + Math.sin(time * 3.6 + seed) * 1.5;
    const rot = time * (0.7 + Math.cos(seed) * 0.45) + seed * 0.6;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== GIVRE INF√âRIEUR ===== */
  c.globalAlpha = 0.85;
  c.strokeStyle = "rgba(235,250,255,1)";
  c.lineWidth = 1.5;

  for (let i = 0; i < 6; i++){
    const x = bx + bw * (0.22 + i * 0.11);
    const sway = Math.sin(time * 2 + i) * 3.5;
    const h = bh * (0.18 + Math.sin(time * 1.4 + i) * 0.08);

    c.beginPath();
    c.moveTo(x, by + bh * 0.78);
    c.lineTo(x + sway, by + bh * 0.78 + h);
    c.stroke();
  }

  c.restore();
}








/* =========================================================
   INFERNO FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî gradients toujours restaur√©s
========================================================= */

const _infernoGradCache = new Map();
function _g(key, fn){
  let v = _infernoGradCache.get(key);
  if(!v){
    v = fn();
    if(_infernoGradCache.size > 48) _infernoGradCache.clear();
    _infernoGradCache.set(key, v);
  }
  return v;
}

function drawInfernoFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  c.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.92;

  const I = isPreview ? 0.62 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => v<0?0:v>1?1:v;
  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453123);

  const turb = (u, k) =>
    Math.sin(u*3.1 + time*4.8 + k)*0.55 +
    Math.sin(u*7.7 - time*3.4 + k*1.9)*0.30 +
    Math.sin(u*13.3+ time*2.2 + k*2.7)*0.15;

  /* ===== DARK VIGNETTE ===== */
  c.globalCompositeOperation = "source-over";
  c.globalAlpha = (isPreview ? 0.12 : 0.18) * I;
  c.fillStyle = _g(`vig_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, R*0.25, cx, cy, R*1.35);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,1)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*1.35, 0, TAU);
  c.fill();

  /* ===== CORE ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.65 + 0.35*Math.sin(time*5.2);
  c.globalAlpha = (isPreview ? 0.70 : 1.0) * corePulse * I;
  c.fillStyle = _g(`core_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.60);
    g.addColorStop(0.00, "rgba(255,255,255,0.28)");
    g.addColorStop(0.18, "rgba(255,210,150,0.35)");
    g.addColorStop(0.38, "rgba(255,120,55,0.42)");
    g.addColorStop(0.62, "rgba(190,25,20,0.34)");
    g.addColorStop(1.00, "rgba(0,0,0,0)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*0.62, 0, TAU);
  c.fill();

  /* ===== SEAL ===== */
  const sealRot = time*0.55;
  const sealR = R*0.74;
  const ringR = R*0.86;

  c.globalAlpha = (isPreview ? 0.38 : 0.62) * I;
  c.lineWidth = 2.1 * I;
  c.strokeStyle = "rgba(255,70,40,0.55)";
  c.setLineDash([10*I,8*I]);
  c.lineDashOffset = -time*55;
  c.beginPath();
  c.arc(cx, cy, ringR, 0, TAU);
  c.stroke();
  c.setLineDash([]);

  function starPath(r, rot){
    const idx = [0,2,4,1,3,0];
    c.beginPath();
    for(let j=0;j<idx.length;j++){
      const i = idx[j];
      const a = rot + i*(TAU/5) - Math.PI/2;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r*0.94;
      if(j===0) c.moveTo(x,y); else c.lineTo(x,y);
    }
  }

  c.globalAlpha = (isPreview ? 0.42 : 0.78) * I;
  c.lineWidth = 2.6 * I;
  c.strokeStyle = "rgba(255,180,140,0.45)";
  starPath(sealR, sealRot);
  c.stroke();

  c.globalAlpha = (isPreview ? 0.28 : 0.55) * I;
  c.lineWidth = 1.6 * I;
  c.strokeStyle = "rgba(255,60,30,0.85)";
  starPath(sealR*0.98, -sealRot*0.7);
  c.stroke();

  /* ===== FLAME CROWN ===== */
  const tongues = isPreview ? 9 : 16;
  const baseR = R*0.88;
  c.globalCompositeOperation = "screen";

  for(let i=0;i<tongues;i++){
    const u = i/tongues;
    const a = u*TAU + time*0.95;
    const n = turb(u*TAU, i);
    const spike = Math.max(0,n) * (isPreview?0.35:0.75);

    const rr = baseR*(0.92 + 0.07*Math.sin(time*2.6+i) + spike*0.22);
    const fx = cx + Math.cos(a)*rr;
    const fy = cy + Math.sin(a)*rr*0.78;

    const h = R*(0.22 + 0.18*(0.5+0.5*Math.sin(time*6+i*0.9)) + spike*0.35);
    const w = R*(0.06 + 0.03*(0.5+0.5*Math.sin(time*4.2+i*1.3)));

    const grad = c.createLinearGradient(fx, fy, fx, fy-h);
    grad.addColorStop(0,"rgba(255,90,20,0.75)");
    grad.addColorStop(0.25,"rgba(255,170,60,0.60)");
    grad.addColorStop(0.55,"rgba(255,240,190,0.34)");
    grad.addColorStop(1,"rgba(255,255,255,0)");

    c.globalAlpha = (isPreview ? 0.40 : 0.75) * I;
    c.fillStyle = grad;

    const bend = (Math.sin(time*7.5+i*1.4)*0.55 + n*0.35) * w;

    c.beginPath();
    c.moveTo(fx,fy);
    c.bezierCurveTo(
      fx+w+bend, fy-h*0.25,
      fx+w*0.25, fy-h*0.92,
      fx+bend*0.25, fy-h
    );
    c.bezierCurveTo(
      fx-w*0.25, fy-h*0.92,
      fx-w+bend*0.2, fy-h*0.25,
      fx,fy
    );
    c.fill();
  }

  /* ===== EMBERS ===== */
  const embers = isPreview ? 7 : 18;
  for(let i=0;i<embers;i++){
    const seed=i*33.7;
    const a=time*(0.9+hash(seed)*1.2)+seed;
    const rr=R*(0.22+0.68*hash(seed+1))+Math.sin(time*2+i)*R*0.03;

    const x=cx+Math.cos(a)*rr;
    const y=cy+Math.sin(a*1.05)*rr*0.78;

    const tw=0.35+0.65*(0.5+0.5*Math.sin(time*7+i*1.7));
    const r=(isPreview?1.4:2.6)*(0.65+tw)*I;

    if(!isPreview){
      c.globalAlpha=0.16*tw*I;
      c.fillStyle="rgba(255,140,70,1)";
      c.beginPath(); c.arc(x-Math.cos(a)*12,y-Math.sin(a)*12,r*2.2,0,TAU); c.fill();
    }

    c.globalAlpha=(isPreview?0.55:0.85)*tw*I;
    c.fillStyle="rgba(255,220,170,1)";
    c.beginPath(); c.arc(x,y,r,0,TAU); c.fill();

    c.globalAlpha*=0.22;
    c.beginPath(); c.arc(x,y,r*3,0,TAU); c.fill();
  }

  c.globalCompositeOperation="source-over";
  c.globalAlpha=1;
  c.restore();
}


/* =========================================================
   NEON FX ‚Äî OPTIMIS√â (ZERO ALLOC / DIRECT CACHE)
   ‚úî Plus de fonction anonyme inutile (_ng supprim√©)
   ‚úî Cache v√©rifi√© directement (Inline)
   ‚úî Clip restaur√© proprement
========================================================= */

const _neonGradCache = new Map();

function drawNeonFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const time = t * 0.001;          // t = fxTime (ms)
  const I = isPreview ? 0.7 : 1.0;
  const TAU = Math.PI * 2;

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.85;

  c.save();

  // Clipping circulaire (Attention, op√©ration lourde, mais n√©cessaire ici)
  c.beginPath();
  c.arc(cx, cy, R*0.95, 0, TAU);
  c.clip();

  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453);

  /* ===== STREAKS (RAYONS) ===== */
  const streaks = isPreview ? 4 : 9;

  for(let i=0;i<streaks;i++){
    const seed = i*21.7;
    const life = fract(time*0.6 + hash(seed));

    const angle = seed + life*TAU;
    const dist  = R*(1.3 - life*1.6);

    const x = cx + Math.cos(angle)*dist;
    const y = cy + Math.sin(angle)*dist*0.75;

    const dx = Math.cos(angle);
    const dy = Math.sin(angle)*0.75;

    const L = R*(0.18 + 0.25*(1-life));

    // Cl√© de cache (Quantized)
    // On utilise des entiers pour limiter la cr√©ation de strings
    const kx = (x*0.1)|0;
    const ky = (y*0.1)|0;
    const kl = (L*10)|0;
    const kp = isPreview?1:0;
    const key = `${kx}_${ky}_${kl}_${kp}`;

    // üî• OPTIMISATION : Check direct (pas de closure cr√©√©e)
    let grad = _neonGradCache.get(key);
    if (!grad){
      grad = c.createLinearGradient(x, y, x - dx*L, y - dy*L);
      grad.addColorStop(0.00, "rgba(255,255,255,0.95)");
      grad.addColorStop(0.35, "rgba(0,255,255,0.85)");
      grad.addColorStop(1.00, "rgba(0,255,255,0)");
      
      // Garbage collect simple du cache local
      if (_neonGradCache.size > 64) _neonGradCache.clear();
      _neonGradCache.set(key, grad);
    }

    c.strokeStyle = grad;
    c.lineWidth = (isPreview ? 1.4 : 2.2) * I;
    c.globalAlpha = (1-life) * (isPreview ? 0.7 : 1.0);

    c.beginPath();
    c.moveTo(x,y);
    c.lineTo(x - dx*L, y - dy*L);
    c.stroke();
  }

  /* ===== CORE FLASH ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.5 + 0.5*Math.sin(time*6.2);
  c.globalAlpha = (isPreview ? 0.25 : 0.45) * corePulse * I;

  // Cache pour le coeur (simple key)
  const coreKey = `core_${bw}_${bh}_${isPreview?1:0}`;
  let coreGrad = _neonGradCache.get(coreKey);
  
  if (!coreGrad){
    coreGrad = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.35);
    coreGrad.addColorStop(0.00, "rgba(255,255,255,0.4)");
    coreGrad.addColorStop(0.35, "rgba(0,255,255,0.35)");
    coreGrad.addColorStop(1.00, "rgba(0,0,0,0)");
    _neonGradCache.set(coreKey, coreGrad);
  }

  c.fillStyle = coreGrad;
  c.beginPath();
  c.arc(cx, cy, R*0.35, 0, TAU);
  c.fill();

  c.restore();
}

/* =========================================================
   VOIDWALKER FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */
/* =========================================================
   üï≥Ô∏è VOIDWALKER FX ‚Äî COSMIC SINGULARITY (LEGENDARY MATCH)
   - Remplace le style "Glitch" par un style "Trou Noir"
   - Disque d'accr√©tion g√©ant
   - Rayons de lumi√®re aspir√©s (Lensing)
========================================================= */

const _voidCosmicCache = new Map();

// Helper gradient pour le vide
function _vCosmicGrad(ctx, key, r){
  let g = _voidCosmicCache.get(key);
  if(!g){
    // Violet profond vers noir
    g = ctx.createRadialGradient(0, 0, r*0.4, 0, 0, r*1.5);
    g.addColorStop(0, "rgba(0,0,0,1)");           // Centre noir pur (masque le corps)
    g.addColorStop(0.4, "rgba(75,0,130,0.4)");    // Indigo
    g.addColorStop(0.7, "rgba(138,43,226,0.2)");  // Violet
    g.addColorStop(1, "rgba(0,0,0,0)");
    
    if(_voidCosmicCache.size > 20) _voidCosmicCache.clear();
    _voidCosmicCache.set(key, g);
  }
  return g;
}

// FX AVANT (L√©ger voile devant le joueur pour l'immerger)
function drawVoidwalkerFrontFX(c, bx, by, bw, bh, t){
  if (skipHeavyFX) return;

  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw,bh) * 0.5;

  c.save();
  c.translate(cx, cy);

  // Quelques √©toiles filantes qui passent DEVANT (Aspiration)
  const time = t * 0.002;
  c.fillStyle = "rgba(255,255,255,0.8)";
  
  for(let i=0; i<3; i++){
      const offset = i * 2000;
      const progress = ((t + offset) % 1500) / 1500; // 0..1
      if(progress > 0.8) continue; // Disparait au centre

      const dist = R * 2 * (1 - progress); // Vient de loin vers le centre
      const angle = (t * 0.001) + i * 2;
      
      const px = Math.cos(angle) * dist;
      const py = Math.sin(angle) * dist;
      const size = 2 * (1 - progress);

      c.beginPath(); 
      c.arc(px, py, size, 0, Math.PI*2); 
      c.fill();
  }
  c.restore();
}

// FX ARRI√àRE (Le disque d'accr√©tion majestueux)
function drawVoidwalkerFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const time = t * 0.001; // Secondes
  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw, bh);

  c.save();
  c.translate(cx, cy);

  // 1. HORIZON SOMBRE (Fondation)
  // Masque ce qui est derri√®re pour donner de la profondeur
  const gradKey = `void_bg_${bw|0}`;
  const bgGrad = _vCosmicGrad(c, gradKey, R);
  c.fillStyle = bgGrad;
  c.beginPath(); c.arc(0,0, R*1.4, 0, Math.PI*2); c.fill();

  // 2. DISQUE D'ACCR√âTION (Particules en spirale)
  // On dessine des traits courbes qui sont "aspir√©s"
  c.globalCompositeOperation = "screen"; // Mode lumineux
  c.lineWidth = (isPreview ? 1.5 : 2.5);
  const strands = isPreview ? 8 : 16;
  
  for(let i=0; i<strands; i++){
      const angleBase = (i / strands) * Math.PI * 2;
      const speed = 0.5 + (i%3)*0.2;
      const rotation = time * speed;
      
      // Couleur changeante (Violet -> Cyan -> Magenta)
      const hue = (t * 0.05 + i * 20) % 360;
      c.strokeStyle = `hsla(${260 + (i*10)%60}, 80%, 70%, ${isPreview?0.4:0.6})`;

      c.beginPath();
      // Spirale logarithmique simplifi√©e
      for(let j=0; j<10; j++){
          const dist = R * (0.4 + j*0.12); // Du centre vers l'ext√©rieur
          const spiralAngle = angleBase + rotation + (j * 0.2); // Courbure
          
          const px = Math.cos(spiralAngle) * dist;
          const py = Math.sin(spiralAngle) * dist * 0.85; // Perspective l√©g√®re (ovale)
          
          if(j===0) c.moveTo(px, py);
          else c.lineTo(px, py);
      }
      c.stroke();
  }

  // 3. JETS D'√âNERGIE (Quasars - Vertical)
  // Fines lignes verticales qui sortent des p√¥les
  c.globalAlpha = 0.3 + 0.2 * Math.sin(time * 5);
  c.fillStyle = "rgba(200, 220, 255, 0.2)";
  c.fillRect(-1, -R*1.5, 2, R*3); // Rayon central
  
  c.globalAlpha = 0.1;
  c.fillRect(-4, -R*1.2, 8, R*2.4); // Glow large

  c.restore();
}


// =====================================================
// ‚ö° PRO VECTOR CACHE (FIXED & STABLE)
// =====================================================
const _obFX = {
  // On garde ce nom (_obFX) car le Garbage Collector du moteur le cherche !
  glowColor: new Map(),
  rectBody: new Map(), // Compatible avec le GC
  circleBody: new Map()
};

// =====================================================
// PERF HELPERS
// =====================================================
let fxFrame = 0;
const CULL_PAD = 200; 

/* =====================================================
   üíé DRAW OBSTACLES : VECTOR GLOW (ULTRA SHARP)
===================================================== */
function drawObstacles(){
  fxFrame++;
  const tNow = renderTime;
  
  // Animation globale pr√©cise
  const rotFast = tNow * 0.005;

  // Viewport
  const viewLeft = -OFF_X - CULL_PAD;
  const viewRight = WORLD_W + OFF_X + CULL_PAD;

  // 1. DESSIN DES OBSTACLES (MURS, ENNEMIS)
  for (let i = 0, l = obstacles.length; i < l; i++){
    const ob = obstacles[i];

    // Culling strict
    const right = ob.x + (ob.width || ob.r || ob.w || 0);
    if (right < viewLeft) continue;
    if (ob.x > viewRight) continue;

    ctx.save();

    // =============================
    // A. RECTANGLES (MURS NEON)
    // =============================
    if (ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "sweeper"){
      ctx.translate(ob.x | 0, ob.y | 0);
      const w = ob.width, h = ob.height;
      const isSweeper = (ob.kind === "sweeper");

      // FOND : Sombre et opaque (pour bien d√©tacher du fond √©toil√©)
      ctx.fillStyle = "#020408"; 
      ctx.fillRect(0, 0, w, h);

      // BORDURE : Trait vectoriel net
      ctx.lineWidth = 3;
      const col = isSweeper ? "#d000ff" : "#00f0ff"; // Violet ou Cyan
      ctx.strokeStyle = col;
      ctx.strokeRect(0, 0, w, h);
      
      // D√âTAIL : Double bordure fine
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
      ctx.strokeRect(4, 4, w-8, h-8);

      // MOTIF : Hachures diagonales (Style Tech)
      ctx.beginPath();
      ctx.strokeStyle = isSweeper ? "rgba(208, 0, 255, 0.2)" : "rgba(0, 240, 255, 0.2)";
      ctx.lineWidth = 2;
      // On espace les lignes de 20px
      for(let k = 0; k < h + w; k += 20) {
          // Lignes diagonales simples
          if (k < h) { ctx.moveTo(0, k); ctx.lineTo(Math.min(w, h-k), h); } 
          else { ctx.moveTo(k-h, 0); ctx.lineTo(w, Math.min(h, w-(k-h))); }
      }
      ctx.stroke();

      ctx.restore();
      continue;
    }

   // =============================
    // B. CERCLES (MINES VORTEX)
    // =============================
    if (ob.kind === "circle"){
      ctx.translate(ob.x | 0, ob.y | 0);
      const r = ob.r;

      // Animations locales
      // On utilise rotFast pour la rotation rapide et un sinus pour la pulsation
      const pulse = 1 + 0.15 * Math.sin(tNow * 0.01); 

      // 1. HALO DE DANGER (Arri√®re-plan flou rouge)
      // Indique la zone de danger imm√©diat
      ctx.fillStyle = "rgba(255, 0, 0, 0.15)";
      ctx.beginPath();
      ctx.arc(0, 0, r * 1.2 * pulse, 0, Math.PI * 2);
      ctx.fill();

      // 2. CORPS PRINCIPAL (Anneau rotatif)
      ctx.save();
      ctx.rotate(rotFast); // Tourne vite
      
      // Cercle de base sombre
      ctx.fillStyle = "#1a0505"; // Rouge noir tr√®s sombre
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
      
      // Anneau technique coup√©
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.85, 0, Math.PI * 1.7); // Cercle incomplet
      ctx.stroke();
      
      ctx.restore();

      // 3. PIQUES FLOTTANTES (Tournent en sens inverse)
      ctx.save();
      ctx.rotate(-rotFast * 1.5); // Sens inverse + rapide = effet "Scie"
      
      ctx.fillStyle = "#ff3333"; // Rouge clair
      const spikes = 6; // Plus de piques
      for(let j=0; j<spikes; j++) {
          ctx.rotate((Math.PI * 2) / spikes);
          ctx.beginPath();
          // Forme de lame de scie
          ctx.moveTo(r * 0.6, -3);
          ctx.lineTo(r * 1.1, 0); // Pointe qui sort du rayon
          ctx.lineTo(r * 0.6, 3);
          ctx.fill();
      }
      ctx.restore();

      // 4. C≈íUR EN FUSION (Pulsant au centre)
      // C'est le point d'impact visuel
      const coreR = r * 0.35 * pulse;
      
      // On dessine directement un d√©grad√© ou un cercle solide brillant
      ctx.fillStyle = "#fff"; // Centre blanc chaud
      ctx.beginPath(); ctx.arc(0, 0, coreR, 0, Math.PI*2); ctx.fill();
      
      ctx.strokeStyle = "rgba(255, 50, 0, 0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0, 0, coreR + 2, 0, Math.PI*2); ctx.stroke();

      ctx.restore();
      continue;
    }

    // =============================
    // C. TURRET (DRONE LOSANGE)
    // =============================
    if (ob.kind === "turret"){
      const w = ob.w, h = ob.h;
      ctx.translate(ob.x | 0, (ob.y - h/2) | 0);

      const timeToShoot = ob.next;
      const isCharging = timeToShoot < 600;
      
      // CORPS : Losange noir
      ctx.fillStyle = "#000000";
      ctx.strokeStyle = isCharging ? "#ff0000" : "#00ff00"; // Vert -> Rouge
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.moveTo(0, h/2);
      ctx.lineTo(w/2, 0);
      ctx.lineTo(w, h/2);
      ctx.lineTo(w/2, h);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // COEUR : Carr√© central
      const coreSize = isCharging ? 8 + Math.random()*3 : 6;
      ctx.fillStyle = isCharging ? "#ffff00" : "#004400"; // Jaune flash ou vert sombre
      ctx.fillRect(w/2 - coreSize/2, h/2 - coreSize/2, coreSize, coreSize);
      
      // VISEUR LASER (Ligne infinie)
      if (isCharging) {
          ctx.globalCompositeOperation = "screen";
          ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
          ctx.lineWidth = 1;
          ctx.setLineDash([10, 10]); // Pointill√©s
          ctx.beginPath();
          ctx.moveTo(w/2, h/2);
          ctx.lineTo(-WORLD_W, h/2); // Vers la gauche (le joueur)
          ctx.stroke();
          ctx.setLineDash([]); // Reset
          ctx.globalCompositeOperation = "source-over";
      }

      ctx.restore();
      continue;
    }

    // =============================
    // D. ROTBAR (LASER PUR)
    // =============================
    if (ob.kind === "rotbar"){
      ctx.translate(ob.cx | 0, ob.cy | 0);
      ctx.rotate(ob.angle);

      const w = (ob.half || 7) * 2;
      const len = ob.len * 2;

      // Base Pivot
      ctx.fillStyle = "#111";
      ctx.beginPath(); ctx.arc(0,0, 14, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = "#fff"; ctx.lineWidth=2; ctx.stroke();

      // Le Rayon (Rectangle Blanc + Bordure Violette)
      ctx.fillStyle = "#ffffff"; 
      ctx.fillRect(-w/2, -len/2, w, len);
      
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#aa00ff"; // Violet √©lectrique
      ctx.strokeRect(-w/2, -len/2, w, len);

      ctx.restore();
      continue;
    }
    
    ctx.restore();
  }

  // =============================
  // 2. BULLETS (VISIBILIT√â 100%)
  // =============================
  // Note : On it√®re sur le tableau global 'bullets' (pas 'obstacles')
  // On utilise 'source-over' pour √™tre s√ªr que c'est opaque
  ctx.globalCompositeOperation = "source-over"; 
  
  for (let i = 0, l = bullets.length; i < l; i++){
    const b = bullets[i];
    
    // Culling
    if (b.x < viewLeft || b.x > viewRight) continue;

    ctx.save();
    ctx.translate(b.x | 0, b.y | 0);

    // Rotation rapide pour l'effet "Shuriken/√ânergie"
    ctx.rotate(rotFast * 5);

    // 1. FORME : Carr√© sur la pointe (Losange)
    // Beaucoup plus visible qu'un rond flou
    const size = 12; 

    // Halo (Grand carr√© transparent color√©)
    ctx.fillStyle = "rgba(255, 100, 0, 0.6)"; // Orange
    ctx.fillRect(-size/1.5, -size/1.5, size*1.3, size*1.3);

    // Coeur (Petit carr√© blanc opaque)
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(-size/3, -size/3, size/1.5, size/1.5);

    ctx.restore();
  }
}



/* =====================================================
   ‚ú® AAA PARTICLES : VECTOR SPARKS (MOTION BLUR)
===================================================== */
function drawParticles(){
  // On groupe le rendu pour la performance
  ctx.save();
  // Fusion additive : Les superpositions cr√©ent de la lumi√®re intense (Blanc)
  ctx.globalCompositeOperation = "lighter";

  for (let i = 0; i < particles.length; i++){
    const p = particles[i];

    const lifeRatio = 1 - (p.age / p.life);
    if (lifeRatio <= 0) continue;

    // Vitesse actuelle
    const speed = Math.hypot(p.vx, p.vy);

    // Alpha bas√© sur la vie
    ctx.globalAlpha = lifeRatio;
    
    // Couleur
    ctx.fillStyle = p.col;
    ctx.strokeStyle = p.col;

    if (speed > 1.5) {
        // --- MODE √âTINCELLE (VITESSE) ---
        // On dessine une ligne dans le sens du mouvement (Motion Blur)
        ctx.lineWidth = p.sz * 0.6;
        ctx.lineCap = "round";
        
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        // La queue de l'√©tincelle
        ctx.lineTo(p.x - p.vx * 1.5, p.y - p.vy * 1.5); 
        ctx.stroke();
    } else {
        // --- MODE POUSSI√àRE (LENT) ---
        // Petit carr√© net (plus rapide que arc et style vectoriel)
        const s = p.sz * lifeRatio;
        ctx.fillRect(p.x - s/2, p.y - s/2, s, s);
    }
  }

  ctx.restore();
}


/* =====================================================
   üí• AAA EXPLOSION : IMPACT & SHOCKWAVE
===================================================== */
function drawExplosionFX(){
  // R√©cup√©ration de l'origine de l'explosion
  const ox = deathOrigin ? deathOrigin.x : (player.x + player.width / 2);
  const oy = deathOrigin ? deathOrigin.y : (player.y + player.height / 2);

  ctx.save();
  ctx.globalCompositeOperation = "lighter"; // Lumi√®re pure

  // 1. ONDE DE CHOC (SHOCKWAVE)
  if (shockwave && shockwave.alpha > 0.01){
    const swR = shockwave.r;
    
    // Cercle principal
    ctx.shadowColor = "white";
    ctx.shadowBlur = 10;
    ctx.strokeStyle = `rgba(255, 255, 255, ${shockwave.alpha})`;
    // L'anneau s'affine en s'√©loignant
    ctx.lineWidth = 4 + (1 - (swR / shockwave.max)) * 8; 
    
    ctx.beginPath();
    ctx.arc(ox, oy, swR, 0, Math.PI * 2);
    ctx.stroke();
    
    // √âcho rapide (deuxi√®me anneau plus fin)
    ctx.shadowBlur = 0;
    ctx.strokeStyle = `rgba(200, 240, 255, ${shockwave.alpha * 0.5})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ox, oy, swR * 0.7, 0, Math.PI * 2);
    ctx.stroke();
  }

  // 2. BLOOM (FLASH LUMINEUX CENTRAL)
  if (bloom && bloom.a > 0.01){
    const r = 180; 
    
    // Pas de cache ici car l'alpha change chaque frame
    // C'est rare (une fois par mort), donc n√©gligeable pour la perf
    const g = ctx.createRadialGradient(ox, oy, 0, ox, oy, r);
    g.addColorStop(0,   `rgba(255, 255, 255, ${bloom.a})`); // Coeur blanc
    g.addColorStop(0.3, `rgba(255, 200, 50, ${bloom.a * 0.6})`); // Halo dor√©
    g.addColorStop(1,   "rgba(0, 0, 0, 0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(ox, oy, r, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}


  

/* ================= BACKGROUND NOISE (GPU SAFE) ================= */
function drawBackgroundNoise(){
  if (!noiseCanvas) return;

  const a = fps >= 58 ? 0.04 : fps >= 52 ? 0.025 : 0;
  if (a <= 0) return;

  const sw = canvas.width  / currentDPR;
  const sh = canvas.height / currentDPR;

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  ctx.globalAlpha = a;

  ctx.drawImage(
    noiseCanvas,
    0, 0, noiseCanvas.width, noiseCanvas.height,
    0, 0, sw, sh
  );

  ctx.restore();
}


/* =========================
   GRADIENT CACHES (GLOBAL)
========================== */
let hazeGradientCache = null;
let hazeH = 0;

let fadeGradientCache = null;
let fadeH = 0;

let coinGradientCache = null;
let coinGradR = 0;

function draw(){

  /* =================================================
     1Ô∏è‚É£ RESET ABSOLU
  ================================================= */
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  /* =================================================
     2Ô∏è‚É£ FOND √âCRAN
  ================================================= */
  ctx.fillStyle = "#05060a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  /* =================================================
     3Ô∏è‚É£ DPR ‚Äî SCREEN SPACE
  ================================================= */
  ctx.setTransform(currentDPR, 0, 0, currentDPR, 0, 0);

  /* =================================================
     4Ô∏è‚É£ FX √âCRAN (FULLSCREEN)
  ================================================= */
  // drawBackgroundNoise(); // D√©sactiv√© pour les perfs

  /* =================================================
     5Ô∏è‚É£ CAMERA ‚Äî BACKGROUND
  ================================================= */
  const camX = cameraOffsetX + (shakeX || 0);
  const camY = cameraOffsetY + (shakeY || 0);

  ctx.save();
  ctx.translate(camX, camY);
  ctx.scale(cameraScale, cameraScale);

  drawBG(bgScroll);

  ctx.restore();

  /* =================================================
     6Ô∏è‚É£ CAMERA ‚Äî GAMEPLAY
  ================================================= */
  ctx.save();
  ctx.translate(camX, camY);
  ctx.scale(cameraScale, cameraScale);

  const now = renderTime;
/* =================================================
     üå´Ô∏è HAZE (Brouillard bas) ‚Äî INFINI VERS LE BAS
  ================================================= */
  if (!hazeGradientCache || hazeH !== BASE_H){
    hazeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.72, 0, BASE_H);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.32)");
    hazeGradientCache = g;
  }
  ctx.fillStyle = hazeGradientCache;
  
  // ‚úÖ CORRECTION : On dessine tr√®s bas (+ BASE_H * 2) pour couvrir la bande noire
  ctx.fillRect(-100, BASE_H * 0.72, BASE_W + 200, BASE_H * 2);

  /* =================================================
     üåò FADE BAS (Ombre bas √©cran) ‚Äî INFINI VERS LE BAS
  ================================================= */
  if (!fadeGradientCache || fadeH !== BASE_H){
    fadeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.45, 0, BASE_H);
    g.addColorStop(0, "rgba(10,18,40,0)");
    g.addColorStop(1, "rgba(10,18,40,0.22)");
    fadeGradientCache = g;
  }
  ctx.fillStyle = fadeGradientCache;
  
  // ‚úÖ CORRECTION : Idem, on descend tr√®s bas
  ctx.fillRect(-100, BASE_H * 0.45, BASE_W + 200, BASE_H * 2);
  /* =================================================
       ü™ô COINS (CORRIG√â : Culling plus large)
    ================================================= */
    if (coins.length){
      // ... (le code du d√©grad√© coinGradientCache reste identique ici) ...
      const baseR = Math.round(coins[0].r * 1.15 * 2) / 2;

      if (!coinGradientCache || coinGradR !== baseR){
        coinGradR = baseR;
        const g = ctx.createRadialGradient(
          -baseR * 0.4, -baseR * 0.4, baseR * 0.3,
          0, 0, baseR
        );
        g.addColorStop(0.0, "rgba(255,245,180,1)");
        g.addColorStop(0.4, "rgba(255,210,90,1)");
        g.addColorStop(0.75,"rgba(230,165,30,1)");
        g.addColorStop(1.0, "rgba(160,110,20,1)");
        coinGradientCache = g;
      }

      // Limites de vue √©largies (Culling)
      // On utilise CULL_PAD (160px) pour √™tre s√ªr de les voir arriver
      const VIEW_L = -OFF_X - 160; 
      const VIEW_R = WORLD_W + OFF_X + 160;

      const coinBudget = (fps < 58) ? 12 : 9999; // Budget un peu augment√©
      let drawn = 0;

      for (const c of coins){
        // 1. CULLING : Si la pi√®ce est trop loin √† gauche ou √† droite, on zappe
        if (c.x < VIEW_L || c.x > VIEW_R) continue;

        if (++drawn > coinBudget) break;

        ctx.save();
ctx.translate(c.x | 0, c.y | 0);
        const r = c.r * 1.15;

        ctx.fillStyle = coinGradientCache;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.arc(-r * 0.35, -r * 0.35, r * 0.25, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,200,80,0.55)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    }

  /* =================================================
     üéÆ GAMEPLAY OBJECTS
  ================================================= */
  drawObstacles(now);
  drawPlayerParticles(ctx);
  drawPlayer();
  drawParticles();
  drawExplosionFX();

  /* =================================================
     üîì FIN GAMEPLAY
  ================================================= */
  ctx.restore();

  /* =================================================
     7Ô∏è‚É£ RESET FINAL
  ================================================= */
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}
// ================= LOOP (AAA STABLE / LOW JITTER) =================

// ================= LOOP (AAA STABLE / MOBILE SAFE) =================

// √©tats globaux
let loopStarted = false;
let accTime   = 0;
let drawAcc  = 0;
let fxTick   = 0;
let lastTS   = 0;
// ================= FPS TRACKING =================
let fps = 60;

// temps moteur (UNIQUE SOURCE)
let renderTime = 0;

// constantes
const STEP    = 1000 / 60;   // logique fixe
const DRAW_60 = 1000 / 60;
const DRAW_30 = 1000 / 30;
const MAX_DRAWS_PER_FRAME = 2; // üîí anti-freeze mobile


function loop(ts){
  if (!loopStarted) return;

  // init frame
  if (!lastTS) lastTS = ts;

  let delta = ts - lastTS;
  lastTS = ts;

  // clamp anti-spike (mobile / onglet)
  if (delta > 50) delta = 50;
  if (delta < 0)  delta = 0;
// ================= FPS COMPUTE (STABLE) =================
if (delta > 0) {
  fps = Math.min(60, 1000 / delta);
}

  // ‚è±Ô∏è TEMPS MOTEUR MONOTONE
  renderTime += delta;
fxTime = renderTime * 0.001;
  // ================= UPDATE LOGIQUE FIXE =================
  accTime += delta;
  while (accTime >= STEP){
    update(STEP, renderTime);
    accTime -= STEP;
  }

  // ================= FX QUALITY (THROTTLED) =================
  fxTick += delta;
  if (fxTick >= 120){
    FXQuality.update(renderTime);
    updateFXState();
    fxTick = 0;
  }

  // ================= DRAW SAFE =================
  drawAcc += delta;

  const drawStep = (fps < 58) ? DRAW_30 : DRAW_60;
  let draws = 0;

  while (drawAcc >= drawStep && draws < MAX_DRAWS_PER_FRAME){
    drawAcc -= drawStep;
    draw();
    draws++;
  }

  // backlog trop grand ‚Üí drop hard (√©vite freeze iOS)
  if (draws === MAX_DRAWS_PER_FRAME){
    drawAcc = 0;
  }

  requestAnimationFrame(loop);
}


// ================= START / STOP =================

function startLoop(){
  if (loopStarted) return;

  // üîí mobile = tier forc√©
  if (FXQuality.isMobile){
    FXQuality.setForceTier(0);
  }

  loopStarted = true;
  lastTS     = 0;
  accTime    = 0;
  drawAcc    = 0;
  fxTick     = 0;
  renderTime = 0;

  requestAnimationFrame(loop);
}

function stopLoop(){
  loopStarted = false;
}


// ================= PAUSE / RESUME (ZERO JITTER) =================

function pauseLoop(){
  gameRunning = false;
  stopLoop(); // RAF OFF COMPLET
}

function resumeLoop(){
  gameRunning = true;
  startLoop(); // RAF ON PROPRE
}







// ================= INPUT JET =================
function jetStart(){
  if (gameState !== "playing") return;
  jetOn = true;
}
function jetStop(){
  jetOn = false;
}


// ================= RUN RESET =================
function resetRun(){
  player.x = 100;
  player.y = BASE_H / 2;            // ‚úÖ pas HEIGHT (source d'√©cart selon layout)
  player.width  = BASE_PLAYER_W;
  player.height = BASE_PLAYER_H;
  player.vy = 0;

  jetOn = false;
if (playerParticles) playerParticles.length = 0;

  obstacles.length = 0;
  coins.length = 0;
  bullets.length = 0;
  particles.length = 0;

  score = 0;
  coinsCollected = 0;
  combo = 1;
  overdriveActive = false;
  overdriveTimer = 0;

  lastCoinTime = 0;
  lastSpawn = 0;
  obstacleSpeed = 3.3;
  lastType = null;
  lastBarTime = 0;

  dyingTimer = 0;
  dyingFromCircle = null;

  shake = 0;
  shockwave = null;
  bloom = null;

  // ===== RESET UI (SAFE) =====
  if (UI?.score)     UI.score.textContent = "0";
  if (UI?.coins)     UI.coins.textContent = "0";
  if (UI?.combo)     UI.combo.textContent = "1";
  if (UI?.overCount) UI.overCount.textContent = "0";
}


// ================= LOOP TIMERS RESET (UNIFI√â) =================
// ‚ö†Ô∏è IMPORTANT : on ne touche pas au "renderTime" sauf quand on d√©marre un NOUVEAU run.
function resetLoopTimers(hard = false){
  lastTS  = 0;
  accTime = 0;
  drawAcc = 0;
  fxTick  = 0;

  if (hard){
    renderTime = 0; // ‚úÖ seulement au lancement d‚Äôun run neuf
  }
}


// ================= GAME OVER / MENU =================
function goToMenu(){
  setUIState("menu");
  document.body.classList.remove("playing");
  gameOverTriggered = false;
}

function onGameOverCleanup(){
  gameRunning = false;
  stopLoop();               // ‚úÖ coupe RAF
  resetLoopTimers(false);   // ‚úÖ pas de reset renderTime ici (sinon jitter menu/fx)
  fxCalm = 0;
}


// ================= NOISE INIT =================
function initNoise(){
  noiseCanvas = document.createElement("canvas");
  noiseCanvas.width = 256;
  noiseCanvas.height = 256;

  const nctx = noiseCanvas.getContext("2d", { alpha: true });
  const img = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);

  for(let i = 0; i < img.data.length; i += 4){
    const v = (Math.random() * 255) | 0;
    img.data[i]   = v;
    img.data[i+1] = v;
    img.data[i+2] = v;
    img.data[i+3] = 40; // alpha l√©ger
  }

  nctx.putImageData(img, 0, 0);
}


// ================= MENU VIDEO (GPU SAFE) =================
const MENU_VIDEO_SRC = menuVideo?.dataset?.src || "";

function startMenuVideo(){
  if (!menuVideo || !MENU_VIDEO_SRC) return;

  if (!menuVideo.src){
    menuVideo.src = MENU_VIDEO_SRC;
    menuVideo.load();
  }

  menuVideo.currentTime = 0;
  const p = menuVideo.play();
  if (p && p.catch) p.catch(()=>{});
}

function stopMenuVideo(){
  if (!menuVideo) return;

  menuVideo.pause();
  menuVideo.currentTime = 0;

  menuVideo.removeAttribute("src");
  menuVideo.load(); // üî• lib√®re le GPU
}


// ================= START RUN (PROPRE) =================
function startRun(e){
  if (e){
    e.preventDefault();
    e.stopPropagation();
  }

  // cache "new record"
  const nr = document.getElementById("newRecord");
  if (nr){
    nr.style.display = "none";
    nr.style.opacity = "0";
    nr.style.transform = "scale(1)";
  }

  // reset flags
  gameOverTriggered = false;

  // reset continue/revive
  canContinueThisRun = true;
  hideContinuePopup();

  if (continueTimeout) clearTimeout(continueTimeout);
  if (continueInterval) clearInterval(continueInterval);
  continueTimeout = null;
  continueInterval = null;

  const box = document.getElementById("continueTimer");
  if (box) box.style.display = "none";

  // stop menu stuff
  stopShopPreviewLoop?.();
  stopMenuVideo();

  // bind UI si besoin
  if (!UI?.score) bindUI?.();

  // init noise si besoin
  if (!noiseCanvas) initNoise();

  // √©tat jeu
  uiState = "playing";
  gameState = "playing";
  gameRunning = true;
  document.body.classList.add("playing");

  // reset run + timers moteur (HARD = run neuf)
  resetRun();
  resetLoopTimers(true);

  fxCalm = 1;

  // relance RAF propre
  startLoop();
}


// ================= STOP GAME LOOP (GPU FRIENDLY) =================
function stopGameLoop(){
  gameRunning = false;
  stopLoop();
  resetLoopTimers(false);

  // lib√®re le canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  fxCalm = 0.6;
}


// ================= MENU ENTRY =================
function startMenu(){
  uiState = "menu";
  gameState = "menu";
  gameRunning = false;

  document.body.classList.remove("playing");

  stopGameLoop();
  startMenuVideo();

  hideMenuAdPopup?.();

  if (canWatchAd?.()){
    setTimeout(() => {
      if (uiState === "menu") showMenuAdPopup?.();
    }, 900);
  }
}


// ================= FX FLAGS =================
let skipHeavyFX = false;

// ================= SHOP NAV (CORRIG√â V2) =================
function switchSkin(dir){
  // On utilise la nouvelle navigation du moteur V2
  shopNav(dir);
}

/* =========================================================
   MENU + SHOP + OPTIONS (UI ONLY)
   - NO AUDIO
   - NO GAME LOOP
   - SHOP = RAF UNIQUE
========================================================= */

const menuOverlayEl  = document.getElementById("menuOverlay");
const menuButtonsEl2 = document.getElementById("menuButtons");
const shopPanelEl2   = document.getElementById("shopPanel");
const shopBackBtnEl2 = document.getElementById("shopBackBtn");

// üîí SAFETY CHECK
if (!menuOverlayEl)  console.warn("[UI] menuOverlayEl manquant");
if (!menuButtonsEl2) console.warn("[UI] menuButtonsEl2 manquant");
if (!shopPanelEl2)   console.warn("[UI] shopPanelEl2 manquant");
if (!shopBackBtnEl2) console.warn("[UI] shopBackBtnEl2 manquant");


/* ================= MENU STATS ================= */
function updateMenuStats(){
  const best  = Number(localStorage.getItem("bestScore")  || 0);
  const coins = Number(localStorage.getItem("coinsBank") || 0);

  const sb = document.getElementById("shopBest");
  const sc = document.getElementById("shopCoins");
  const mb = document.getElementById("menuBest");
  const mc = document.getElementById("menuCoins");

  if (sb) sb.textContent = best.toLocaleString();
  if (sc) sc.textContent = coins.toLocaleString();
  if (mb) mb.textContent = best.toLocaleString();
  if (mc) mc.textContent = coins.toLocaleString();
}


/* =========================================================
   üöÄ SHOP SYSTEM V7 ‚Äî FINAL LOGIC (Dynamic, HD, Zoom)
========================================================= */

// Variables Globales Shop
let shopPreviewIdx = 0;
let shopCanvasCtx  = null;
let shopRafId      = 0;

// --- 1. FONCTIONS PRINCIPALES ---

function openShop(){
Player.load(); 

  // 1. Change l'√©tat global (Menu -> Shop)
  setUIState("shop");
  
  // 2. Construit le HTML si n√©cessaire (Une seule fois)
  if (!document.getElementById("shopHeroCanvas")) {
      initShopUI();
  }
  
  // 3. Met √† jour les infos (Prix, Nom, Fond)
  updateShopDisplay();
  
  // 4. Lance la boucle d'animation
  loopShopPreview(); 
}

function closeShop(){
  // 1. Arr√™te l'animation (Batterie)
  stopShopPreviewLoop();
  
  // 2. Retour au menu
  setUIState("menu");
}

function stopShopPreviewLoop(){
  if (shopRafId){
    cancelAnimationFrame(shopRafId);
    shopRafId = 0;
  }
}

// --- 2. CONSTRUCTION HTML (HD 1200px) ---

function initShopUI(){
  const panel = document.getElementById("shopPanel");
  if (!panel) return;
  
  panel.innerHTML = `
    <div id="shopBackBtn" onclick="closeShop()">‚Üê BACK</div>
    
    <div id="shopBalanceDisplay">
      <div class="coinIcon needs-glow"></div>
      <div id="shopTotalCoins">0</div>
    </div>
    
    <div id="shopAdBlock" style="display:none;">
        <div class="adHint">NEED COINS?</div>
        <div id="shopAdBtn">+${typeof AD_REWARD_COINS !== 'undefined' ? AD_REWARD_COINS : 50} (WATCH AD)</div>
    </div>
    
    <div class="shopContentZone">
      <div class="skinCard">
        <canvas id="shopHeroCanvas" width="1200" height="1200" class="skinPreview"></canvas>
      </div>
      
      <div class="skinInfoZone">
        <div class="skinName" id="shopSkinName">SKIN</div>
        <div class="skinPrice" id="shopSkinPrice">0</div>
        <button id="shopActionBtn" class="skinButton">ACTION</button>
      </div>
    </div>
    
    <div class="navArrow left" onclick="shopNav(-1)">‚Äπ</div>
    <div class="navArrow right" onclick="shopNav(1)">‚Ä∫</div>
  `;
  
  // Connexion du contexte
  const cvs = document.getElementById("shopHeroCanvas");
  if (cvs) {
      shopCanvasCtx = cvs.getContext("2d", { alpha: true });
  }
  
  // Clic Pub
  const topAdBtn = document.getElementById("shopAdBtn");
  if (topAdBtn) {
    topAdBtn.onclick = () => { if (typeof canWatchAd === "function" && canWatchAd()) watchAdForCoins("shop"); };
  }
}

// --- 3. NAVIGATION & UPDATE ---

function shopNav(dir){
  shopPreviewIdx = (shopPreviewIdx + dir + SKIN_KEYS.length) % SKIN_KEYS.length;
  updateShopDisplay();
}

function updateShopDisplay(){
  const totalCoinsEl = document.getElementById("shopTotalCoins");
  if (totalCoinsEl) totalCoinsEl.textContent = Player.coins.toLocaleString();

  const skinId = SKIN_KEYS[shopPreviewIdx];
  const skin   = SKINS_DB[skinId];
  
  const elName  = document.getElementById("shopSkinName");
  const elPrice = document.getElementById("shopSkinPrice");
  const btn     = document.getElementById("shopActionBtn");
  const panel   = document.getElementById("shopPanel");
  const adBlock = document.getElementById("shopAdBlock");
  
  if (!elName || !skin) return;

  // Textes
  elName.textContent = skin.name;

  // Logique Achat
  const isOwned = Player.unlocked.includes(skinId);
  const isEquipped = (Player.equipped === skinId);
  const canAfford = Player.coins >= skin.price;

  btn.className = "skinButton";
  btn.onclick = null;

  if (isEquipped){
    elPrice.textContent = "EQUIPPED";
    elPrice.style.color = "#8aff8a";
    btn.textContent = "SELECTED";
    btn.classList.add("equipped");
  } else if (isOwned){
    elPrice.textContent = "OWNED";
    elPrice.style.color = "#a0c0ff";
    btn.textContent = "EQUIP";
    btn.classList.add("owned");
    btn.onclick = () => { Player.equip(skinId); currentSkin = skinId; updateShopDisplay(); };
  } else {
    elPrice.textContent = skin.price.toLocaleString() + " COINS";
    elPrice.style.color = canAfford ? "#fff" : "#ff5555";
    btn.classList.add(skin.category || "common");

    if (canAfford){
      btn.textContent = "UNLOCK";
      btn.onclick = () => { if (Player.buy(skinId)){ currentSkin = skinId; updateShopDisplay(); } };
    } else {
      if (typeof canWatchAd === "function" && canWatchAd()){
        btn.textContent = "GET COINS (AD)";
        btn.classList.add("adCTA");
        btn.onclick = () => watchAdForCoins("shop");
      } else {
        btn.textContent = "NEED COINS";
        btn.style.opacity = 0.5;
        btn.style.cursor = "not-allowed";
      }
    }
  }

  // Pub block
  if (adBlock) {
      adBlock.style.display = (!isOwned && !canAfford && typeof canWatchAd === "function" && canWatchAd()) ? "block" : "none";
  }

  // üî• FONDS DYNAMIQUES üî•
  if (panel) {
      let bgGradient = "";
      const cat = skin.category || "common";
      const name = skin.name.toUpperCase();

      if (cat === "common")    bgGradient = "rgba(100,100,100,0.25)";
      if (cat === "rare")      bgGradient = "rgba(0, 150, 255, 0.35)";
      if (cat === "epic")      bgGradient = "rgba(180, 0, 255, 0.35)";
      if (cat === "legendary") bgGradient = "rgba(255, 200, 0, 0.4)";

      if (name.includes("INFERNO")) bgGradient = "rgba(255, 60, 0, 0.45)";
      if (name.includes("NEON"))    bgGradient = "rgba(0, 255, 200, 0.35)";
      if (name.includes("NATURE"))  bgGradient = "rgba(50, 255, 50, 0.3)";
      if (name.includes("VOID"))    bgGradient = "rgba(100, 0, 255, 0.4)";

      panel.style.background = `radial-gradient(circle at 50% 50%, ${bgGradient}, transparent 70%), linear-gradient(180deg, #050810 0%, #000000 100%)`;
  }
}

// --- 4. BOUCLE RENDU (ZOOM) ---

function loopShopPreview(){
  if (shopRafId) cancelAnimationFrame(shopRafId);
  if (uiState !== "shop") return;
  
  if (shopCanvasCtx){
    const skinId = SKIN_KEYS[shopPreviewIdx];
    const w = shopCanvasCtx.canvas.width;
    const h = shopCanvasCtx.canvas.height;

    shopCanvasCtx.clearRect(0, 0, w, h);
    
    const t = performance.now(); 
    fxTime = t * 0.001; 

    // üî• ZOOM MAGIQUE üî•
    shopCanvasCtx.save();
    shopCanvasCtx.translate(w/2, h/2);
    const ZOOM_LEVEL = 4.0; // Ajuste ici si c'est trop gros/petit
    shopCanvasCtx.scale(ZOOM_LEVEL, ZOOM_LEVEL);
    shopCanvasCtx.translate(-w/2, -h/2);

    if (typeof drawPlayerPreview === "function") {
        drawPlayerPreview(shopCanvasCtx, skinId, t);
    }
    if (skinId === "voidwalker" && typeof drawVoidwalkerFrontFX === "function"){
        drawVoidwalkerFrontFX(shopCanvasCtx, 0, 0, w, h, t);
    }
    
    shopCanvasCtx.restore();
  }
  
  shopRafId = requestAnimationFrame(loopShopPreview);
}


/* =========================================================
   UI STATE CENTRAL ‚Äî VERSION CLEAN
========================================================= */
let _menuAdTimer = 0;
let uiState = "menu"; 

function setUIState(state){
  uiState = state;

  // SYNC GAME STATE
  if (state === "playing") gameState = "playing";
  else if (state === "gameover") gameState = "gameover";
  else gameState = "menu";

  const overlayMenuEl = document.getElementById("menuOverlay");
  const shopStats     = document.getElementById("shopStats"); // (Vieux stats, peut √™tre null)
  const menuStats     = document.getElementById("menuStats");
  const gc            = document.getElementById("gameContainer");
  const shopPanel     = document.getElementById("shopPanel");
  const overlayGameOver = document.getElementById("overlayGameOver");
  const optionsPanelEl = document.getElementById("optionsPanel");

  // === RESET GLOBAL ===
  if (overlayMenuEl) { overlayMenuEl.style.display = "none"; overlayMenuEl.style.pointerEvents = "none"; }
  if (shopPanel)     { shopPanel.classList.remove("visible"); }
  if (optionsPanelEl){ optionsPanelEl.style.display = "none"; optionsPanelEl.style.pointerEvents = "none"; }
  if (overlayGameOver){ overlayGameOver.classList.remove("visible"); overlayGameOver.style.display = "none"; overlayGameOver.style.pointerEvents = "none"; }
  if (gc) gc.style.pointerEvents = "auto";
  
  jetOn = false;

  // === √âTATS ===
  switch(state){
case "menu":{
      stopShopPreviewLoop();
      startMenuVideo();
      
      // ‚úÖ AJOUTER CETTE LIGNE ICI :
      updateMenuStats(); 
      
      if (overlayMenuEl){
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
        overlayMenuEl.style.pointerEvents = "auto";
      }
      if (menuStats) menuStats.style.display = "flex";
      playMusic("menu");
      break;
    }

   case "shop": {
      // NOTE: Tout est g√©r√© par openShop() qui appelle setUIState("shop")
      // Ici on s'assure juste que le fond vid√©o tourne
      startMenuVideo();
      // On affiche l'overlay global (qui contient le panel shop en absolute)
      if (overlayMenuEl) {
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
      }
      // On rend le panel visible (transition CSS)
      if (shopPanel) shopPanel.classList.add("visible");
      
      playMusic("menu");
      break;
    }

    case "options":{
      stopShopPreviewLoop();
      if (overlayMenuEl) overlayMenuEl.style.display = "flex";
      if (optionsPanelEl){
        optionsPanelEl.style.display = "flex";
        optionsPanelEl.style.visibility = "visible";
        optionsPanelEl.style.pointerEvents = "auto";
      }
      playMusic("menu");
      break;
    }

    case "playing":{
      stopShopPreviewLoop();
      stopMenuVideo();
      playMusic("game");
      break;
    }

    case "gameover":{
      stopShopPreviewLoop();
      startMenuVideo();
      if (overlayGameOver){
        overlayGameOver.style.display = "flex";
        overlayGameOver.classList.add("visible");
        overlayGameOver.style.pointerEvents = "auto";
      }
      if (gc) gc.style.pointerEvents = "none";
      playMusic("menu");
      break;
    }
  }
}

/* =========================================================
   DOM READY ‚Äî BINDINGS & INIT
========================================================= */
document.addEventListener("DOMContentLoaded", () => {

  // === SWIPE SHOP (Mobile) ===
  let touchX = 0;
  const shopP = document.getElementById("shopPanel");
  
  if (shopP){
    shopP.addEventListener("touchstart", (e)=>{
      if (!e.touches || !e.touches.length) return;
      touchX = e.touches[0].clientX;
    }, { passive:true });

    shopP.addEventListener("touchend", (e)=>{
      if (!e.changedTouches || !e.changedTouches.length) return;
      const dx = e.changedTouches[0].clientX - touchX;
      // Seuil de 50px pour valider le swipe
      if (Math.abs(dx) > 50){
        shopNav(dx < 0 ? 1 : -1); // Inverse du mouvement doigt
      }
    }, { passive:true });
  }

  // === BOUTONS MENU ===
  // Note: openShop est maintenant la fonction globale V7
  document.getElementById("btnShop")?.addEventListener("click", openShop);
  
  // Options
  document.getElementById("btnOptions")?.addEventListener("click", () => setUIState("options"));
  document.getElementById("optBack")?.addEventListener("click", () => setUIState("menu"));

  // Jouer
  const btnPlay = document.getElementById("btnPlay");
  if (btnPlay){
    btnPlay.addEventListener("click", (e)=>{
      e.preventDefault(); 
      gameOverTriggered = false;
      startRun(e);
      setUIState("playing");
    });
  }
// =========================================================
  // üïπÔ∏è CONTROLES JEU (VERSION "FEN√äTRE ENTI√àRE" - INFAILLIBLE)
  // =========================================================
  
  // --- TACTILE (MOBILE) ---
  window.addEventListener("touchstart", (e) => {
      // On active seulement si on est en train de jouer
      if (uiState === "playing") {
          // Emp√™che le scroll ou le zoom quand on tape
          if(e.cancelable) e.preventDefault();
          jetStart();
      }
  }, { passive: false }); // Important pour que preventDefault fonctionne

  window.addEventListener("touchend", (e) => {
      if (uiState === "playing") {
          if(e.cancelable) e.preventDefault();
          jetStop();
      }
  });

  // --- SOURIS (PC) ---
  window.addEventListener("mousedown", (e) => {
      // On v√©rifie qu'on ne clique pas sur un bouton (comme Pause ou Shop)
      if (uiState === "playing" && !e.target.closest('button')) {
          e.preventDefault();
          jetStart();
      }
  });

  window.addEventListener("mouseup", (e) => {
      if (uiState === "playing") {
          e.preventDefault();
          jetStop();
      }
  });

  // --- CLAVIER (ESPACE / Z / FL√àCHE HAUT) ---
  window.addEventListener("keydown", (e)=>{
    if (e.repeat) return;
    if (uiState !== "playing") return;

    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "KeyZ"){
      e.preventDefault();
      jetStart();
    }
  });

  window.addEventListener("keyup", (e)=>{
    if (uiState !== "playing") return;

    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "KeyZ"){
      e.preventDefault();
      jetStop();
    }
  });

  // --- GESTION DES BOUTONS (RESTART / MENU) ---
  document.getElementById("restartBtn")?.addEventListener("click", (e)=>{
      e.preventDefault(); 
      e.stopPropagation(); // Emp√™che le jetpack de s'activer en cliquant
      gameOverTriggered = false; 
      startRun(); 
      setUIState("playing");
  });
   
  document.getElementById("menuBtn")?.addEventListener("click", (e)=>{
      e.preventDefault(); 
      e.stopPropagation();
      gameOverTriggered = false; 
      stopGameLoop(); 
      document.body.classList.remove("playing");
      setUIState("menu");
  });

// Init
  if (typeof bindUI === "function") bindUI();
  if (typeof initDailyAds === "function") initDailyAds();
  
  // ‚úÖ IMPORTANT : Charger et Afficher les donn√©es sauvegard√©es tout de suite
  Player.load(); // Recharge depuis localStorage
  coinsBank = Player.coins; // Met √† jour la variable globale
  bestScore = Player.bestScore; // Met √† jour la variable globale
  
  if (typeof updateMenuStats === "function") updateMenuStats(); // Affiche les valeurs
   
  setUIState("menu");

}); // FIN DU DOMContentLoaded

FXQuality.setForceTier(0); // 0 = Mode Low (Pas d'ombres, pas de particules lourdes)

</script>

</body>
</html>   

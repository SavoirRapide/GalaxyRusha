<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />

  <title>Jetpack Runner V7.4 ‚Äî Tourelles + midgame plus dur</title>

  <!-- VIEWPORT (CRITIQUE MOBILE) -->
<meta name="viewport"
content="width=device-width,
         height=device-height,
         initial-scale=1.0,
         maximum-scale=1.0,
         user-scalable=no,
         viewport-fit=cover">


  <!-- ===== PWA ===== -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#05060a">

  <!-- ===== iOS (OBLIGATOIRE) ===== -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Jetpack Runner">

  <!-- IC√îNES -->
  <link rel="icon" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- STYLE -->
  <style>

/* =========================
   BASE / GAME CANVAS ‚Äî FULLSCREEN FINAL
========================== */
*{
  margin:0;
  padding:0;
  box-sizing:border-box;
}

html, body{
  width:100%;
  height:100%;
  background:#05060a;
  color:#fff;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  overflow:hidden;

  touch-action:none;
  overscroll-behavior:none;
}

body{
  position:fixed;
  inset:0;
  overflow:hidden;
  display:block;
}

/* =========================
   GAME CONTAINER ‚Äî FULLSCREEN
========================== */
#gameContainer{
  position:absolute;
  inset:0;
  width:100vw;
  height:100vh;

  border-radius:0;
  border:none;
  overflow:hidden;

  background:
    radial-gradient(circle at 50% 44%, rgba(70,170,255,.22), rgba(0,0,0,0) 48%),
    radial-gradient(circle at 50% 72%, rgba(30,90,200,.28), rgba(0,0,0,0) 64%),
    linear-gradient(180deg, rgba(6,10,26,.96), rgba(2,3,8,.99) 76%);
}

/* =========================
   CANVAS ‚Äî FULLSCREEN
========================== */
#game{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  display:block;
}

/* =========================
   UI IN-GAME
========================== */
#ui{
  position:absolute;
  top:14px;
  left:50%;
  transform:translateX(-50%);
  z-index:4;
  pointer-events:none;
  text-align:center;
}

/* SCORE */
#uiScore{
  font-size:32px;
  font-weight:900;
  letter-spacing:1px;
  color:#ffffff;
  text-shadow:
    0 2px 10px rgba(120,180,255,.35),
    0 0 18px rgba(60,140,255,.25);
}

/* =========================
   OVERDRIVE ‚Äî SCORE (MOBILE SAFE)
========================== */
#uiScore{
  will-change:transform;
}

body.overdriveActive #uiScore{
  animation: scorePulse .6s ease-in-out infinite;
}

@keyframes scorePulse{
  0%{ transform:scale(1); opacity:1; }
  50%{ transform:scale(1.06); opacity:.92; }
  100%{ transform:scale(1); opacity:1; }
}

/* =========================
   OVERDRIVE ‚Äî AURA CONTAINER (GPU FRIENDLY)
========================== */
#gameContainer::after{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  opacity:0;
  transform:scale(1);
  will-change:transform;
}

body.overdriveActive #gameContainer::after{
  opacity:.22;
  background:
    radial-gradient(circle at center,
      rgba(140,220,255,.25),
      rgba(0,0,0,0) 65%
    );
  animation: overdriveAura 1.6s ease-in-out infinite;
}

@keyframes overdriveAura{
  0%{ transform:scale(1); }
  50%{ transform:scale(1.06); }
  100%{ transform:scale(1); }
}

/* =========================
   OVERDRIVE METER (OPTIMIS√â)
========================== */
#overdriveMeter{
  position:absolute;
  right:22px;
  top:60%;
  transform:translateY(-50%);
  width:24px;
  height:180px;
  z-index:25;
  pointer-events:none;
}

#overdriveLabel{
  position:absolute;
  top:-26px;
  left:50%;
  transform:translateX(-50%);
  font-size:9px;
  letter-spacing:2px;
  color:#cfefff;
  opacity:.85;
  text-shadow:0 0 4px rgba(120,220,255,.6);
}

#overdriveBarOuter{
  position:relative;
  width:100%;
  height:100%;
  border-radius:999px;
  background:rgba(0,0,0,.65);
  border:1px solid rgba(255,255,255,.16);
  box-shadow:inset 0 0 10px rgba(0,0,0,.85);
  overflow:hidden;
}

#overdriveBarInner{
  position:absolute;
  bottom:0;
  width:100%;
  height:0%;
  border-radius:999px;
  background:linear-gradient(
    180deg,
    #f7fbff,
    #8fd8ff,
    #4f7cff,
    #3a1cff
  );
  box-shadow:
    0 0 10px rgba(140,210,255,.55),
    0 0 18px rgba(100,160,255,.35);
}

/* flow D√âSACTIV√â par d√©faut */
#overdriveBarInner::after{
  content:"";
  position:absolute;
  inset:-30%;
  opacity:0;
}

/* flow UNIQUEMENT en overdrive */
body.overdriveActive #overdriveBarInner::after{
  opacity:.32;
  background:
    repeating-linear-gradient(
      180deg,
      rgba(255,255,255,.28) 0px,
      rgba(255,255,255,.28) 2px,
      rgba(255,255,255,0) 8px,
      rgba(255,255,255,0) 18px
    );
  animation:overdriveFlow 2.2s linear infinite;
}

@keyframes overdriveFlow{
  from{ transform:translateY(0); }
  to{ transform:translateY(32%); }
}

body.overdriveActive #overdriveBarInner{
  animation:overdrivePulse 1.4s ease-in-out infinite alternate;
}

@keyframes overdrivePulse{
  from{ opacity:.92; }
  to{ opacity:1; }
}

/* =========================
   COMBO (MOBILE SAFE)
========================== */
#combo{
  position:absolute;
  right:58px;
  top:50%;
  transform:translateY(-50%);
  font-size:14px;
  font-weight:900;
  letter-spacing:1px;
  opacity:0;
  color:#ffffff;
  text-shadow:0 0 4px rgba(120,200,255,.45);
  transition:opacity .2s ease;
}

body.comboActive #combo{
  opacity:.9;
}

/* =========================
   OVERDRIVE GLOBAL (LIGHT)
========================== */


body.overdriveActive #uiScore{
  text-shadow:
    0 0 10px rgba(160,240,255,.65),
    0 0 22px rgba(80,160,255,.35);
}




/* =========================
   HINT
========================== */
#hint{
  position:absolute;
  bottom:12px;
  left:50%;
  transform:translateX(-50%);
  font-size:13px;
  opacity:.6;
  text-shadow:0 0 6px #000;
  z-index:3;
  animation: hintFade 4s ease forwards;
}

@keyframes hintFade{
  0%{ opacity:.6 }
  70%{ opacity:.6 }
  100%{ opacity:0 }
}

#menuOverlay{
  position: absolute;
  inset: 0;
  z-index: 26;
  overflow: hidden;
}

/* ===== FOND VID√âO ===== */
#menuBg{
  position: absolute;
  inset: 0;
  z-index: 1; /* LE PLUS BAS */
}

#menuVideo{
  width: 100%;
  height: 100%;
  object-fit: contain; /* üëà PAS DE ZOOM */
  background: black;   /* bandes si besoin */
}


/* ===== GALAXY / IMAGE / CANVAS ===== */
#galaxyBG{
  position: absolute;
  inset: 0;
  z-index: 100;
  pointer-events: none;
}

/* ===== PARTICULES ===== */
.menuParticles{
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;
}


#optionsPanel{
  position: relative;
  z-index: 10;
}

 /* =========================
   BUTTON STACK ‚Äî DESIGN ADAPT√â √Ä L‚ÄôIMAGE MJ (LUNAIRE / DOUX)
   ‚ö†Ô∏è PLACEMENT STRICTEMENT IDENTIQUE
========================== */
#menuButtons{
  position:absolute;
  left:50%;
  top:65%;
  transform:translate(-50%, -50%);
  display:flex;
  flex-direction:column;
  gap:18px;
  z-index:10;
}

/* =========================
   BOUTONS ‚Äî STYLE LUNAIRE / COTON / GALAXIE
========================== */
.menuBtn{
  min-width:250px;
  padding:16px 0;

  border:none;
  border-radius:999px;

  font-size:17px;
  font-weight:800;
  letter-spacing:2px;
  text-transform:uppercase;

  color:#0b1b2a;

  background:
    radial-gradient(circle at 30% 20%,
      rgba(255,255,255,.9),
      rgba(180,220,255,.85) 35%,
      rgba(120,180,255,.9) 65%,
      rgba(90,140,255,1)
    );

  cursor:pointer;
  position:relative;
  overflow:hidden;

  box-shadow:
    0 18px 40px rgba(0,0,0,.35),
    inset 0 2px 0 rgba(255,255,255,.7),
    inset 0 -6px 14px rgba(60,90,160,.35),
    0 0 0 1px rgba(255,255,255,.25);

  transition:
    transform .2s ease,
    box-shadow .2s ease,
    filter .2s ease;
}

/* =========================
   HALO DOUX (√âNERGIE LUNAIRE)
========================== */
.menuBtn::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:999px;
  background:
    radial-gradient(circle at 50% 50%,
      rgba(200,230,255,.55),
      rgba(200,230,255,0) 70%
    );
  opacity:.8;
  pointer-events:none;
}

/* =========================
   BRILLANCE SUBTILE
========================== */
.menuBtn::before{
  content:"";
  position:absolute;
  inset:0;
  background:
    linear-gradient(
      120deg,
      transparent 30%,
      rgba(255,255,255,.6) 50%,
      transparent 70%
    );
  opacity:.35;
  transform:translateX(-120%);
  transition:transform .9s ease;
  pointer-events:none;
}

/* =========================
   HOVER ‚Äî FLOTTANT / DOUX
========================== */
.menuBtn:hover{
  transform:scale(1.05);
  filter:saturate(1.08) brightness(1.05);
  box-shadow:
    0 26px 60px rgba(0,0,0,.45),
    inset 0 2px 0 rgba(255,255,255,.85),
    inset 0 -8px 18px rgba(60,90,160,.45),
    0 0 46px rgba(160,210,255,.85);
}

.menuBtn:hover::before{
  transform:translateX(120%);
}

/* =========================
   ACTIVE ‚Äî PRESSION DOUCE
========================== */
.menuBtn:active{
  transform:scale(0.96);
  box-shadow:
    0 10px 26px rgba(0,0,0,.45),
    inset 0 4px 10px rgba(60,90,160,.45);
}

/* =====================================================
   SHOP UI ‚Äî CHARACTER SHOWCASE (AAA ‚Ä¢ IMMERSIVE)
===================================================== */

/* =========================
   PANEL ‚Äî L'ATMOSPH√àRE
========================= */
#shopPanel {
  position: absolute;
  inset: 0;
  /* On enl√®ve le padding restrictif pour utiliser tout l'√©cran */
  padding: 0; 
  opacity: 0;
  pointer-events: none;
  z-index: 10;
  overflow: hidden;

  /* Fond sombre et profond avec un spotlight central subtil */
  background: 
    radial-gradient(circle at 50% 40%, rgba(60, 80, 120, 0.15), transparent 60%),
    linear-gradient(180deg, #020305 0%, #050810 50%, #020305 100%);
  
  backdrop-filter: blur(10px);
  transition: opacity 0.4s ease;
}

#shopPanel.visible {
  opacity: 1;
  pointer-events: auto;
}

/* =========================
   BACK BTN ‚Äî MINIMALISTE
========================= */
#shopBackBtn {
  position: absolute;
  top: 30px;
  left: 30px;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  
  display: flex;
  align-items: center;
  justify-content: center;
  
  font-size: 20px;
  color: rgba(255, 255, 255, 0.8);
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(4px);
  
  cursor: pointer;
  z-index: 50;
  transition: all 0.2s ease;
}

#shopBackBtn:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: scale(1.1);
  color: #fff;
}

/* =========================
   STAGE ‚Äî LA SC√àNE
========================= */
.shopCategory {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.shopCategoryTitle {
  position: absolute;
  top: 12%;
  font-size: 10px;
  letter-spacing: 8px;
  text-transform: uppercase;
  opacity: 0.5;
  color: #fff;
  z-index: 5;
}

/* =========================
   SKIN LIST ‚Äî CONTAINER
========================= */
.skinList {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  perspective: 1000px; /* Pour la profondeur */
}

/* =========================
   SKIN CARD ‚Äî DEVENUE INVISIBLE (WRAPPER)
   On enl√®ve le background et les bordures ici !
========================= */
.skinCard {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  
  /* Plus de background, plus de box-shadow sur la card elle-m√™me */
  background: none;
  box-shadow: none;
  border: none;
  
  animation: none; /* On g√®re l'animation sur le canvas */
}

/* =========================
   PREVIEW ‚Äî LE H√âROS (CANVAS)
========================= */
.skinPreview {
  /* Taille massive pour mettre en avant le perso */
  width: 380px; 
  height: 380px;
  
  /* Pas de background sur le canvas, on veut voir le perso d√©tour√© */
  background: transparent; 
  border-radius: 0; 
  box-shadow: none;
  
  /* Animation de flottaison fluide */
  animation: heroFloat 5s ease-in-out infinite;
  
  /* Effet de glow derri√®re le perso selon la raret√© (g√©r√© via drop-shadow) */
  filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.1));
  z-index: 10;
}

/* SOCLE DE LUMI√àRE (Spotlight au sol) */
.skinCard::after {
  content: "";
  position: absolute;
  top: 62%; /* Juste sous les pieds */
  width: 200px;
  height: 40px;
  background: radial-gradient(ellipse at center, rgba(255,255,255,0.3) 0%, transparent 70%);
  transform: scaleY(0.4);
  opacity: 0.6;
  z-index: 1;
  pointer-events: none;
  transition: background 0.3s ease;
}

/* Couleurs du socle selon raret√© */
.skinCard.common::after    { background: radial-gradient(ellipse at center, rgba(200, 230, 255, 0.25), transparent 70%); }
.skinCard.rare::after      { background: radial-gradient(ellipse at center, rgba(100, 200, 255, 0.35), transparent 70%); }
.skinCard.epic::after      { background: radial-gradient(ellipse at center, rgba(200, 100, 255, 0.35), transparent 70%); }
.skinCard.legendary::after { background: radial-gradient(ellipse at center, rgba(255, 200, 80, 0.45), transparent 70%); }

/* =========================
   INFO ZONE ‚Äî BAS DE L'√âCRAN
========================= */
.skinName {
  position: absolute;
  bottom: 22%; /* Positionn√© par rapport au bas */
  font-size: 32px; /* Beaucoup plus gros */
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: #fff;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  z-index: 20;
}

.skinRarityLabel {
  position: absolute;
  bottom: 19%;
  font-size: 10px;
  letter-spacing: 4px;
  text-transform: uppercase;
  opacity: 0.8;
  z-index: 20;
}

.skinPrice {
  position: absolute;
  bottom: 16%;
  font-size: 14px;
  opacity: 0.7;
  color: #d0dbe6;
  font-variant-numeric: tabular-nums;
}

/* =========================
   ACTION BUTTON
========================= */
.skinButton {
  position: absolute;
  bottom: 8%; /* Tout en bas */
  padding: 16px 64px;
  
  border-radius: 4px; /* Plus carr√©, plus pro */
  border: none;
  
  font-size: 14px;
  font-weight: 800;
  letter-spacing: 3px;
  text-transform: uppercase;
  
  cursor: pointer;
  z-index: 30;
  
  background: #fff;
  color: #000;
  
  box-shadow: 0 0 20px rgba(255,255,255,0.1);
  clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); /* Forme Sci-Fi */
  
  transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
}

.skinButton:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 0 0 30px rgba(255,255,255,0.3);
}

.skinButton:active {
  transform: scale(0.98);
}

/* Styles sp√©cifiques */
.skinButton.adCTA   { background: #4fffa8; color: #041f10; box-shadow: 0 0 30px rgba(79, 255, 168, 0.2); }
.skinButton.playCTA { background: #ffcc00; color: #2a1b00; box-shadow: 0 0 30px rgba(255, 204, 0, 0.2); }

/* =========================
   NAVIGATION (ARROWS)
========================= */
/* On ciblera les fl√®ches cr√©√©es par le JS */
.navArrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 40;
  color: rgba(255,255,255,0.3);
  font-size: 40px;
  transition: color 0.2s, background 0.2s;
}
.navArrow:hover {
  color: #fff;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05));
}
.navArrow.left { left: 0; }
.navArrow.right { right: 0; }

/* =========================
   ANIMATIONS
========================= */
@keyframes heroFloat {
  0%   { transform: translateY(0px) rotate(0deg); }
  50%  { transform: translateY(-15px) rotate(1deg); }
  100% { transform: translateY(0px) rotate(0deg); }
}

/* Couleurs de raret√© (Textes) */
.common    { color: #d0e6ff; text-shadow: 0 0 15px rgba(208, 230, 255, 0.4); }
.rare      { color: #4fc3f7; text-shadow: 0 0 15px rgba(79, 195, 247, 0.5); }
.epic      { color: #ce93d8; text-shadow: 0 0 20px rgba(206, 147, 216, 0.6); }
.legendary { color: #ffd54f; text-shadow: 0 0 25px rgba(255, 213, 79, 0.7); }



/* =========================
   INTRO ‚Äî FULLSCREEN IMAGE + FX OVERLAY
========================== */

#overlayIntro{
  position:absolute;
  inset:0;
  z-index:100000;
  overflow:hidden;
  pointer-events:auto;

  display:flex;
  align-items:center;
  justify-content:center;

  background:#000;
}


/* ===== LOGO INTRO ‚Äî FULLSCREEN D√âZOOM√â ===== */
#overlayIntro #introLogo{
  position:absolute;
  inset:0;
  z-index:5;
  display:flex;
  align-items:center;
  justify-content:center;
}

#overlayIntro #introLogo img{
  width:100vw;
  height:100vh;

  object-fit:contain;     /* ‚Üê CL√â DU D√âZOOM */
  object-position:center;

  background:#000;        /* bandes propres si ratio diff√©rent */

  filter:
    drop-shadow(0 0 12px rgba(0,0,0,.6));
}


/* =========================
   MENU STATS ‚Äî INTEGRATED HUD
========================== */

#menuStats{
  position:absolute;
  top:6%;
  right:16%;
  display:flex;
  gap:18px;
  align-items:flex-start;

  z-index:12;
  pointer-events:none;
}

/* =========================
   STAT ITEM ‚Äî TEXT ONLY
========================== */
#menuStats .stat{
  display:flex;
  flex-direction:column;
  gap:2px;

  padding:0;
  background:none;

  font-size:11px;
  font-weight:600;
  letter-spacing:2px;
  color:rgba(200,220,255,.6);
}

/* =========================
   ICON (TEXT / EMOJI)
========================== */
#menuStats .statIcon{
  font-size:15px;
  line-height:1;
  opacity:.85;
}

/* =========================
   TEXT BLOCK
========================== */
#menuStats .statText{
  display:flex;
  flex-direction:column;
}

/* =========================
   LABEL
========================== */
#menuStats .statLabel{
  font-size:8px;
  letter-spacing:2px;
  text-transform:uppercase;
  color:rgba(200,220,255,.5);
}

/* =========================
   VALUE
========================== */
#menuStats .stat .value{
  font-size:18px;
  font-weight:700;
  letter-spacing:0;

  color:#f5fbff;

  text-shadow:
    0 0 6px rgba(120,180,255,.45),
    0 0 14px rgba(80,140,255,.35);
}
/* =========================
   COINS ‚Äî ACCENT BY ICON ONLY
========================== */
#menuStats .statBox.coins{
  border-color:rgba(255,200,120,.22);
}

#menuStats .statBox.coins .statIcon{
  color:#ffd27a;
}




#shopStats{
  position:absolute;
  top:20px;
  left:100px;
  display:flex;
  gap:16px;
  z-index:30;
}

#shopStats .statBox{
  padding:14px 18px;
  min-width:150px;
  border-radius:20px;
  background:
    radial-gradient(circle at 30% 20%, rgba(255,255,255,.18), transparent 55%),
    linear-gradient(180deg, rgba(20,36,72,.88), rgba(6,10,26,.96));
  border:1px solid rgba(180,220,255,.25);
  backdrop-filter: blur(18px);
  box-shadow:
    0 20px 40px rgba(0,0,0,.55),
    0 0 50px rgba(120,180,255,.22);
}

#shopStats .statLabel{
  font-size:10px;
  letter-spacing:3px;
  opacity:.75;
  color:#d6f0ff;
}

#shopStats .statValue{
  margin-top:4px;
  font-size:22px;
  font-weight:900;
  color:#eaf6ff;
  text-shadow:0 0 16px rgba(140,210,255,.55);
}

#shopStats .statBox:last-child{
  background:
    radial-gradient(circle at 30% 20%, rgba(255,220,140,.35), transparent 55%),
    linear-gradient(180deg, rgba(58,42,18,.92), rgba(20,12,4,.98));
  border-color:rgba(255,210,120,.35);
}

#shopStats .statBox:last-child .statValue{
  color:#ffd36a;
  text-shadow:0 0 20px rgba(255,190,90,.75);
}


/* =========================
   TAP TO START ‚Äî ULTRA LISIBLE / GOLDEN
========================== */
#overlayIntro .introHint{
  position:absolute;
  bottom:40px;
  left:50%;
  transform:translateX(-50%);
  z-index:5;
  pointer-events:none;

  font-size:26px;
  font-weight:900;
  letter-spacing:4px;
  text-transform:uppercase;

  color:#fff4c4;
  text-shadow:
    0 0 6px rgba(0,0,0,.9),
    0 0 18px rgba(255,200,120,1),
    0 0 36px rgba(255,160,80,.95),
    0 0 60px rgba(255,120,40,.75);

  animation: tapPulse 1.25s ease-in-out infinite;
}

@keyframes tapPulse{
  0%{
    opacity:.4;
    transform:translateX(-50%) scale(.95);
  }
  50%{
    opacity:1;
    transform:translateX(-50%) scale(1.1);
  }
  100%{
    opacity:.4;
    transform:translateX(-50%) scale(.95);
  }
}

/* =========================
   VIGNETTE BAS (FOCUS VISUEL)
========================== */
#overlayIntro{
  box-shadow: inset 0 -140px 160px rgba(0,0,0,.55);
}


  /* =========================
     OPTIONS MENU (REDESIGN)
  ========================== */
  #optionsPanel{
    position:absolute;
    inset:0;
    display:none;
    flex-direction:column;
    z-index:10000;
    background:
      radial-gradient(circle at 50% 40%, rgba(0,220,255,.10), rgba(0,0,0,0) 48%),
      linear-gradient(180deg, rgba(5,10,25,.92), rgba(0,0,0,.75));
    backdrop-filter:blur(10px) saturate(1.05);
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }

  #optionsPanel .optionsBox{
    width:100%;
    max-width:440px;
    padding:42px 38px;
    background:linear-gradient(180deg, rgba(12,20,48,.72), rgba(6,10,26,.62));
    border-radius:20px;
    box-shadow:
      0 0 0 1px rgba(255,255,255,.06) inset,
      0 0 42px rgba(80,150,255,.18),
      0 0 90px rgba(40,120,255,.08);
    color:#cfe9ff;
    margin-top:34px;
    transform:translateY(-18px);
    border:1px solid rgba(140,200,255,0.18);
  }

  #optionsPanel h2{
    text-align:center;
    margin-bottom:26px;
    letter-spacing:4px;
    text-transform:uppercase;
    font-weight:900;
  }

  .optRow{
    margin-bottom:20px;
  }

  .optRow label{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
    font-weight:700;
    opacity:.95;
  }

  #optionsPanel input[type="range"]{
    width:100%;
    accent-color:#39bafc;
  }

  #optionsPanel input[type="checkbox"]{
    transform:scale(1.05);
    accent-color:#39bafc;
  }

  #optBack{
    width:100%;
    margin-top:26px;
  }



/* =========================
   GAME OVER OVERLAY ‚Äî AAA
========================== */

#overlayGameOver{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;

  background:
    radial-gradient(circle at 50% 45%,
      rgba(80,120,255,.12),
      rgba(0,0,0,.92) 55%,
      rgba(0,0,0,.98)
    );

  visibility:hidden;
  opacity:0;
  pointer-events:none;

  transition:opacity .35s ease;
  z-index:100; /* AU-DESSUS DE TOUT */
}

#overlayGameOver.visible{
  visibility:visible;
  opacity:1;
  pointer-events:auto;
}


/* =========================
   GAME OVER CARD
========================== */

.gameOverCard{
  position:relative;
  min-width:260px;
  max-width:86%;
  padding:26px 28px 30px;

  display:flex;
  flex-direction:column;
  align-items:center;
  gap:16px;

  border-radius:18px;

  background:
    linear-gradient(180deg,
      rgba(12,18,38,.95),
      rgba(4,6,14,.95)
    );

  border:1px solid rgba(140,200,255,.22);

  box-shadow:
    0 0 0 1px rgba(255,255,255,.04) inset,
    0 0 40px rgba(80,140,255,.25),
    0 0 90px rgba(40,80,200,.18);
}


/* =========================
   GAME OVER TITLE
========================== */

.gameOverTitle{
  font-size:34px;
  font-weight:900;
  letter-spacing:3px;
  margin:0;

  color:#ffd0dc;
  text-shadow:
    0 0 14px rgba(255,120,160,.6),
    0 0 32px rgba(120,80,160,.35);
}


/* =========================
   STATS
========================== */

.gameOverStats{
  width:100%;
  display:flex;
  flex-direction:column;
  gap:8px;
}

.gameOverStats p{
  margin:0;
  display:flex;
  justify-content:space-between;

  font-size:15px;
  font-weight:800;
  letter-spacing:1px;
  color:#eaf6ff;
}

.gameOverStats span{
  font-weight:900;
  color:#ffd36a;
  text-shadow:
    0 0 8px rgba(255,210,120,.7),
    0 0 16px rgba(255,180,80,.5);
}


/* =========================
   ACTION BUTTONS
========================== */

.gameOverActions{
  display:flex;
  gap:14px;
  margin-top:6px;
}

.gameOverActions .bigButton{
  min-width:120px;
  padding:12px 18px;
  border-radius:999px;

  font-size:14px;
  font-weight:900;
  letter-spacing:1px;

  border:none;
  cursor:pointer;

  background:
    linear-gradient(180deg,
      rgba(120,220,255,.95),
      rgba(40,140,255,.95)
    );

  color:#001020;

  box-shadow:
    0 0 18px rgba(120,220,255,.85),
    0 0 36px rgba(80,160,255,.55);

  transition:transform .15s ease, box-shadow .15s ease;
}

.gameOverActions .bigButton:hover{
  transform:scale(1.06);
  box-shadow:
    0 0 26px rgba(160,240,255,.95),
    0 0 60px rgba(80,160,255,.65);
}




  
#uiCoins{
  position:absolute;
  top:16px;
  left:16px;
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 14px;
  border-radius:999px;
  background:rgba(0,0,0,.40);
  backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,.12);
  box-shadow:
    0 0 0 1px rgba(255,255,255,.05) inset,
    0 0 20px rgba(255,200,80,.20);
  z-index:20;
  pointer-events:none;
}

#uiCoins .coinIcon{
  width:18px;
  height:18px;
  border-radius:50%;
  background:radial-gradient(circle at 30% 30%, #fff6c7, #ffb400 60%, #ff7a00);
  box-shadow:
    0 0 10px rgba(255,200,80,.85),
    0 0 22px rgba(255,150,40,.35);
}

#uiCoins .coinValue{
  font-size:14px;
  font-weight:900;
  color:#ffd36a;
  text-shadow:0 0 10px rgba(255,211,106,.55);
}

#menuAnim{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  z-index:0;
}
  /* =========================
   GAME STATE VISIBILITY
========================== */
body.playing #menuOverlay{
  display:none !important;
  body.playing #menuOverlay,
body.playing #menuVideo,
body.playing #galaxyBG,
body.playing .menuParticles
  display:none !important;
  visibility:hidden !important;
  opacity:0 !important;
  pointer-events:none !important;
}


#touchZone{
  touch-action: none;
  -webkit-touch-callout: none;
  user-select: none;
}
/* =========================
   FINAL FULLSCREEN FIX ‚Äî ALL DEVICES
========================== */
#gameContainer{
  position:absolute !important;
  inset:0 !important;
  width:100vw !important;
  height:100vh !important;
  max-width:100vw !important;
  max-height:100vh !important;
  border-radius:0 !important;
}


/* =========================
   MENU AD ‚Äî MOBILE COMPACT
========================== */
@media (max-width: 768px){

  #menuAdPopup{
    top:auto !important;
    bottom:12px !important;
    left:50%;
    transform:translateX(-50%) scale(0.82);
    width:calc(100% - 24px);
    max-width:320px;
  }

  #menuAdPopup *{
    font-size:90%;
  }
}
/* =========================
   SHOP AD ‚Äî MOBILE SCALE ONLY
========================= */
@media (max-width: 900px){
  #shopAdBlock{
    transform: translateX(-50%) scale(0.82);
    transform-origin: top center;
    padding: 12px 14px 14px;
  }

  #shopAdBlock #shopAdBtn{
    padding: 8px 14px;
    font-size: 12px;
  }

  #shopAdBlock div{
    font-size: 11px;
  }
}
/* ===== SHOP AD ‚Äî MOBILE SAFE ===== */
@media (max-width: 720px){
  #shopAdBlock{
    width: min(88%, 300px) !important;
    padding: 12px 14px 14px !important;
    border-radius: 18px !important;
  }

  #shopAdBlock div{
    font-size: 11px !important;
  }

  #shopAdBtn{
    padding: 8px 14px !important;
    font-size: 12px !important;
  }
}
body.playing #gameContainer{
  background:#05060a !important;
}
#rotateOverlay{
  position:fixed;
  inset:0;
  background:#05060a;
  z-index:999999;
  display:none;
  align-items:center;
  justify-content:center;
}

#rotateOverlay .rotateBox{
  color:white;
  font-size:22px;
  font-weight:900;
  text-align:center;
  opacity:.9;
}

</style>

</head>
<body>

<audio id="musicMenu" src="audio/Menu.ogg" loop preload="auto"></audio>
<audio id="musicGame" src="audio/game.ogg" loop preload="auto"></audio>
<audio id="sfxDeath" src="audio/death.ogg" preload="auto"></audio>
<audio id="sfxIntro" src="audio/intro_burst.mp3" preload="auto"></audio>
<audio id="sfxOverdrive" src="audio/overdrive_start.mp3" preload="auto"></audio>

<!-- =========================
     INTRO
========================== -->
<div id="overlayIntro">
  <!-- FX braises -->
  <canvas id="introEmbers"></canvas>

  <div class="introContent">
   <div id="introLogo" class="introHero">
  <img src="./assets/MJLogo.png"> 
    </div>

    <div class="introHint">
    TAP TO START
    </div>
  </div>
</div>

<!-- TRANSITION FX -->
<div id="transitionFX"></div>

<!-- =========================
     MENU PRINCIPAL
========================== -->
<div id="menuOverlay">
  <canvas id="galaxyBG"></canvas>
  <div class="menuParticles"></div>

<video
  id="menuVideo"
  muted
  loop
  playsinline
  preload="none"
  data-src="./assets/menu_bg.mp4"
></video>

<!-- MENU AD SLIDE -->
<div id="menuAdPopup"
  style="
    position:absolute;
    top:-80px;
    left:50%;
    transform:translateX(-50%);
    width:260px;
    padding:12px 16px;
    border-radius:14px;
    background:linear-gradient(180deg, rgba(20,32,70,.95), rgba(8,14,32,.95));
    box-shadow:0 12px 40px rgba(40,90,160,.45);
    text-align:center;
    z-index:120;
    transition:top .6s ease, opacity .6s ease;
    opacity:0;
    pointer-events:auto;
  ">

  <div style="font-size:14px; font-weight:700; color:#cfe8ff;">
    üéÅ Watch an ad
  </div>

  <div style="font-size:12px; opacity:.8; margin:4px 0 10px;">
    Get <b>49 coins</b> instantly
  </div>

  <button id="menuAdBtn"
    class="bigButton"
    style="padding:8px 18px; font-size:13px;">
    Watch ad (+49)
  </button>

  <div id="menuAdCount"
    style="margin-top:6px; font-size:11px; opacity:.6;">
    5 / 5 ads left
  </div>
</div>


  <div id="menuStats">
  <div class="statBox best">
    <div class="statLabel">BEST</div>
    <div class="statValue" id="menuBest">0</div>
  </div>

  <div class="statBox coins">
    <div class="statLabel">COINS</div>
    <div class="statValue" id="menuCoins">0</div>
  </div>
</div>


  <div id="menuButtons">
    <button id="btnPlay" class="menuBtn">PlAY</button>
    <button id="btnShop" class="menuBtn">SHOP</button>
    <button id="btnOptions" class="menuBtn">SETTINGS</button>
  </div>

  <div id="shopBackBtn">‚Üê</div>

<div id="shopStats">
  <div class="statBox">
    <div class="statLabel">BEST</div>
    <div class="statValue" id="shopBest">0</div>
  </div>
  <div class="statBox coins">
    <div class="statLabel">COINS</div>
    <div class="statValue" id="shopCoins">0</div>
  </div>
</div>

  <div id="shopPanel"></div>
  
</div>




<!-- =========================
     OPTIONS
========================== -->
<div id="optionsPanel">
  <div class="optionsBox">
    <h2>SETTINGS</h2>

    <div class="optRow">
      <label>üéµ Music</label>
      <input id="optMusic" type="range" min="0" max="100">
    </div>

    <div class="optRow">
      <label>üîä Effects</label>
      <input id="optSfx" type="range" min="0" max="100">
    </div>

    <div class="optRow">
      <label>
        <input id="optMute" type="checkbox"> üîá Mute
      </label>
    </div>

    <button id="optBack" class="menuBtn">BACK</button>
  </div>
</div>


<!-- =========================
     JEU
========================== -->
<div id="gameContainer">
  <canvas id="game" width="720" height="405"></canvas>


  <!-- UI LAYER (TOUT L‚ÄôIN-GAME UI) -->
  <div id="uiLayer">

    <!-- COINS -->
    <div id="uiCoins">
      <div class="coinIcon"></div>
      <div class="coinValue" id="coinCount">0</div>
    </div>

    <!-- SCORE -->
    <div id="ui">
      <div id="uiScore">0</div>
    </div>

    <!-- OVERDRIVE -->
    <div id="overdriveMeter">
      <div id="overdriveLabel">BOOST</div>
      <div id="overdriveBarOuter">
        <div id="overdriveBarInner"></div>
      </div>
    </div>

    <!-- COMBO -->
    <div id="combo">x<span id="comboVal">1</span></div>
<!-- CONTINUE POPUP (REVIVE ‚Äî AAA MICRO) -->
<div id="continuePopup"
  style="
    position:absolute;
    bottom:42%;
    left:50%;
    transform:translateX(-50%);
    display:none;
    z-index:210;
    pointer-events:auto;
  ">

  <div
    style="
      width:180px;
      padding:12px 12px 10px;
      border-radius:14px;

      background:
        radial-gradient(120% 140% at 50% 0%, rgba(140,200,255,.18), transparent 60%),
        linear-gradient(180deg, rgba(18,30,76,.98), rgba(8,14,36,.98));

      box-shadow:
        0 0 0 1px rgba(255,255,255,.05) inset,
        0 12px 36px rgba(40,90,160,.5);

      text-align:center;
      animation:reviveIn .18s cubic-bezier(.2,.8,.2,1) forwards;
      transform-origin:center bottom;
    "
  >

    <!-- TITLE -->
    <div
      style="
        font-size:14px;
        font-weight:900;
        margin-bottom:3px;
        color:#f5f9ff;
        letter-spacing:.15px;
      ">
      ‚ö° Second chance
    </div>

    <!-- DESC -->
    <div
      style="
        font-size:11.5px;
        line-height:1.3;
        opacity:.85;
        margin-bottom:8px;
        color:#d6e2ff;
      ">
      Keep your run alive
    </div>

    <!-- CTA -->
    <div id="continueAdBtn"
      style="
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:6px;

        padding:8px 14px;
        border-radius:999px;

        background:linear-gradient(180deg, #a6f3ff, #56c6ff);
        color:#03121c;

        font-size:12.5px;
        font-weight:900;
        cursor:pointer;

        box-shadow:
          0 0 0 1px rgba(255,255,255,.35) inset,
          0 0 18px rgba(140,230,255,.9);

        margin-bottom:5px;
      ">
      ‚ö° Continue
    </div>

    <!-- TIMER -->
    <div id="continueTimer"
      style="
        font-size:10px;
        opacity:.45;
        color:#c6d6ff;
      ">
      <span id="continueSeconds">4</span>s left
    </div>

  </div>
</div>

<style>
@keyframes reviveIn{
  from{
    opacity:0;
    transform:translateY(10px) scale(.97);
  }
  to{
    opacity:1;
    transform:translateY(0) scale(1);
  }
}
</style>

<!-- GAME OVER -->
<div id="overlayGameOver">
  <div class="gameOverCard">

    <!-- NEW RECORD -->
    <div id="newRecord"
      style="
        font-size:48px;
        font-weight:900;
        color:#ffd700;
        text-shadow:0 0 25px #ffea00;
        opacity:0;
        transform:scale(0.6);
        transition:opacity .5s, transform .5s;
        display:none;
      ">
      NEW RECORD !
    </div>

    <h2 class="gameOverTitle">Game Over !</h2>

    <div class="gameOverStats">
      <p>Score <span id="finalScore">0</span></p>
      <p>Best Score <span id="finalBest">0</span></p>
      <p>Coins <span id="finalCoins">0</span></p>
    </div>

    <div class="gameOverActions">
      <button id="restartBtn" class="bigButton">Play Again</button>
      <button id="menuBtn" class="bigButton">Main Menu</button>
    </div>
</div>
</div>

  <!-- INPUT ZONE -->
  <div id="touchZone" style="position:absolute; inset:0; z-index:10;"></div>
</div>
<div id="rotateOverlay">
  <div class="rotateBox">
    üîÑ<br>
Rotate your phone
  </div>
</div>

</body>

<script>
/* =========================================================
   GLOBAL STATE ‚Äî SAFE BOOTSTRAP
========================================================= */
const SPAWN_MARGIN_X = 260;

// ================= GAME CORE =================
let gameState = "intro";
let gameRunning = true; // üî• UNIQUE source de v√©rit√© (NE PAS red√©clarer ailleurs)

let equippedSkin = "moony";
// ================= TRAIL TIMING =================

let skinId = localStorage.getItem("currentSkin") || "solar";
let t = 0; // temps global logique
let gameOverTriggered = false;
let isTouch = false;
let noiseCanvas = null;
let moonyExpr = 0;
let lastFrameTime = performance.now();
let worstDelta = 0;
let lastOverdrivePct = -1;
let reviveInvincible = false;
let reviveInvTimer = 0;
// ================= BACKGROUND =================
const bgCanvas = document.createElement("canvas");
const bgCtx = bgCanvas.getContext("2d");

// ================= CANVAS =================
const canvas = document.getElementById("game");
if (!canvas) throw new Error("Canvas #game introuvable");

const ctx = canvas.getContext("2d");
if (!ctx) throw new Error("Contexte 2D impossible");

// ================= WORLD / CAMERA =================
const BASE_W = 810; // üëà Modifi√© pour le ratio 2:1 (Fullscreen mobile)
const BASE_H = 405;

let bgScroll = 0;
let currentScale = 1;
let currentDPR   = 1;

let cameraScale   = 1;
let cameraOffsetX = 0;
let cameraOffsetY = 0;

// ================= PATH CACHES (iOS SAFE) =================
const _arcPathCache  = new Map();
const _rectPathCache = new Map();

function _getArcPath(r){
  const rq = Math.max(1, Math.round(r * 2) / 2);
  const key = rq.toFixed(2);
  let p = _arcPathCache.get(key);
  if (!p){
    p = new Path2D();
    p.arc(0, 0, rq, 0, Math.PI * 2);
    _arcPathCache.set(key, p);
  }
  return p;
}

function _getRectPath(w, h, r = 8){
  const key = ((w | 0) << 16) | (h | 0);
  let p = _rectPathCache.get(key);
  if (!p){
    p = new Path2D();
    p.roundRect(0, 0, w, h, r);
    _rectPathCache.set(key, p);
  }
  return p;
}

// ================= FRAME / FX =================
let frameCount = 0;
let fxCalm = 1;

const OVERDRIVE_CALM = {
  glow: 0.65,
  blur: 0.6,
  alpha: 0.7
};

/* =========================================================
   FX QUALITY MANAGER ‚Äî SINGLE INSTANCE
========================================================= */

const FXQuality = (() => {

  let tier = 2; // 0..3
  let scene = "game";
  let forceTier = null;

  let lastT = 0;
  let emaDt = 16.67;
  let emaFps = 60;
  const alpha = 0.08;

  let cooldown = 0;
  const UP_COOLDOWN = 0.9;

  const isMobile =
    (typeof navigator !== "undefined" &&
     /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) ||
    (typeof matchMedia !== "undefined" &&
     matchMedia("(pointer: coarse)").matches);

  function setScene(s){
    scene = s || "game";
  }

  function setForceTier(v){
    forceTier = (v === 0 || v === 1 || v === 2 || v === 3) ? v : null;
  }

  function update(ts){
    if (!lastT){
      lastT = ts;
      return;
    }

    const dt = ts - lastT;
    lastT = ts;
    if (dt > 1200) return;

    emaDt  += (dt - emaDt) * alpha;
    emaFps  = 1000 / Math.max(1, emaDt);

    if (forceTier !== null){
      tier = forceTier;
      return;
    }

    let down45 = 48, down35 = 38, up55 = 57, up60 = 61;

    if (scene === "menu"){
      down45 = 43; down35 = 33; up55 = 53; up60 = 58;
    } else if (scene === "shop"){
      down45 = 46; down35 = 36; up55 = 56; up60 = 60;
    }

    if (isMobile){
      up60 -= 6;
      up55 -= 4;
      down45 += 1;
      down35 += 1;
    }

    if (cooldown > 0){
      cooldown -= dt * 0.001;
    }

    if (emaFps < down35){
      tier = Math.max(0, tier - 2);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (emaFps < down45){
      tier = Math.max(0, tier - 1);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (cooldown <= 0){
      if (emaFps > up60){
        tier = Math.min(3, tier + 1);
      } else if (emaFps > up55 && tier < 2){
        tier = Math.min(2, tier + 1);
      }
    }
  }

  function q(){ return tier; }
  function fps(){ return emaFps; }

  function scaleCount(base, minFactor = 0.35){
    const f = tier === 3 ? 1 : tier === 2 ? 0.85 : tier === 1 ? 0.65 : 0.45;
    return Math.max(1, Math.round(base * Math.max(minFactor, f)));
  }

  function scaleAlpha(base){
    const f = tier === 3 ? 1 : tier === 2 ? 0.92 : tier === 1 ? 0.78 : 0.65;
    return base * f;
  }

  function allowHeavy(){
    if (tier === 0) return false;
    if (tier === 1 && scene === "shop") return false;
    return true;
  }

  return {
    update,
    setScene,
    setForceTier,
    q,
    fps,
    isMobile,
    scaleCount,
    scaleAlpha,
    allowHeavy
  };

})();

// ================= GLOBAL FX FLAGS =================
const IS_MOBILE = FXQuality.isMobile;
const USE_PATH  = !IS_MOBILE;

// üîí mobile = LOW forc√© (une seule fois)
if (IS_MOBILE){
  FXQuality.setForceTier(0);
}

/* =========================================================
   ORIENTATION / ROTATION ‚Äî SAFE
========================================================= */

function checkOrientation(){
  const overlay = document.getElementById("rotateOverlay");
  if (!overlay) return;

  const w = window.innerWidth  || 0;
  const h = window.innerHeight || 0;
  if (!w || !h) return;

  const portrait = h > w;
  overlay.style.display = portrait ? "flex" : "none";
  gameRunning = !portrait;
}

window.addEventListener("resize", checkOrientation, { passive:true });
window.addEventListener("orientationchange", () => {
  setTimeout(checkOrientation, 120);
}, { passive:true });

setTimeout(checkOrientation, 0);

function lockLandscape(){
  if (!window.screen || !screen.orientation || !screen.orientation.lock) return;
  try { screen.orientation.lock("landscape").catch(()=>{}); } catch(e){}
}

window.addEventListener("pointerdown", lockLandscape, { once:true });


/* =========================================================
   MENU / VIDEO / AUDIO ‚Äî SAFE & MOBILE FRIENDLY
========================================================= */

// ================= MENU VIDEO =================
const menuVideo = document.getElementById("menuVideo") || null;

let menuVideoStarted = false;
let menuVideoWarmed  = false;

// ================= MENU FLOW =================
async function showMenu(){

  // üîí STOP JEU PROPREMENT
  gameRunning = false;
  if (typeof accTime !== "undefined") accTime = 0;
  if (typeof lastFrame !== "undefined") lastFrame = null;

  fxCalm = 0;

  // üß≠ UI
  if (typeof menuOverlay !== "undefined" && menuOverlay){
    menuOverlay.style.display = "flex";
  }

  // üéûÔ∏è VIDEO MENU
  if (menuVideo){
    try {
      menuVideo.pause();
      menuVideo.currentTime = 0;

      requestAnimationFrame(() => {
        menuVideo.play().catch(()=>{});
      });
    } catch(e){}
  }

  // üéµ MUSIQUE MENU
  loadMenuMusic(); // fire & forget
  setTimeout(() => {
    playMenuMusic();
  }, 150);
}

function hideMenu(){
  if (typeof menuOverlay !== "undefined" && menuOverlay){
    menuOverlay.style.display = "none";
  }
  stopMenuMusic();
}

// ================= VIDEO WARMUP (iOS SAFE) =================
function warmupMenuVideo(){
  if (!menuVideo || menuVideoWarmed) return;

  try {
    menuVideo.style.visibility = "hidden";
    menuVideo.currentTime = 0;

    menuVideo.play().then(() => {
      setTimeout(() => {
        try {
          menuVideo.pause();
          menuVideo.currentTime = 0;
          menuVideo.style.visibility = "visible";

          menuVideo.loop = true;
          menuVideo.play().catch(()=>{});
          menuVideoWarmed = true;
        } catch(e){}
      }, 300);
    }).catch(()=>{});
  } catch(e){}
}

// =========================================================
// AUDIO (WEB AUDIO ‚Äî SAFE)
// =========================================================

let audioCtx = null;
try {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
} catch(e){
  audioCtx = null;
}

let menuMusicBuffer = null;
let menuMusicSource = null;

async function loadMenuMusic(){
  if (!audioCtx || menuMusicBuffer) return;

  try {
    const res = await fetch("audio/Menu.ogg");
    if (!res.ok) throw new Error("HTTP " + res.status);

    const arr = await res.arrayBuffer();
    menuMusicBuffer = await audioCtx.decodeAudioData(arr);

  } catch(e){
    console.warn("Menu music disabled:", e.message);
    menuMusicBuffer = null;
  }
}

function playMenuMusic(){
  if (!audioCtx || !menuMusicBuffer || menuMusicSource) return;

  try {
    const src = audioCtx.createBufferSource();
    src.buffer = menuMusicBuffer;
    src.loop = true;
    src.connect(audioCtx.destination);
    src.start(0);
    menuMusicSource = src;
  } catch(e){}
}

function stopMenuMusic(){
  if (!menuMusicSource) return;

  try {
    menuMusicSource.stop();
    menuMusicSource.disconnect();
  } catch(e){}
  menuMusicSource = null;
}

// =========================================================
// ADS (SAFE GUARDS)
// =========================================================

const USE_REAL_ADS = true;
let adBusy = false;

function showRewardedAd(onSuccess, onFail){
  if (adBusy) return;
  adBusy = true;

  // DEV MODE
  if (!USE_REAL_ADS){
    setTimeout(() => {
      adBusy = false;
      onSuccess && onSuccess();
    }, 800);
    return;
  }

  // PROD
  if (!window.UnityAds || !UnityAds.isReady || !UnityAds.isReady("rewardedVideo")){
    adBusy = false;
    onFail && onFail("not_ready");
    return;
  }

  UnityAds.show("rewardedVideo", {
    onComplete(){
      adBusy = false;
      onSuccess && onSuccess();
    },
    onSkip(){
      adBusy = false;
      onFail && onFail("skipped");
    },
    onError(e){
      adBusy = false;
      onFail && onFail(e);
    }
  });
}

// =========================================================
// FX STATE (SINGLE SOURCE)
// =========================================================

const FX = {
  level: 1,
  preview: false,
  overdrive: false,
  intensity: 1
};

function updateFXState(){
  if (typeof uiState !== "undefined" && uiState === "shop"){
    FX.preview   = true;
    FX.overdrive = false;
    FX.level     = 0;
    FX.intensity = 0.3;
    return;
  }

  FX.preview = false;

  if (gameState === "playing"){
    FX.overdrive = document.body.classList.contains("overdriveActive");
    FX.level     = FX.overdrive ? 2 : 1;
    FX.intensity = FX.overdrive ? 1 : 0.6;
    return;
  }

  FX.level = 0;
  FX.intensity = 0;
  FX.overdrive = false;
}

function updateFXCalm(delta){
  if (delta > 20){
    fxCalm = Math.max(0.55, fxCalm - 0.08);
  } else {
    fxCalm = Math.min(1, fxCalm + 0.05);
  }
}

// =========================================================
// CANVAS QUALITY (SAFE)
// =========================================================

if (ctx){
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
}

// =========================================================
// UI REFERENCES (SAFE INIT)
// =========================================================

const UI = {
  score: null,
  best: null,
  coins: null,
  combo: null,
  overCount: null,
  overFill: null
};

/* =========================
   VIEWPORT (SAFE)
========================= */
function getViewport(){
  // visualViewport peut √™tre instable sur iOS ‚Üí fallback propre
  const vv = window.visualViewport;
  if (vv && typeof vv.width === "number" && typeof vv.height === "number"){
    return { w: vv.width, h: vv.height };
  }
  return { w: window.innerWidth || 0, h: window.innerHeight || 0 };
}

/* =========================
   RESIZE (DPR + CANVAS) ‚Äî SAFE
========================= */
function resizeCanvas(){
  if (!canvas) return;

  const { w, h } = getViewport();
  if (!w || !h) return;

  // DPR plafonn√© (mobile/iOS safe)
  const dpr = window.devicePixelRatio || 1;
  currentDPR = Math.min(dpr, 1.5);

  const cw = Math.round(w * currentDPR);
  const ch = Math.round(h * currentDPR);

  if (canvas.width !== cw)  canvas.width  = cw;
  if (canvas.height !== ch) canvas.height = ch;

  canvas.style.width  = Math.round(w) + "px";
  canvas.style.height = Math.round(h) + "px";

  updateCamera(w, h);
}

/* =========================
   CAMERA (FIT STRICT + LETTERBOX)
========================= */
let VIEW_W = 0;
let VIEW_H = 0;
let OFF_X  = 0;
let OFF_Y  = 0;

function updateCamera(vw, vh){
  if (!vw || !vh) return;

  const scaleX = vw / BASE_W;
  const scaleY = vh / BASE_H;

  // gameplay non d√©form√©
  cameraScale = Math.min(scaleX, scaleY);

  cameraOffsetX = (vw - BASE_W * cameraScale) * 0.5;
  cameraOffsetY = (vh - BASE_H * cameraScale) * 0.5;

  // dimensions visibles en coordonn√©es monde
  VIEW_W = vw / cameraScale;
  VIEW_H = vh / cameraScale;

  // zones hors gameplay (bandes)
  OFF_X = Math.max(0, (VIEW_W - BASE_W) * 0.5);
  OFF_Y = Math.max(0, (VIEW_H - BASE_H) * 0.5);
}

/* =========================
   LISTENERS RESIZE (SAFE)
========================= */
window.addEventListener("resize", resizeCanvas, { passive:true });

if (window.visualViewport){
  window.visualViewport.addEventListener("resize", resizeCanvas, { passive:true });
}

resizeCanvas();

/* =========================
   UI BINDING (SAFE)
========================= */
let uiBound = false;

function bindUI(){
  if (uiBound) return;
  uiBound = true;

  UI.score     = document.getElementById("uiScore")        || null;
  UI.best      = document.getElementById("uiBest")         || null;
  UI.coins     = document.getElementById("coinCount")      || null;
  UI.combo     = document.getElementById("comboVal")       || null;
  UI.overCount = document.getElementById("overdriveCount") || null;
  UI.overFill  = document.getElementById("overdriveBarInner") || null;
}

function safeText(el, value){
  if (el) el.textContent = value;
}

/* =========================
   INPUT ZONE (POINTER SAFE)
========================= */
const touchZone = document.getElementById("touchZone");

if (touchZone){

  // d√©tecte environnement tactile une seule fois
  window.addEventListener("touchstart", () => {
    isTouch = true;
  }, { once:true, passive:true });

  let lastPointerTime = 0;

  // PRESS ‚Üí jet ON
  touchZone.addEventListener("pointerdown", (e) => {
    if (uiState !== "playing") return;

    const now = performance.now();
    if (now - lastPointerTime < 220){
      e.preventDefault();
      return;
    }
    lastPointerTime = now;

    e.preventDefault();
    jetStart();
  });

  // bloque dblclick desktop
  touchZone.addEventListener("dblclick", e => {
    e.preventDefault();
  });

  // RELEASE ‚Üí jet OFF
  function stopJet(e){
    if (uiState !== "playing") return;
    if (e && e.preventDefault) e.preventDefault();
    jetStop();
  }

  touchZone.addEventListener("pointerup", stopJet);
  touchZone.addEventListener("pointercancel", stopJet);
  touchZone.addEventListener("pointerleave", stopJet);
  touchZone.addEventListener("pointerout", stopJet);
}




/* ============================
   AUDIO MANAGER (STABLE)
============================ */

// üî¥ supprim√© : gameMusicStopTimer (inutile, jamais utilis√©)

const musicMenu = document.getElementById("musicMenu");
const musicGame = document.getElementById("musicGame");
const sfxDeath  = document.getElementById("sfxDeath");
const sfxOverdrive = document.getElementById("sfxOverdrive");

const audioSettings =
  JSON.parse(localStorage.getItem("audioSettings") || "null")
  || { music:70, sfx:80, mute:false };

// volumes fixes
if (sfxOverdrive) sfxOverdrive.volume = 0.3;

// üîê verrou navigateur (iOS / Chrome mobile)
let audioUnlocked = false;
let currentMusic = "none"; // "menu" | "game" | "none"

function clamp01(v){
  return Math.max(0, Math.min(1, v));
}

/* =========================
   AUDIO UNLOCK (CRITIQUE)
========================= */
function unlockAudio(){
  if (audioUnlocked) return;
  audioUnlocked = true;

  // ‚ö†Ô∏è d√©verrouille HTMLAudio
  [musicMenu, musicGame, sfxDeath, sfxOverdrive].forEach(a => {
    if (!a) return;
    try {
      a.muted = true;
      a.play().then(() => {
        a.pause();
        a.currentTime = 0;
        a.muted = false;
      }).catch(()=>{});
    } catch(e){}
  });

  // ‚ö†Ô∏è d√©verrouille AudioContext (menu video / music)
  if (window.audioCtx && audioCtx.state === "suspended"){
    audioCtx.resume().catch(()=>{});
  }

  // reprend la musique demand√©e
  if (currentMusic !== "none"){
    playMusic(currentMusic);
  }
}

// üëÜ UN SEUL gesture suffit
window.addEventListener("pointerdown", unlockAudio, { once:true });
window.addEventListener("touchstart", unlockAudio, { once:true });

/* =========================
   SETTINGS
========================= */
function applyAudioSettings(){
  const m = audioSettings.mute ? 0 : clamp01(audioSettings.music / 100);
  const s = audioSettings.mute ? 0 : clamp01(audioSettings.sfx / 100);

  if (musicMenu) musicMenu.volume = m * 0.9;
  if (musicGame) musicGame.volume = m;
  if (sfxDeath)  sfxDeath.volume  = s;
}

/* =========================
   CORE CONTROL
========================= */
function stopMusic(track){
  if (!track) return;
  try { track.pause(); } catch(e){}
  try { track.currentTime = 0; } catch(e){}
}

function playMusic(which){
  currentMusic = which;

  if (!audioUnlocked) return;

  if (audioSettings.mute){
    stopMusic(musicMenu);
    stopMusic(musicGame);
    return;
  }

  applyAudioSettings();

  if (which === "menu"){
    stopMusic(musicGame);
    if (musicMenu){
      musicMenu.loop = true;
      musicMenu.volume = clamp01(audioSettings.music/100) * 0.9;
      musicMenu.play().catch(()=>{});
    }
    return;
  }

  if (which === "game"){
    stopMusic(musicMenu);
    if (musicGame){
      musicGame.loop = true;
      musicGame.volume = clamp01(audioSettings.music/100);
      musicGame.play().catch(()=>{});
    }
    return;
  }

  stopMusic(musicMenu);
  stopMusic(musicGame);
}

/* =========================
   FADE (OPTIONNEL, SAFE)
========================= */
function fadeAudio(audio, targetVolume, duration = 260){
  if (!audio || audioSettings.mute) return;

  const start = audio.volume;
  const delta = targetVolume - start;
  const startTime = performance.now();

  function step(now){
    const t = Math.min(1, (now - startTime) / duration);
    audio.volume = start + delta * t;
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================
   UI OPTIONS
========================= */
const optMusic = document.getElementById("optMusic");
const optSfx   = document.getElementById("optSfx");
const optMute  = document.getElementById("optMute");

if (optMusic && optSfx && optMute){

  optMusic.value  = audioSettings.music;
  optSfx.value    = audioSettings.sfx;
  optMute.checked = audioSettings.mute;

  optMusic.addEventListener("input", () => {
    audioSettings.music = +optMusic.value;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
    applyAudioSettings();
    playMusic(currentMusic);
  });

  optSfx.addEventListener("input", () => {
    audioSettings.sfx = +optSfx.value;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
    applyAudioSettings();
  });

  optMute.addEventListener("change", () => {
    audioSettings.mute = optMute.checked;
    localStorage.setItem("audioSettings", JSON.stringify(audioSettings));

    if (audioSettings.mute){
      playMusic("none");
    } else {
      if (gameState === "playing") playMusic("game");
      else playMusic("menu");
    }
  });
}

applyAudioSettings();
bindUI();


/* =========================
   GAME OVER / CORE STATE
========================== */

// --- GAME OVER UI ---
const finalScoreEl = document.getElementById("finalScore");
const finalBestEl  = document.getElementById("finalBest");
const finalCoinsEl = document.getElementById("finalCoins");

// --- OVERLAYS ---
const overlayMenu     = document.getElementById("menuOverlay");
const overlayGameOver = document.getElementById("overlayGameOver");

// --- INPUT ---
const restartBtn = document.getElementById("restartBtn");

// --- OVERDRIVE UI ---
const OVERDRIVE_MAX = 20;
const overdriveBar     = document.getElementById("overdriveBarInner");
const overdriveCountEl = document.getElementById("overdriveCount");

// --- FX / HUD ---
const tint     = document.getElementById("tint");
const comboVal = document.getElementById("comboVal");

// --- MENUS / PANELS ---
const overlayIntro   = document.getElementById("overlayIntro");
const optionsPanelEl = document.getElementById("optionsPanel");
const transitionFX   = document.getElementById("transitionFX");

// --- AUDIO ---
const sfxIntro = document.getElementById("sfxIntro");

/* =========================
   UI SAFETY
========================= */

function safeStyle(el, prop, value){
  if (el) el.style[prop] = value;
}

/* =========================
   OVERDRIVE LOGIC
========================= */
function addOverdrive(amount){
  if (overdriveActive) return;

  overdrive += amount;

  if (overdrive >= OVERDRIVE_THRESHOLD){
    overdrive = 0;
    activateOverdrive();
  }

  updateOverdriveUI();
}

function activateOverdrive(){
  if (overdriveActive) return;

  overdriveActive = true;
  overdriveTimer = overdriveDuration;

  document.body.classList.add("overdriveActive");
  document.body.classList.remove("overdriveEnding");

  if (sfxOverdrive && !audioSettings.mute){
    sfxOverdrive.volume = clamp01(audioSettings.sfx / 100);
    sfxOverdrive.currentTime = 0;
    sfxOverdrive.play().catch(()=>{});
  }
}

function deactivateOverdrive(){
  overdriveActive = false;
  overdriveTimer = 0;
  overdrive = 0;

  document.body.classList.remove("overdriveActive");
  document.body.classList.remove("overdriveEnding");

  updateOverdriveUI();
}

function updateOverdriveUI(){
  if (overdriveActive) return;

  const ratio = Math.min(1, overdrive / OVERDRIVE_THRESHOLD);
  if (UI.overFill)  UI.overFill.style.height = (ratio * 100) + "%";
  if (UI.overCount) UI.overCount.textContent = Math.floor(overdrive);
}

/* =========================
   INTRO TRANSITION (SAFE)
========================= */
function playIntroTransition(){
  if (!overlayIntro) return;

  // ‚ùå PAS DE audioUnlocked = true ICI

  overlayIntro.classList.add("fx-impact");
  transitionFX?.classList.add("flash");

  if (!audioSettings.mute && sfxIntro){
    sfxIntro.currentTime = 0;
    sfxIntro.volume = clamp01(audioSettings.sfx / 100);
    sfxIntro.play().catch(()=>{});
  }

  setTimeout(() => {
    playMusic("menu");
  }, 120);

  setTimeout(() => {
    overlayIntro.style.display = "none";
    overlayMenu.style.display = "flex";
    transitionFX?.classList.remove("flash");
  }, 420);
}

if (overlayIntro){
  overlayIntro.addEventListener("pointerdown", playIntroTransition, { once:true });
  overlayIntro.addEventListener("touchstart", playIntroTransition, { passive:true, once:true });
}

/* =========================
   PERF MODE (FIXED)
========================= */
let PERF_MODE = "HIGH"; // HIGH | MED | LOW

function updatePerf(){
  const f = FXQuality.fps();
  if (f < 42) PERF_MODE = "LOW";
  else if (f < 55) PERF_MODE = "MED";
  else PERF_MODE = "HIGH";
}

/* =========================
   PLAYER / WORLD STATE
========================= */
const player = { x:100, y:BASE_H/2, width:36, height:32, vy:0 };
const BASE_PLAYER_W = 36;
const BASE_PLAYER_H = 32;

const GRAVITY = 0.42;
const THRUST  = -0.8;
let jetOn = false;

let obstacles = [];
let coins     = [];
let bullets   = [];

let obstacleSpeed = 3.8;
let lastSpawn = 0;
let score = 0;
let bestScore = Number(localStorage.getItem("bestScore") || 0);
let coinsCollected = 0;
let pendingCoins   = 0;

let newRecordThisRun = false;
let coinsBank = Number(localStorage.getItem("coinsBank") || 0);

/* === SKIN SYSTEM === */
const SKIN_CATEGORIES = {
  common:    { label: "COMMON" },
  rare:      { label: "RARE" },
  epic:      { label: "EPIC" },
  legendary: { label: "LEGENDARY" }
};

const SKINS = {
  moony: {
    name: "Moony",
    category: "common",
    price: 0,
    body: ["#f6f0dd", "#e8dcc0"],
    eye: "#5a4a32",
    jet: [
      "rgba(245,235,210,0.95)",
      "rgba(225,215,185,0.75)",
      "rgba(200,190,160,0.12)"
    ],
    aura: [
      "rgba(255,245,220,0.22)",
      "rgba(215,200,165,0.10)"
    ],
    trail: { color: "rgba(235,230,200,0.95)", glow: 6, size: 1.8, shape: "round" }
  },

  solar: {
    name: "Solar",
    category: "rare",
    price: 900,
    body: ["#ffeb3b", "#f57f17"],
    eye: "#263238",
    jet: ["rgba(255,255,255,0.9)", "#ffcc80", "rgba(255,87,34,0.1)"],
    aura: ["rgba(129,212,250,0.35)", "rgba(41,182,246,0.18)"],
    trail: { color: "rgba(255,200,80,0.95)", glow: 10, size: 1.9, shape: "spark" }
  },

  forest: {
    name: "Forest",
    category: "common",
    price: 350,
    body: ["#8bc34a", "#558b2f"],
    eye: "#1b5e20",
    jet: ["rgba(255,255,255,0.9)", "#dcedc8", "rgba(139,195,74,0.15)"],
    aura: ["rgba(165,214,167,0.35)", "rgba(102,187,106,0.18)"],
    trail: { color: "rgba(150,200,120,0.85)", glow: 6, size: 1.6, shape: "round" }
  },

  arctic: {
    name: "Arctic",
    category: "rare",
    price: 900,
    body: ["#bbdefb", "#1e88e5"],
    eye: "#0d47a1",
    jet: ["rgba(255,255,255,0.9)", "#e3f2fd", "rgba(33,150,243,0.15)"],
    aura: ["rgba(144,202,249,0.35)", "rgba(66,165,245,0.2)"],
    trail: { color: "rgba(210,235,255,0.95)", glow: 8, size: 1.5, shape: "snow" }
  },

  inferno: {
    name: "Inferno",
    category: "epic",
    price: 1600,
    body: ["#ff8a65", "#d84315"],
    eye: "#4e342e",
    jet: ["rgba(255,255,255,0.9)", "#ffccbc", "rgba(255,112,67,0.15)"],
    aura: ["rgba(255,171,145,0.4)", "rgba(239,83,80,0.2)"],
    trail: { color: "rgba(255,120,60,0.95)", glow: 14, size: 2.0, shape: "ember" }
  },

  neon: {
    name: "Neon",
    category: "epic",
    price: 2200,
    body: ["#00e5ff", "#00b8d4"],
    eye: "#004d40",
    jet: ["rgba(255,255,255,0.9)", "#84ffff", "rgba(38,166,154,0.18)"],
    aura: ["rgba(24,255,255,0.38)", "rgba(100,255,218,0.22)"],
    trail: { color: "rgba(0,255,255,0.95)", glow: 12, size: 1.6, shape: "line" }
  },

  voidwalker: {
    name: "Voidwalker",
    category: "legendary",
    price: 3500,
    body: ["#6a1b9a", "#311b92"],
    eye: "#000000",
    jet: ["rgba(255,255,255,0.9)", "#ce93d8", "rgba(103,58,183,0.18)"],
    aura: ["rgba(171,71,188,0.4)", "rgba(94,53,177,0.22)"],
    trail: { color: "rgba(160,120,220,0.8)", glow: 16, size: 2.2, shape: "void" }
  }
};

/* =========================
   SAVE / CURRENT SKIN (SAFE)
========================= */
let ownedSkins = (() => {
  try {
    const v = JSON.parse(localStorage.getItem("ownedSkins") || '["moony"]');
    return Array.isArray(v) ? v : ["moony"];
  } catch (e) {
    return ["moony"];
  }
})();

let currentSkin = (() => {
  const v = localStorage.getItem("currentSkin") || "moony";
  return (v && SKINS[v]) ? v : "moony";
})();

// s√©curit√© absolue
if (!ownedSkins.includes("moony")) ownedSkins.push("moony");
ownedSkins = ownedSkins.filter(id => !!SKINS[id]); // enl√®ve skins inexistants

if (!SKINS[currentSkin]) currentSkin = "moony";

/* =========================
   OVERDRIVE / RUN STATE
========================= */
let overdriveActive = false;
let overdriveTimer  = 0;

const OVERDRIVE_DURATION_BASE = 3000;
let overdriveDuration = OVERDRIVE_DURATION_BASE;

const OVERDRIVE_THRESHOLD = 20;
let overdrive = 0; // charge actuelle

let dyingTimer = 0;
let dyingFromCircle = null;

let lastType = null;
let lastIntensity = 0;

// combo
let combo = 1;
let lastCoinTime = 0;

// FX collision
let particles = [];
let shake = 0;
let shockwave = null;
let bloom = null;
let deathOrigin = null; // {x,y}
let lastShakeX = 0;
let lastShakeY = 0;

/* =========================================================
   ENGINE v1.0 ‚Äî PHASES / RYTHME / SPAWN
   (API FROZEN ‚Äî AUCUN HACK RUNTIME)
========================================================= */

/* =========================
   PHASES & RYTHME GLOBAL
========================= */

// seuils score ‚Üí phase
const PHASE_LIMITS = [8000, 22000, 45000, 85000];

// param√®tres globaux par phase
const PACE_MULT = [1.0, 1.25, 1.55, 1.9, 2.3];
const SPAWN_MS  = [1120, 940, 780, 660, 560];
const MOVE_AMP  = [20, 48, 78, 105, 130];

/* =========================
   PHASE DETECTION
========================= */
function phase(score){
  if (score < PHASE_LIMITS[0]) return 0; // onboarding
  if (score < PHASE_LIMITS[1]) return 1; // flow
  if (score < PHASE_LIMITS[2]) return 2; // pression
  if (score < PHASE_LIMITS[3]) return 3; // chaos contr√¥l√©
  return 4;                              // endgame
}

/* =========================
   ACC√àS RAPIDES (SANS ALLOC)
========================= */
function paceMultiplier(score){
  return PACE_MULT[phase(score)];
}

function currentSpawnInterval(score){
  return SPAWN_MS[phase(score)];
}

function movingAmplitude(score){
  return MOVE_AMP[phase(score)];
}

/* =========================
   FREQUENCES OBSTACLES
========================= */
const FREQ = {
  0: { rotbar:0.08, circle:0.18, turret:0.00, mover:0.16, sweeper:0.06, gap:0.52, chicane:0.00, zig:0.00 },
  1: { rotbar:0.17, circle:0.18, turret:0.08, mover:0.20, sweeper:0.08, gap:0.23, chicane:0.04, zig:0.02 },
  2: { rotbar:0.21, circle:0.18, turret:0.13, mover:0.20, sweeper:0.09, gap:0.12, chicane:0.04, zig:0.03 },
  3: { rotbar:0.24, circle:0.18, turret:0.17, mover:0.20, sweeper:0.10, gap:0.07, chicane:0.03, zig:0.01 },
  4: { rotbar:0.26, circle:0.18, turret:0.20, mover:0.20, sweeper:0.10, gap:0.04, chicane:0.01, zig:0.01 }
};

function currentFreq(score){
  return FREQ[phase(score)];
}

/* =========================
   POIDS OBSTACLES (DENSIT√â)
========================= */
const OBSTACLE_WEIGHT = {
  gap:     0,
  circle:  1,
  mover:   1,
  sweeper: 1,
  turret:  2,
  rotbar:  2
};

/* =========================
   HELPERS G√âN√âRAUX
========================= */
function randomRange(a,b){
  return a + Math.random() * (b - a);
}

function clamp(v,a,b){
  return Math.max(a, Math.min(b, v));
}

/* =========================
   MONDE & CAMERA
========================= */
const WORLD_W = BASE_W;
const WORLD_H = BASE_H;

// distance de spawn anticip√© (API v1.0)
const SAFE_SPAWN_AHEAD = BASE_W * 1.3;

/* =========================
   FAR RIGHT CACHE (SPAWN SAFE)
========================= */
let farRightCache = 0;
let farRightFrame = -1;

function farRightX(){
  if (farRightFrame === frameCount) return farRightCache;

  let mx = -1e9;

  for (const ob of obstacles){
    let right;

    switch (ob.kind){
      case 'rotbar':
        right = ob.cx + ob.len;
        break;
      case 'circle':
        right = ob.x + ob.r;
        break;
      default:
        right = (ob.x || 0) + (ob.width || 0);
        break;
    }

    if (right > mx) mx = right;
  }

  farRightCache = mx + 60; // marge SAFE moteur
  farRightFrame = frameCount;
  return farRightCache;
}

/* =========================
   COLLISION ‚Äî AABB vs OBB
========================= */
function aabbVsOBB(ax,ay,aw,ah, cx,cy, halfW, halfH, angle){
  const c = Math.cos(angle);
  const s = Math.sin(angle);

  const dax = (ax + aw * 0.5) - cx;
  const day = (ay + ah * 0.5) - cy;

  const lx =  dax * c + day * s;
  const ly = -dax * s + day * c;

  const ex = Math.abs(aw * 0.5 * c) + Math.abs(ah * 0.5 * s);
  const ey = Math.abs(aw * 0.5 * s) + Math.abs(ah * 0.5 * c);

  const skin = 1.5;

  return (
    Math.abs(lx) <= (halfW - skin) + ex &&
    Math.abs(ly) <= (halfH - skin) + ey
  );
}

/* =========================
   COINS ‚Äî SPAWN ENGINE v1.0
========================= */
/*
  R√àGLE FONDAMENTALE :
  - aucun spawn li√© √† la visibilit√©
  - spawn TOUJOURS anticip√© (SAFE_SPAWN_AHEAD)
  - draw() ne fait QUE dessiner
*/

function pushCoinsAround(x, y, r, base, extra = 0){
  const n = base + extra;

  for (let i = 0; i < n; i++){
    const ang  = (Math.PI * 2 * i / n) + randomRange(-0.1, 0.1);
    const dist = r + randomRange(20, 34);

    coins.push({
      x: x + Math.cos(ang) * dist,
      y: y + Math.sin(ang) * dist,
      r: 7
    });
  }
}


/* =========================
   GAP
========================= */
function spawnGap(ph){
  const gapH = 120 + Math.random() * 60;

  const minY = 40;
  const maxY = WORLD_H - 40 - gapH;
  if (maxY <= minY) return;

  const gapY = minY + Math.random() * (maxY - minY);
  const w = 44;
  const x = WORLD_W + SPAWN_MARGIN_X;

  // s√©curit√© rotbar
  for (const ob of obstacles){
    if (ob.kind === "rotbar"){
      const right = ob.cx + ob.len;
      if (right > WORLD_W - 120 && right < WORLD_W + SPAWN_MARGIN_X + 200){
        return;
      }
    }
  }

  obstacles.push({ kind:"rect", x, y:0, width:w, height:gapY, type:"top" });
  obstacles.push({
    kind:"rect",
    x,
    y:gapY + gapH,
    width:w,
    height:WORLD_H - (gapY + gapH),
    type:"bottom"
  });

  const count = 4 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++){
    coins.push({
      x: x + 80 + i * 34,
      y: clamp(gapY + gapH * 0.5 + Math.sin(i) * gapH * 0.35, 30, WORLD_H - 30),
      r: 7
    });
  }
}


/* =========================
   CIRCLE
========================= */
function spawnCircle(ph){
  const r  = randomRange(42, 58);
  const cy = randomRange(70, WORLD_H - 70);
  const cx = WORLD_W + SPAWN_MARGIN_X;

  obstacles.push({
    kind:"circle",
    x:cx,
    y:cy,
    r,
    rot:0,
    t:Math.random() * Math.PI * 2
  });

  pushCoinsAround(cx, cy, r, 3, (ph >= 2) + (ph >= 3));
}

/* =========================
   MOVER
========================= */
function spawnMover(ph){
  const w = 42;
  const h = randomRange(90, 180);

  const baseY = Math.random() < 0.5 ? 0 : WORLD_H - h;
  const speed = randomRange(1.0, 1.9) * (1 + ph * 0.15);
  const x = WORLD_W + SPAWN_MARGIN_X;

  obstacles.push({
    kind:"movingRect",
    x,
    y:baseY,
    width:w,
    height:h,
    baseY,
    t:Math.random() * Math.PI * 2,
    amp:movingAmplitude(score),
    speed
  });

  coins.push({
    x:x + 90,
    y:clamp(baseY === 0 ? h + 50 : baseY - 50, 30, WORLD_H - 30),
    r:7
  });
}


/* =========================
   ROTBAR
========================= */
function spawnRotbar(ph){
  const now = renderTime;
  const minGapMs = (ph <= 1) ? 24000 : 19000;

  if (now - lastBarTime < minGapMs && Math.random() < 0.7) return;

  for (const ob of obstacles){
    if (ob.kind === "rotbar"){
      if (ob.cx + ob.len > WORLD_W - 120) return;
    }
  }

  lastBarTime = now;

  const len = randomRange(95, 140);
  const cx  = WORLD_W + SPAWN_MARGIN_X + 200;
  const cy  = randomRange(80, WORLD_H - 80);

  obstacles.push({
    kind: "rotbar",
    cx,
    cy,
    len,
    angle: Math.random() * Math.PI,
    speed: randomRange(0.019, 0.055) * (1 + ph * 0.25),
    half: 7
  });

  for (let i = 0; i < 3; i++){
    coins.push({
      x: cx + Math.cos(i - 1) * (len + 28),
      y: cy + Math.sin(i - 1) * (len + 28),
      r: 7
    });
  }
}



/* =========================
   SWEEPER
========================= */
function spawnSweeper(ph){
  const w = 32;
  const h = randomRange(110, 180);

  const x = WORLD_W + SPAWN_MARGIN_X;
  const y = randomRange(0, WORLD_H - h);

  obstacles.push({
    kind: "sweeper",
    x,
    y,
    width: w,
    height: h,
    vy: randomRange(1.2, 2.0) * (Math.random() < 0.5 ? 1 : -1) * (1 + ph * 0.18)
  });

  for (let i = 0; i < 3; i++){
    coins.push({
      x: x + 80 + i * 22,
      y: y + i * 14,
      r: 7
    });
  }
}


/* =========================
   TURRET
========================= */
function canPlaceTurret(){
  const limit = WORLD_W + OFF_X + 280;

  for(const ob of obstacles){
    const right = (ob.kind==='rotbar')
      ? ob.cx + ob.len
      : (ob.kind==='circle')
        ? ob.x + ob.r
        : (ob.x||0) + (ob.width||0);

    if (right > WORLD_W && right < limit){
      if (ob.kind==='movingRect' || ob.kind==='sweeper' || ob.kind==='rotbar'){
        return false;
      }
    }
  }
  return true;
}
/* =========================
   TURRET PARAMETERS (COMPATIBLE AVEC TON MOTEUR)
========================= */
function turretParams(ph){
  // ph est d√©j√† re√ßu depuis spawn(), pas besoin de recalculer le score
  const phase = ph || 0;

  return {
    // Noms de propri√©t√©s align√©s avec spawnTurret :
    bullet: 3.8 + (phase * 0.6),            // Ton code attend .bullet
    fireMs: Math.max(700, 2200 - (phase * 300)),
    reposition: Math.max(1200, 3500 - (phase * 400)), // Ton code attend .reposition
    spread: 30 + (phase * 5)                // Ton code attend .spread
  };
}
function spawnTurret(ph){
  if (ph === 0) return;

  const x = WORLD_W + SPAWN_MARGIN_X;
  const y = clamp(player.y + randomRange(-60,60), 60, WORLD_H - 60);
  const p = turretParams(ph);

  obstacles.push({
    kind:"turret",
    x, y,
    w:36, h:26,
    t:0,
    next:p.fireMs * 0.6,
    fireMs:p.fireMs,
    bulletSpeed:p.bullet,
    reTimer:p.reposition,
    reBase:p.reposition,
    spread:p.spread
  });

  for(let i=0;i<3;i++){
    coins.push({ x:x+70+i*22, y:y+(i-1)*14, r:7 });
  }
}


/* =========================
   BULLET
========================= */
function spawnBullet(tx, ty, speed){
  bullets.push({
    x: tx - 6,
    y: ty,
    r: 5,
    vx: -speed
  });
}

/* =========================
   DISPATCHER (FIT 16:9 SAFE)
========================= */
function spawn(){
  const now = renderTime;
  const ph  = phase(score);
  const minGap = 90 - ph * 8;
  const overlapTolerance = Math.max(140, 420 - ph * 70);

  if (farRightX() > WORLD_W + SPAWN_MARGIN_X + minGap){
    if (now - lastSpawnTime < overlapTolerance) return;
  }

  const freq = FREQ[ph];
  const entries = Object.entries(freq);

  let r = Math.random();
  let sum = 0;
  for (const [, p] of entries) sum += p;

  let pick = null;
  let acc  = 0;

  for (const [name, p] of entries){
    acc += p;
    if (r * sum <= acc){
      pick = name;
      break;
    }
  }

  if (pick === lastType && Math.random() < 0.6){
    pick = "gap";
  }
  lastType = pick;

  const intensity = OBSTACLE_WEIGHT[pick] || 0;

  if (typeof lastIntensity !== "undefined"){
    if (lastIntensity >= 2 && intensity >= 2){
      pick = "gap";
    }
    if ((intensity - lastIntensity) >= 2 && Math.random() < 0.6){
      pick = "circle";
    }
  }
  lastIntensity = intensity;

  lastSpawnTime = now;

  switch (pick){
    case "gap":     spawnGap(ph);     break;
    case "circle":  spawnCircle(ph);  break;
    case "mover":   spawnMover(ph);   break;
    case "rotbar":  spawnRotbar(ph);  break;
    case "sweeper": spawnSweeper(ph); break;
    case "turret":  spawnTurret(ph);  break;
    default:        spawnGap(ph);
  }
}






// death / FX
function startDeath(fromCircle, circle, typeTag=null){
  if (gameState === 'dying' || gameState === 'gameover') return;

  gameState = 'dying';
  dyingTimer = 520;
  gameOverTriggered = false;

  // ‚úÖ origine FIXE (ne suivra plus les modifs de player.x/y/scale pendant dying)
  const px = player.x + player.width/2;
  const py = player.y + player.height/2;
  deathOrigin = { x:px, y:py };

  // ‚úÖ SAFE : si circle est null, on √©vite le crash
  dyingFromCircle = (fromCircle && circle) ? { x: circle.x, y: circle.y } : null;

  // --- AUDIO MORT ---
  if (typeof musicGame !== "undefined" && musicGame) {
    fadeAudio(musicGame, 0.2, 220);
  }
  if (typeof sfxDeath !== "undefined" && sfxDeath) {
    try{
      sfxDeath.currentTime = 0;
      sfxDeath.volume = audioSettings.mute ? 0 : clamp01(audioSettings.sfx / 100);
      sfxDeath.play().catch(()=>{});
    }catch(e){}
  }

  // --- PARTICULES ---
  particles.length = 0;
  const n = 26;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = fromCircle ? randomRange(1.2,2.1) : randomRange(1.8,3.2);
    const life = randomRange(420,700);
    const col = typeTag==='bullet'
      ? 'rgba(255,255,255,0.9)'
      : (fromCircle ? 'rgba(255,128,96,0.9)' : 'rgba(255,200,80,0.9)');

    particles.push({
      x:px,y:py,
      vx:Math.cos(ang)*spd,
      vy:Math.sin(ang)*spd,
      life,age:0,col,
      sz:randomRange(2,4)
    });
  }

  // --- SHOCKWAVE / BLOOM ---
  shockwave = { x:px, y:py, r:0, alpha:1, max:180 };
  bloom = { x:px, y:py, a:0.6 };
}
// ================================
// DAILY ADS SYSTEM (SAFE + CLEAN)
// ================================

const ADS_MAX_PER_DAY    = 5;
const AD_REWARD_COINS   = 49;

// üîí √©tat journalier
let adsDate             = "";
let adsWatchedToday     = 0;
let isWatchingDailyAd   = false;

// ================================
// DATE UTILS (YYYY-MM-DD, LOCAL SAFE)
// ================================
function getTodayKey(){
  const d = new Date();
  return (
    d.getFullYear() + "-" +
    String(d.getMonth()+1).padStart(2,"0") + "-" +
    String(d.getDate()).padStart(2,"0")
  );
}

// ================================
// INIT / RESET JOURNALIER
// ================================
function initDailyAds(){
  const today = getTodayKey();

  adsDate = localStorage.getItem("adsDate");
  adsWatchedToday = Number(localStorage.getItem("adsCount") || 0);

  if (adsDate !== today){
    adsDate = today;
    adsWatchedToday = 0;
    localStorage.setItem("adsDate", today);
    localStorage.setItem("adsCount", "0");
  }
}

// ================================
// SAVE
// ================================
function saveDailyAds(){
  localStorage.setItem("adsCount", String(adsWatchedToday));
}

// ================================
// HELPERS
// ================================
function adsLeftToday(){
  return Math.max(0, ADS_MAX_PER_DAY - adsWatchedToday);
}

function canWatchAd(){
  return adsLeftToday() > 0 && !isWatchingDailyAd;
}

// ================================
// WATCH AD FOR COINS
// ================================
function watchAdForCoins(source = "menu"){
  if (!canWatchAd()) return;

  isWatchingDailyAd = true;
  updateAdButtonState(source, "loading");

  showRewardedAd(
    () => {
      // ‚úÖ SUCC√àS
      coinsBank += AD_REWARD_COINS;
      adsWatchedToday++;

      saveDailyAds();
      localStorage.setItem("coinsBank", String(coinsBank));

      updateCoinsUI();
      updateDailyAdsUI();
      updateAdButtonState(source, "ready");
      closeAdOffer(source);

      isWatchingDailyAd = false;
    },
    () => {
      // ‚ùå √âCHEC
      isWatchingDailyAd = false;
      updateAdButtonState(source, "ready");
      console.warn("[ADS] rewarded ad failed");
    }
  );
}

// ================================
// UI ‚Äî COINS
// ================================
function updateCoinsUI(){
  safeText(document.getElementById("menuCoins"), coinsBank.toLocaleString());
  safeText(document.getElementById("shopCoins"), coinsBank.toLocaleString());
}

// ================================
// UI ‚Äî BUTTON STATE
// ================================
function updateAdButtonState(source, state){
  const btn = document.querySelector(
    source === "shop" ? "#shopAdBtn" : "#menuAdBtn"
  );
  if (!btn) return;

  if (state === "loading"){
    btn.textContent = "Loading ad...";
    btn.disabled = true;
    return;
  }

  if (!canWatchAd()){
    btn.textContent = "No ads left today";
    btn.disabled = true;
    return;
  }

  btn.textContent = `Watch ad +${AD_REWARD_COINS} coins`;
  btn.disabled = false;
}

// ================================
// UI ‚Äî DAILY COUNTER
// ================================
function updateDailyAdsUI(){
  const left = adsLeftToday();

  const menuCount = document.getElementById("menuAdCount");
  if (menuCount){
    menuCount.textContent = `${left} / ${ADS_MAX_PER_DAY} ads left`;
  }

  const shopCount = document.getElementById("shopAdCount");
  if (shopCount){
    shopCount.textContent = `${left} / ${ADS_MAX_PER_DAY} ads left today`;
  }

  ["menuAdBtn", "shopAdBtn"].forEach(id => {
    const b = document.getElementById(id);
    if (!b) return;

    if (left <= 0){
      b.disabled = true;
      b.textContent = "No ads left today";
    }
  });
}

// ================================
// MENU AD POPUP (SAFE)
// ================================
let menuAdTimeout   = null;
let menuAdMenuCount = 0;

function showMenuAdPopup(){
  if (uiState !== "menu") return;
  if (gameState !== "menu") return;
  if (!canWatchAd()) return;

  // üëâ 1 fois sur 2 passages menu
  menuAdMenuCount++;
  if (menuAdMenuCount % 2 !== 0) return;

  const el = document.getElementById("menuAdPopup");
  if (!el) return;

  clearTimeout(menuAdTimeout);

  el.style.top = "14px";
  el.style.opacity = "1";

  menuAdTimeout = setTimeout(hideMenuAdPopup, 4000);
}

function hideMenuAdPopup(){
  const el = document.getElementById("menuAdPopup");
  if (!el) return;

  el.style.opacity = "0";
  el.style.top = "-80px";
}




// ================================
// CONTINUE POPUP (AD OFFER) ‚Äî API
// ================================
let canContinueThisRun = true;   // 1 fois par run
let isWatchingAd = false;

let continueTimeout = null;
let continueInterval = null;

function _getContinueEls(){
  return {
    popup: document.getElementById("continuePopup"),
    btn:   document.getElementById("continueAdBtn"),
    secs:  document.getElementById("continueSeconds"),
    timer: document.getElementById("continueTimer")
  };
}

function hideContinuePopup(){
  const { popup } = _getContinueEls();

  if (continueTimeout){
    clearTimeout(continueTimeout);
    continueTimeout = null;
  }
  if (continueInterval){
    clearInterval(continueInterval);
    continueInterval = null;
  }

  if (popup) popup.style.display = "none";
}
function showContinuePopup(durationSec = 2.5){
  const { popup, btn, secs, timer } = _getContinueEls();
  if (!popup || !btn || !secs || !timer) return;

  // s√©curit√© : uniquement en game over
  if (gameState !== "gameover") return;
  if (!canContinueThisRun) return;

  hideContinuePopup();

  popup.style.display = "flex";
  timer.style.display = "block";     // üî• MANQUANT
  timer.style.opacity = "0.7";       // üî• visibilit√©

  btn.disabled = false;
  btn.textContent = "Watch Ad & Continue";

  let timeLeft = durationSec;
  secs.textContent = timeLeft;

  continueInterval = setInterval(() => {
    timeLeft--;
    if (timeLeft < 0) timeLeft = 0;
    secs.textContent = timeLeft;

    if (timeLeft <= 0){
      hideContinuePopup();
    }
  }, 630);

  continueTimeout = setTimeout(() => {
    hideContinuePopup();
  }, durationSec * 630);
}


// ================================
// CLICK ‚Äî WATCH AD
// ================================
function handleContinueAd(){
  if (isWatchingAd) return;
  if (!canContinueThisRun) return;

  isWatchingAd = true;
  canContinueThisRun = false;

  const { btn } = _getContinueEls();
  if (!btn) return;

  btn.textContent = "Loading ad...";
  btn.disabled = true;

  // üéØ VRAIE PUB ICI
  showRewardedAd(
    () => {
      // ‚úÖ PUB COMPL√âT√âE ‚Üí REVIVE
      isWatchingAd = false;
      revivePlayerAfterAd();
    },
    () => {
      // ‚ùå PUB √âCHOU√âE / SKIP / NO FILL
      isWatchingAd = false;

      btn.textContent = "‚ö° Continue";
      btn.disabled = false;

      console.warn("revive ad failed");
    }
  );
}

// ================================
// REVIVE (FORCE SAFE)
// ================================
function revivePlayerAfterAd(){
  hideContinuePopup();

  // =====================
  // üßπ HIDE GAME OVER
  // =====================
  if (overlayGameOver){
    overlayGameOver.classList.remove("visible");
    overlayGameOver.style.display = "none";
    overlayGameOver.style.pointerEvents = "none";
    overlayGameOver.style.opacity = "0";
  }

  // =====================
  // üî• REVIVE STATE
  // =====================
  gameOverTriggered = false;
  gameState = "playing";
  gameRunning = true;

  // =====================
  // üéØ SAFE REPOSITION
  // =====================
  player.x  = 120;
player.y = BASE_H * 0.5;
  player.vy = 0;

  // =====================
  // üõ°Ô∏è INVINCIBILITY (SINGLE SOURCE)
  // =====================
  player.invincible = true;

  setTimeout(() => {
    player.invincible = false;
  }, 3500);

  // =====================
  // üßπ CLEAN DANGERS (IMPORTANT)
  // =====================
  obstacles = obstacles.filter(o => o.x > player.x + 550);
  bullets   = bullets.filter(b => b.x > player.x + 550);

  // =====================
  // ‚ú® RESET DEATH FX
  // =====================
  dyingTimer = 0;
  particles.length = 0;
  shockwave = null;
  bloom = null;
  shake = 0;

  // =====================
  // üéµ AUDIO
  // =====================
  if (musicGame && !audioSettings.mute){
    musicGame.play().catch(()=>{});
  }

  // =====================
  // ‚ñ∂Ô∏è LOOP
  // =====================
  resumeLoop();
}


// ================================
// GAME OVER (COMPLET + SAVE DEDANS)
// ================================
function handleGameOver(){
  if (gameOverTriggered) return;
  gameOverTriggered = true;

  // reset overdrive
  overdriveActive = false;
  overdriveTimer = 0;
  overdrive = 0;
  document.body.classList.remove("overdriveActive");
  if (UI?.overFill) UI.overFill.style.height = "0%";
  if (UI?.overCount) UI.overCount.textContent = "0";

  // audio
  stopMusic(musicGame);
  currentMusic = "none";

  // state
  gameState = "gameover";
pauseLoop();

  const s = Math.floor(score);

  // new record
  if (s > bestScore){
    bestScore = s;
    const nr = document.getElementById("newRecord");
    if (nr){
      nr.style.display = "block";
      requestAnimationFrame(() => {
        nr.style.opacity = "1";
        nr.style.transform = "scale(1.2)";
        setTimeout(() => nr.style.transform = "scale(1)", 300);
      });
    }
  }

  // texts
  safeText(finalScoreEl, s.toLocaleString());
  safeText(finalBestEl, bestScore.toLocaleString());
  safeText(finalCoinsEl, coinsCollected.toLocaleString());

  // overlay gameover
  if (overlayGameOver){
    overlayGameOver.classList.add("visible");
    overlayGameOver.style.display = "flex";
    overlayGameOver.style.visibility = "visible";
    overlayGameOver.style.opacity = "1";
    overlayGameOver.style.pointerEvents = "auto";
  }

  // ‚úÖ SAVE (ICI ET PAS AILLEURS)
  coinsBank += coinsCollected;
  localStorage.setItem("bestScore", String(bestScore));
  localStorage.setItem("coinsBank", String(coinsBank));

  safeText(document.getElementById("menuBest"), bestScore.toLocaleString());
  safeText(document.getElementById("menuCoins"), coinsBank.toLocaleString());

  deathOrigin = null;

  // popup ad apr√®s d√©lai
  setTimeout(() => {
    showContinuePopup(4);
  }, 1200);
}
// ================================
// BIND (UNE SEULE FOIS)
// ================================
window.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("continueAdBtn");
  if (btn){
    btn.addEventListener("click", handleContinueAd);
  }
});
function updateRoulette(list){
  const rect = list.getBoundingClientRect();
  const center = rect.left + rect.width / 2;

  list.querySelectorAll(".skinCard").forEach(card=>{
    const r = card.getBoundingClientRect();
    const cardCenter = r.left + r.width / 2;
    const d = (cardCenter - center) / rect.width;

    const scale = 1 - Math.abs(d) * 0.4;
    const rotateY = d * 28;
    const opacity = 1 - Math.abs(d) * 0.6;

    card.style.transform =
      `scale(${scale}) rotateY(${rotateY}deg)`;
    card.style.opacity = opacity;
  });
}
function initSkinRoulette(){
  document.querySelectorAll(".skinList").forEach(list=>{
    const onScroll = ()=>{
      requestAnimationFrame(()=>updateRoulette(list));
    };
    list.addEventListener("scroll", onScroll, { passive:true });
    updateRoulette(list);
  });
}
// ================= PARTICLES GLOBALS (OBLIGATOIRES) =================
const PARTICLE_POOL_SIZE = FXQuality?.isMobile ? 80 : 160;

const particlePool = [];
const playerParticles = [];

let poolIndex = 0;
let lastTrailSpawn = 0;
for (let i = 0; i < PARTICLE_POOL_SIZE; i++){
  particlePool.push({
    active:false,
    x:0, y:0,
    vx:0, vy:0,
    life:0, lifeMax:0,
    size:0, glow:0,
    seed:0,
    shape:"default",
    color:"#fff",
    jx:null, js:null
  });
}
/* =========================
   SPAWN PLAYER TRAIL (POOL SAFE / FINAL)
========================= */
function spawnPlayerTrail(x, y, skin){
  const now = renderTime || performance.now();

  // üîí throttle CRITIQUE (mobile / FX heavy)
  const delay = FXQuality.isMobile ? 24 : 16;
  if (now - lastTrailSpawn < delay) return;
  lastTrailSpawn = now;

  // üîí pool circulaire (AUCUNE ALLOC)
  const p = particlePool[poolIndex];
  poolIndex = (poolIndex + 1) % PARTICLE_POOL_SIZE;

  // ===== RESET COMPLET =====
  p.active  = true;
  p.x = x;
  p.y = y;

  p.vx = -1.4 - Math.random() * 0.6;
  p.vy = (Math.random() - 0.5) * 0.6;

  p.life    = 26;
  p.lifeMax = 26;

  p.seed = Math.random() * 999;
  p.jx = null;
  p.js = null;

  p.size = overdriveActive ? 2.6 : 3.6;
  p.glow = overdriveActive ? 8 : 14;

  p.shape = "default";
  p.color = "rgba(230,240,255,0.9)";

  // ===== SKIN VARIANTS =====
  switch (skin){
    case "solar":
      p.shape = "solar";
      p.color = "rgba(255,210,90,1)";
      p.glow  = overdriveActive ? 10 : 18;
      break;

    case "neon":
      p.shape = "line";
      p.color = "rgba(120,220,255,1)";
      p.glow  = 12;
      break;

    case "inferno":
      p.shape = "ember";
      p.color = "rgba(255,120,40,1)";
      p.glow  = 16;
      break;

    case "arctic":
      p.shape = "snow";
      p.color = "rgba(220,245,255,1)";
      p.glow  = 6;
      break;

    case "forest":
      p.shape = "leaf";
      p.color = "rgba(120,200,120,1)";
      p.glow  = 6;
      break;

    case "voidwalker":
      p.shape = "void";
      p.color = "rgba(140,110,220,1)";
      p.glow  = 14;
      break;
  }

  // ===== REGISTER (SANS DUPLICAT) =====
  if (!p._inList){
    p._inList = true;
    playerParticles.push(p);
  }
}


// ================= CAMERA SHAKE (GLOBAL SAFE) =================
let shakeX = 0, shakeY = 0;
let shakeTime = 0, shakePower = 0;

function triggerShake(power = 6, duration = 120){
  shakePower = Math.max(shakePower, power);
  shakeTime = duration;
}

function updateShake(delta){
  if (shakeTime > 0){
    const prev = shakeTime;
    shakeTime -= delta;

    const p = shakePower * (shakeTime / Math.max(1, prev));
    const nx = (Math.random() * 2 - 1) * p;
    const ny = (Math.random() * 2 - 1) * p;

    shakeX = shakeX * 0.6 + nx * 0.4;
    shakeY = (shakeY * 0.6 + ny * 0.4) * 0.75;

    if (shakeTime <= 0){
      shakeX = 0;
      shakeY = 0;
      shakePower = 0;
    }
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}

/* =========================
   UTILS
========================= */
function aabbVsRect(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function isOptionsOpen(){
  return optionsPanelEl && optionsPanelEl.style.display === "flex";
}



let _lastLagLog = 0;

function debugLag(delta){
  const now = performance.now();
  if (delta > 22 && now - _lastLagLog > 1200){
    _lastLagLog = now;
    console.warn(
      "LAG",
      delta.toFixed(1),
      "score:", Math.floor(score),
      "obs:", obstacles.length,
      "fx:", particles.length
    );
  }
}

let _fxGC = 0;

function fxGarbageCollect(){
  _fxGC++;
  if (_fxGC < 600) return; // ~10s
  _fxGC = 0;

  if (_arcPathCache.size > 64) _arcPathCache.clear();
  if (_rectPathCache.size > 64) _rectPathCache.clear();

  for (const k in _obFX){
    if (_obFX[k].size > 64) _obFX[k].clear();
  }
}

/* =========================
   UPDATE (CLEAN / SAFE)
========================= */
function update(delta, ts){

  // ---------- PERF / FX ----------
  updateFXCalm(delta);
  updateShake(delta);

  // temps moteur unique
  const now = renderTime;

  // heavy FX skip flag (si tu l'utilises ailleurs)
  skipHeavyFX = (delta > 24);

  // expression
  const target = jetOn ? 1 : 0;
  moonyExpr += (target - moonyExpr) * 0.08;

  // ---------- OPTIONS ----------
  if (isOptionsOpen()){
    jetOn = false;
    player.vy = 0;
    return;
  }

  // ---------- DYING ----------
  if (gameState === "dying"){

    // particles (reverse loop ok)
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02;
      p.age += delta;
      if (p.age >= p.life) particles.splice(i, 1);
    }

    // shockwave
    if (shockwave){
      shockwave.r += 6;
      shockwave.alpha *= 0.95;
      if (shockwave.r > (shockwave.max || 180) || shockwave.alpha < 0.02){
        shockwave = null;
      }
    }

    // bloom
    if (bloom){
      bloom.a *= 0.92;
      if (bloom.a < 0.02) bloom = null;
    }

    // suction circle
    if (dyingFromCircle){
      const cx = dyingFromCircle.x;
      const cy = dyingFromCircle.y;
      const pcx = player.x + player.width  * 0.5;
      const pcy = player.y + player.height * 0.5;

      player.x += (cx - pcx) * 0.06;
      player.y += (cy - pcy) * 0.06;

      player.width  *= 0.992;
      player.height *= 0.992;
    }

    dyingTimer -= delta;
    if (dyingTimer <= 0) handleGameOver();
    return;
  }

  if (gameState !== "playing") return;

  // ---------- OVERDRIVE ----------
  if (overdriveActive){
    overdriveTimer -= Math.min(delta, 18);

    const pct = Math.max(0, overdriveTimer / overdriveDuration);
    const pctInt = (pct * 100) | 0;

    if (pctInt !== lastOverdrivePct){
      lastOverdrivePct = pctInt;
      safeStyle(UI.overFill, "height", pctInt + "%");
    }

    if (pct < 0.35) document.body.classList.add("overdriveEnding");
    if (overdriveTimer <= 0) deactivateOverdrive();
  }

  // ---------- PLAYER ----------
  player.vy += (jetOn ? THRUST : GRAVITY);
  player.vy = clamp(player.vy, -8, 8);
  player.y  += player.vy;

  const SAFE_TOP    = OFF_Y;
  const SAFE_BOTTOM = WORLD_H - OFF_Y - player.height;

  if (player.y < SAFE_TOP){
    player.y = SAFE_TOP;
    player.vy = 0;
  } else if (player.y > SAFE_BOTTOM){
    player.y = SAFE_BOTTOM;
    player.vy = 0;
  }

  // ---------- TRAIL ----------
  if ((jetOn || Math.abs(player.vy) > 0.25) && (now - lastTrailSpawn) > 40){
    spawnPlayerTrail(
      player.x + player.width  * 0.5,
      player.y + player.height * 0.65,
      currentSkin || "moony"
    );
    lastTrailSpawn = now;
  }

  // ---------- SPAWN ----------
  const sp = obstacleSpeed;
  bgScroll += 0.6;

  if ((now - lastSpawn) > currentSpawnInterval(score)){
    spawn();
    lastSpawn = now;
  }

  // ---------- OBSTACLES ----------
  const rx = player.x, ry = player.y, rw = player.width, rh = player.height;
  const cxp = rx + rw * 0.5, cyp = ry + rh * 0.5;
  const DESPAWN_X = -OFF_X - 80;

  for (let i = obstacles.length - 1; i >= 0; i--){
    const ob = obstacles[i];

    // move
    if (ob.kind === "rotbar"){
      ob.cx -= sp;
      ob.angle += ob.speed;
    } else {
      ob.x -= sp;
    }

    // movingRect
    if (ob.kind === "movingRect"){
      ob.t += ob.speed * 0.05;
      const range = ob.amp || movingAmplitude(score);
      const baseY = (ob.baseY != null) ? ob.baseY : OFF_Y;
      ob.y = clamp(baseY - Math.sin(ob.t) * range, SAFE_TOP, SAFE_BOTTOM);
    }

    // turret
    if (ob.kind === "turret"){
      ob.t += delta;

      ob.reTimer -= delta;
      if (ob.reTimer <= 0){
        ob.reTimer = ob.reBase;
        ob.y = clamp(
          player.y + randomRange(-ob.spread, ob.spread),
          SAFE_TOP + 20,
          SAFE_BOTTOM - 20
        );
      }

      ob.next -= delta;
      if (ob.next <= 0){
        ob.next = ob.fireMs;
        if (!ob.safeFirst) spawnBullet(ob.x, ob.y, ob.bulletSpeed);
        ob.safeFirst = false;
      }
    }

    // despawn
    const rightEdge =
      (ob.kind === "rotbar") ? (ob.cx + ob.len) :
      (ob.kind === "circle") ? (ob.x + ob.r) :
      (ob.kind === "turret") ? (ob.x + (ob.w || 0)) :
                               (ob.x + (ob.width || 0));

    if (rightEdge < DESPAWN_X){
      obstacles.splice(i, 1);
      continue;
    }

    // collisions
    if (!overdriveActive && !player.invincible){
      const ox = (ob.kind === "rotbar") ? ob.cx : ob.x;

      if (Math.abs(ox - cxp) <= 180){

        if (
          (ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "sweeper") &&
          aabbVsRect(rx, ry, rw, rh, ob.x, ob.y, ob.width, ob.height)
        ) return startDeath(false, null, "rect");

        if (ob.kind === "circle"){
          const dx = cxp - ob.x, dy = cyp - ob.y;
          const rr = (ob.r * 0.9) + (ob.pulse || 0);
          if (dx*dx + dy*dy < rr*rr){
            return startDeath(true, ob, "circle");
          }
        }

        if (ob.kind === "rotbar"){
          if (aabbVsOBB(rx, ry, rw, rh, ob.cx, ob.cy, (ob.half || 7), ob.len, ob.angle)){
            return startDeath(false, null, "bar");
          }
        }

        if (ob.kind === "turret"){
          if (aabbVsRect(rx, ry, rw, rh, ob.x - 2, ob.y - 2, (ob.w || 0) + 4, (ob.h || 0) + 4)){
            return startDeath(false, null, "turret");
          }
        }
      }
    }
  }

  // ---------- BULLETS ----------
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx - (overdriveActive ? 1 : 0);

    if (b.x + b.r < -OFF_X - 40){
      bullets.splice(i, 1);
      continue;
    }

    if (!overdriveActive){
      const cx = clamp(b.x, rx, rx + rw);
      const cy = clamp(b.y, ry, ry + rh);
      const dx = b.x - cx, dy = b.y - cy;
      if (dx*dx + dy*dy <= b.r*b.r){
        return startDeath(false, null, "bullet");
      }
    }
  }

  // ---------- COINS ----------
  for (let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= sp;

    if (c.x + c.r < -OFF_X - 40){
      coins.splice(i, 1);
      continue;
    }

    const cx = clamp(c.x, rx, rx + rw);
    const cy = clamp(c.y, ry, ry + rh);
    const dx = c.x - cx, dy = c.y - cy;

    if (dx*dx + dy*dy <= c.r*c.r){
      coins.splice(i, 1);

      coinsCollected++;
      combo = ((now - lastCoinTime) < 1600) ? (combo + 1) : 1;
      lastCoinTime = now;

      addOverdrive(1);

      const base = overdriveActive ? 400 : 200;
      score += base + Math.floor(base * 0.1 * Math.max(0, combo - 1));
    }
  }

  // ---------- SCORE + UI ----------
  score += delta * 0.24 * paceMultiplier(score) * (overdriveActive ? 2 : 1);

  if ((frameCount & 3) === 0){
    if (UI.score) UI.score.textContent = (Math.floor(score) | 0);
    if (UI.coins) UI.coins.textContent = coinsCollected;
    if (UI.combo) UI.combo.textContent = combo;
  }

  // ---------- DIFFICULTY ----------
  obstacleSpeed = 3.8 + Math.pow(score / 8000, 0.9);

  // ---------- GC ----------
  fxGarbageCollect();
}




// =========================
// DEATH ORIGIN (SAFE)
// =========================
function getDeathXY(){
  if (deathOrigin) return deathOrigin;
  return {
    x: player.x + player.width  * 0.5,
    y: player.y + player.height * 0.5
  };
}


// =========================
// BACKGROUND (CLEAN / SAFE)
// =========================
// - pas de bgCanvas
// - createPattern repeat-x
// - robuste avec shake / zoom / resize

let bgImg      = new Image();
let bgPattern  = null;
let bgReady    = false;

// d√©cor plus lointain (<1)
const BG_SCALE = 0.53;

bgImg.src = "assets/bg_gd_blue.png";

bgImg.onload = () => {
  bgReady = true;
  bgPattern = null; // recr√©√© au draw (ctx s√ªr)
};

bgImg.onerror = () => {
  console.error("BG image missing:", bgImg.src);
  bgReady = false;
  bgPattern = null;
};

/* =========================
   BACKGROUND DRAW (SAFE & FULLSCREEN & OPTIMIZED)
========================= */
function drawBG(scroll){
  // S√©curit√© si contexte ou image pas pr√™ts
  if (!bgReady || !bgImg || !ctx) return;

  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  // 1. Fond couleur unie (Fallback) - OPTIMIS√â
  ctx.fillStyle = "#0b2148";
  // On r√©duit les marges de -2000 √† -100 pour gagner en performance
  ctx.fillRect(-100, -100, BASE_W + 200, BASE_H + 200);

  // 2. Cr√©ation du pattern si n√©cessaire
  if (!bgPattern){
    try {
      bgPattern = ctx.createPattern(bgImg, "repeat-x");
    } catch(e){
      bgPattern = null;
    }
    if (!bgPattern) return;
  }

  // 3. Calcul du d√©filement (Parallax)
  const PAD = 400; // Marge n√©cessaire pour le tremblement (shake)
  const w   = bgImg.width;
  
  // Application du BG_SCALE pour l'effet de profondeur
  const x = -((scroll || 0) * BG_SCALE % w);

  ctx.save();
  ctx.translate(x - PAD, -PAD);
  ctx.fillStyle = bgPattern;

  // 4. Dessin du pattern - OPTIMIS√â
  // On enl√®ve les +2000 inutiles
  ctx.fillRect(
    0,
    0,
    BASE_W + PAD * 2 + w + 200,
    BASE_H + PAD * 2 + 200
  );

  ctx.restore();
}
/* =========================
   PLAYER PARTICLES ‚Äî CLEAN / SAFE
   - pas de doublon
   - pas d‚Äô√©tat global inutile
   - cache ma√Ætris√©
========================= */

// ===== STATE =====
let lastJetSpawn = 0;
let fxTime = 0;

// ===== SOLAR GRADIENT CACHE (BORNE) =====
const solarGradCache = new Map(); // key -> CanvasGradient
const SOLAR_CACHE_MAX = 36;

function getSolarGradient(ctx, r, lifeRatio){
  const q = Math.max(2, (r * 2) | 0); // quantize stable
  const tier = lifeRatio > 0.6 ? 1 : lifeRatio > 0.3 ? 2 : 3;
  const key = q + "|" + tier;

  let g = solarGradCache.get(key);
  if (g) return g;

  const R = q * 0.5;
  g = ctx.createRadialGradient(0, 0, 0, 0, 0, R * 3.2);

  const mult = tier === 1 ? 1 : tier === 2 ? 0.75 : 0.55;
  g.addColorStop(0.0, `rgba(255,255,220,${0.55 * mult})`);
  g.addColorStop(0.25,`rgba(255,210,90,${0.45 * mult})`);
  g.addColorStop(0.55,`rgba(255,140,40,${0.22 * mult})`);
  g.addColorStop(1.0, "rgba(255,120,20,0)");

  if (solarGradCache.size >= SOLAR_CACHE_MAX) solarGradCache.clear();
  solarGradCache.set(key, g);
  return g;
}

/* =========================
   DRAW PLAYER PARTICLES
========================= */
/* =========================
   DRAW PLAYER PARTICLES (FINAL FIX)
========================= */
function drawPlayerParticles(ctx){
  const arr = playerParticles;
  if (!arr.length) return;

  ctx.save();

  const allowGlow = (fps > 48 && fxCalm > 0.01);

  for (let i = arr.length - 1; i >= 0; i--){
    const p = arr[i];

    // ===== UPDATE =====
    p.x += p.vx;
    p.y += p.vy;
    p.life--;

    if (p.life <= 0){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    const lifeRatio = p.life / p.lifeMax;
    if (lifeRatio <= 0.02){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    ctx.globalAlpha = lifeRatio;

    if (allowGlow && p.glow > 0){
      ctx.shadowColor = p.color;
      ctx.shadowBlur  = p.glow * fxCalm;
    } else {
      ctx.shadowBlur = 0;
    }

    const x = p.x, y = p.y, s = p.size;

    switch (p.shape){

      // ===== DEFAULT =====
      default:{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;

        const r = s * (0.8 + lifeRatio * 0.6);
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== LEAF =====
      case "leaf":{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;

        ctx.beginPath();
        ctx.ellipse(
          x, y,
          s * 1.1,
          s * 0.6,
          p.life * 0.15,
          0, Math.PI * 2
        );
        ctx.fill();
      } break;

      // ===== SOLAR =====
      case "solar":{
        ctx.globalCompositeOperation = "lighter";
        const rr = s * (0.9 + lifeRatio * 0.9);

        ctx.save();
        ctx.translate(x, y);

        ctx.fillStyle = getSolarGradient(ctx, rr, lifeRatio);
        ctx.beginPath();
        ctx.arc(0, 0, rr * 3.1, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(0, 0, rr, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== SNOW =====
      case "snow":{
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1;

        const ss = s * 1.4 * lifeRatio;
        ctx.beginPath();
        ctx.moveTo(x - ss, y);
        ctx.lineTo(x + ss, y);
        ctx.moveTo(x, y - ss);
        ctx.lineTo(x, y + ss);
        ctx.stroke();
      } break;

      // ===== EMBER =====
      case "ember":{
        if (p.jx == null){
          p.jx = (Math.random() - 0.5) * 1.2;
          p.js = 0.5 + Math.random() * 0.6;
        }

        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;

        ctx.beginPath();
        ctx.arc(
          x + p.jx,
          y - (1 - lifeRatio) * 2,
          s * p.js,
          0, Math.PI * 2
        );
        ctx.fill();
      } break;

      // ===== LINE =====
      case "line":{
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1.2;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - p.vx * 2, y - p.vy * 2);
        ctx.stroke();

        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== VOID =====
      case "void":{
        ctx.globalCompositeOperation = "lighter";

        ctx.fillStyle = "rgba(120,90,180,0.75)";
        ctx.beginPath();
        ctx.arc(x, y, s * (0.9 + lifeRatio), 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(15,8,25,0.9)";
        ctx.beginPath();
        ctx.arc(x, y, s * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = "source-over";
      } break;
    }
  }

  ctx.restore();
}








/* =========================
   FACE DISPATCH (SINGLE SOURCE)
========================= */
const FACE_FN = {
  moony:      drawMoonyFace,
  solar:      drawSolarFace,
  forest:     drawForestFace,
  arctic:     drawArcticFace,
  neon:       drawNeonFace,
  inferno:    drawInfernoFace,
  voidwalker: drawVoidFace
};

function getFaceFn(skinId){
  return FACE_FN[skinId] || drawMoonyFace;
}

/* =========================
   PLAYER ‚Äî RENDER (CLEAN / ORDER SAFE)
   - FX back
   - FACE (DEVANT)
   - FX front optionnel
========================= */



function drawPlayer(){
  const bx = player.x;
  const by = player.y;
  const bw = player.width;
  const bh = player.height;
  const vy = player.vy || 0;

  const skinId = currentSkin || "moony";
  const fxBack = SKIN_FX_BACK[skinId];
  const faceFn = getFaceFn(skinId);

  const VISUAL_SCALE = 1.42;

  ctx.save();

  // invincibility alpha
  if (player.invincible){
    ctx.globalAlpha = 0.7 + Math.sin(renderTime * 0.02) * 0.15;
  }

  // ===== TRANSFORM =====
  ctx.translate(bx + bw * 0.5, by + bh * 0.5);
  ctx.scale(VISUAL_SCALE, VISUAL_SCALE);

  const tilt = clamp(-vy * 0.04, -0.35, 0.35);
  ctx.rotate(tilt);
  ctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  // ===== SHIELD =====
  if (player.invincible){
    ctx.save();
    ctx.globalCompositeOperation = "screen";

    const r = bw * 0.65;
    const g = ctx.createRadialGradient(hx, hy, r * 0.2, hx, hy, r);
    g.addColorStop(0, "rgba(160,220,255,0.35)");
    g.addColorStop(1, "rgba(160,220,255,0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // ===== FX BACK (CORRIG√â : renderTime en ms) =====
  if (fxBack){
    // ‚úÖ ICI : On envoie renderTime (ms) au lieu de fxTime (s)
    fxBack(ctx, 0, 0, bw, bh, renderTime, false);
  }

  // ===== FACE (Utilise fxTime global) =====
  faceFn(ctx, hx, hy, headR, vy);

  // ===== FX FRONT (CORRIG√â : renderTime en ms) =====
  if (skinId === "voidwalker"){
    // ‚úÖ ICI : On envoie renderTime (ms)
    drawVoidwalkerFrontFX(ctx, 0, 0, bw, bh, renderTime);
  }

  ctx.restore();
}

/* =========================
   SHOP PREVIEW ‚Äî MIRROR SAFE
========================= */
function drawPlayerPreview(pctx, skinId, t){
  const w = pctx.canvas.width;
  const h = pctx.canvas.height;

  const bw = 36;
  const bh = 32;
  const bx = (w - bw) * 0.5;
  const by = (h - bh) * 0.5 + 6;

  const fxBack = SKIN_FX_BACK[skinId] || drawMoonyFX;
  const faceFn = getFaceFn(skinId);

  pctx.save();
  pctx.translate(bx + bw * 0.5, by + bh * 0.5);
  pctx.scale(1.35, 1.35);
  pctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  fxBack(pctx, 0, 0, bw, bh, t, true);
  faceFn(pctx, hx, hy, headR, 0);

  pctx.restore();
}

/* =========================================================
   üé® SKIN ROUTERS (LE PONT ENTRE LE SHOP ET LE DESSIN)
   Ces fonctions permettent au Shop d'appeler le bon dessin
   sans conna√Ætre les d√©tails techniques du jeu.
========================================================= */

// 1. ROUTEUR DE VISAGE (FACE)
function getFaceFn(skinId){
  // Associe le nom du skin √† la fonction de visage existante dans ton jeu
  switch(skinId){
    case "moony":      return drawMoonyFace;   // V√©rifie que ces noms existent bien
    case "solar":      return drawSolarFace;
    case "forest":     return drawForestFace;
    case "arctic":     return drawArcticFace;
    case "inferno":    return drawInfernoFace;
    case "neon":       return drawNeonFace;
    case "voidwalker": return drawVoidFace;    // Souvent appel√© drawVoidFace ou drawVoidwalkerFace
    default:           return drawMoonyFace;
  }
}

// 2. ROUTEUR FX ARRI√àRE (BACK)
// On cr√©e une map pour √©viter un switch g√©ant si possible, ou on garde le switch
const SKIN_FX_BACK = {
  "moony":      drawMoonyFX,
  "solar":      drawSolarFX,
  "forest":     drawForestFX,
  "arctic":     drawArcticFX,
  "inferno":    drawInfernoFX,
  "neon":       drawNeonFX,
  "voidwalker": drawVoidwalkerFX
};

// 3. ROUTEUR FX G√âN√âRAL (Appel√© par le preview)
function drawSkinFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  if (skipHeavyFX) return;


  
  if (fxFunc) {
    fxFunc(ctx, bx, by, bw, bh, t, isPreview);
  }
}

// 4. ROUTEUR FX AVANT (FRONT - Masques, lueurs par dessus le visage)
function drawSkinFrontFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  // Seuls certains skins ont des effets par dessus le visage
  if (skinId === "voidwalker"){
    // V√©rifie si cette fonction existe dans ton code, sinon commente la ligne
    if (typeof drawVoidwalkerFrontFX === "function") {
      drawVoidwalkerFrontFX(ctx, bx, by, bw, bh, t);
    }
  }
  // Tu peux ajouter d'autres skins ici si besoin (ex: lunettes pour Neon ?)
}

// ===== GLOBAL (une seule fois, au-dessus de drawMoonyFace) =====
let moonyBlink = 1;
let blinkPhase = 0;
let nextBlink  = 0;

// "normal" ou "nintendo"
let moonyBlinkMode = "nintendo";

/* =========================
   MOONY FACE ‚Äî PERF CACHE (PRO)
   - garde le design (skin+halo+core+yeux identiques)
   - √©vite les allocs lourdes chaque frame en "quantizant" les gradients
========================= */

// caches (key -> CanvasGradient)
const _moonyGradSkin = new Map();
const _moonyGradGlow = new Map();
const _moonyGradCore = new Map();
const _moonyGradIris = new Map();
const _moonyGradEyeGlow = new Map();

// quantize helper (stabilise les cl√©s -> moins de re-cr√©ations)
function _q(v, step){ return Math.round(v / step) * step; }
function _qi01(v, steps){
  // clamp 0..1 puis bucket
  const x = v < 0 ? 0 : (v > 1 ? 1 : v);
  return (x * steps) | 0;
}

function drawMoonyFace(ctx, hx, hy, r, vy){
  const t = fxTime;
  const focus = moonyExpr || 0;

  /* =========================
     POSITION GLOBALE
  ========================= */
  const eyeY      = hy - r * 0.18;
  const eyeOffset = r * 0.46;

  /* =========================
     BLINK (2 MODES)
  ========================= */
  if (moonyBlinkMode === "normal") {
    moonyBlink =
      (Math.sin(t * 0.9 + Math.sin(t * 0.13) * 2) > 0.96) ? 0.18 : 1;
  } else {
    if (t > nextBlink && blinkPhase === 0) blinkPhase = 0.01;

    if (blinkPhase > 0) {
      blinkPhase += 0.18;
      moonyBlink = Math.abs(Math.cos(blinkPhase));

      if (blinkPhase > Math.PI) {
        blinkPhase = 0;
        moonyBlink = 1;

        // double blink rare (peu fr√©quent => OK)
        if (Math.random() < 0.18) nextBlink = t + 0.15;
        else nextBlink = t + 2.1 + Math.random() * 2.6;
      }
    }
  }

  /* =========================
     LUEUR LUNAIRE ‚Äî AUTONOME
  ========================= */
  const moonPulse = 0.75 + Math.sin(t * 1.1) * 0.25; // respiration lente
  const moonShine = 0.60 + Math.sin(t * 0.4) * 0.40; // variation large

  // ---- PERF: quantize pour √©viter de recr√©er les gradients en continu
  const rq = _q(r, 0.25);
  const pIdx = _qi01((moonPulse - 0.5) / 0.7, 14); // ~14 steps
  const sIdx = _qi01((moonShine - 0.2) / 1.0, 14);

  /* =========================
     PEAU ARGENT√âE (base visible)
  ========================= */
  {
    const key = rq + "|" + pIdx + "|" + sIdx;
    let moonSkin = _moonyGradSkin.get(key);
    if (!moonSkin){
      const mp = 0.5 + (pIdx / 14) * 0.7; // remap bucket -> valeur stable
      const ms = 0.2 + (sIdx / 14) * 1.0;

      moonSkin = ctx.createRadialGradient(
        hx, hy - rq*0.25, rq*0.12,
        hx, hy, rq*1.35
      );
      moonSkin.addColorStop(0,   `rgb(${232 + mp*18}, ${238 + mp*12}, ${252})`);
      moonSkin.addColorStop(0.55,`rgb(${205 + ms*22}, ${215 + ms*16}, ${232 + ms*10})`);
      moonSkin.addColorStop(1,   `rgb(${175 + ms*10}, ${185 + ms*10}, ${205 + ms*8})`);

      _moonyGradSkin.set(key, moonSkin);
      // petit garde-fou m√©moire
      if (_moonyGradSkin.size > 220) _moonyGradSkin.clear();
    }

    ctx.fillStyle = moonSkin;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.03, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     HALO LUNAIRE (autour)
  ========================= */
  {
    const key = rq + "|" + pIdx + "|" + sIdx;
    let moonGlow = _moonyGradGlow.get(key);
    if (!moonGlow){
      const mp = 0.5 + (pIdx / 14) * 0.7;
      const ms = 0.2 + (sIdx / 14) * 1.0;

      moonGlow = ctx.createRadialGradient(
        hx, hy - rq*0.25, rq*0.15,
        hx, hy, rq*1.65
      );
      moonGlow.addColorStop(0,    `rgba(255,255,255,${0.22 * mp})`);
      moonGlow.addColorStop(0.45, `rgba(225,238,255,${0.18 * ms})`);
      moonGlow.addColorStop(1,    "rgba(255,255,255,0)");

      _moonyGradGlow.set(key, moonGlow);
      if (_moonyGradGlow.size > 220) _moonyGradGlow.clear();
    }

    ctx.fillStyle = moonGlow;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.18, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     CORE LUMINEUX (c≈ìur)
  ========================= */
  {
    const key = rq + "|" + pIdx;
    let moonCore = _moonyGradCore.get(key);
    if (!moonCore){
      const mp = 0.5 + (pIdx / 14) * 0.7;

      moonCore = ctx.createRadialGradient(
        hx, hy - rq*0.15, rq*0.05,
        hx, hy, rq*0.95
      );
      moonCore.addColorStop(0, `rgba(255,255,255,${0.22 + mp*0.18})`);
      moonCore.addColorStop(1, "rgba(255,255,255,0)");

      _moonyGradCore.set(key, moonCore);
      if (_moonyGradCore.size > 180) _moonyGradCore.clear();
    }

    ctx.fillStyle = moonCore;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*0.98, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     YEUX ‚Äî B√âB√â MANGA
  ========================= */
  function moonyEye(x){
    ctx.save();
    ctx.translate(x, eyeY);

    const baseR = r * 0.34;
    const eyeR  = baseR * (0.98 + Math.sin(t*1.6)*0.025);

    // quantize radius pour caches
    const erq = _q(eyeR, 0.25);

    ctx.scale(1, moonyBlink);

    // blanc
    ctx.fillStyle = "#fffefb";
    ctx.beginPath();
    ctx.arc(0, 0, erq, 0, Math.PI*2);
    ctx.fill();

    // iris large (CACHE)
    {
      const key = erq;
      let iris = _moonyGradIris.get(key);
      if (!iris){
        iris = ctx.createRadialGradient(0,0,0,0,0,erq*0.9);
        iris.addColorStop(0, "#7a6646");
        iris.addColorStop(1, "#4a3a24");
        _moonyGradIris.set(key, iris);
        if (_moonyGradIris.size > 160) _moonyGradIris.clear();
      }
      ctx.fillStyle = iris;
      ctx.beginPath();
      ctx.arc(0, 0, erq * 0.72, 0, Math.PI*2);
      ctx.fill();
    }

    // pupille petite
    ctx.fillStyle = "#1b1611";
    ctx.beginPath();
    ctx.arc(
      Math.sin(t*0.6) * erq * (0.10 - focus*0.04),
      Math.cos(t*0.5) * erq * (0.10 - focus*0.04),
      erq * (0.20 - focus*0.08),
      0, Math.PI*2
    );
    ctx.fill();

    // reflets kawaii
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.beginPath();
    ctx.arc(-erq*0.32, -erq*0.36, erq*0.30, 0, Math.PI*2);
    ctx.arc( erq*0.18, -erq*0.22, erq*0.12, 0, Math.PI*2);
    ctx.arc(-erq*0.05, -erq*0.05, erq*0.06, 0, Math.PI*2);
    ctx.fill();

    // glow doux (CACHE)
    {
      const key = erq;
      let glow = _moonyGradEyeGlow.get(key);
      if (!glow){
        glow = ctx.createRadialGradient(0,0,erq*0.4,0,0,erq*1.25);
        glow.addColorStop(0, "rgba(255,255,255,0.12)");
        glow.addColorStop(1, "rgba(255,255,255,0)");
        _moonyGradEyeGlow.set(key, glow);
        if (_moonyGradEyeGlow.size > 160) _moonyGradEyeGlow.clear();
      }
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0,0,erq*1.2,0,Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  moonyEye(hx - eyeOffset);
  moonyEye(hx + eyeOffset);

  /* =========================
     BOUCHE ‚Äî VIVANTE (RESPIRATION + TILT + micro "o")
  ========================= */
  const my = hy + r * 0.42;

  const breathe = Math.sin(t * 1.6) * r * 0.025;
  const mood    = focus ? -r*0.04 : r*0.02;
  const tilt    = Math.sin(t * 0.9) * r * 0.015;

  ctx.strokeStyle = "#6a5844";
  ctx.lineWidth   = r * 0.065;
  ctx.lineCap     = "round";

  ctx.beginPath();
  ctx.moveTo(hx - r*0.15, my);
  ctx.quadraticCurveTo(
    hx + tilt,
    my + r*0.18 + breathe + mood,
    hx + r*0.15,
    my
  );
  ctx.stroke();

  // micro "o" rare (kawaii)
  if (!focus && Math.sin(t * 0.6) > 0.92) {
    ctx.fillStyle = "#6a5844";
    ctx.beginPath();
    ctx.arc(hx, my + r*0.05, r*0.045, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     JOUES ‚Äî KAWAII POWER
  ========================= */
  ctx.fillStyle = "rgba(255,180,170,0.45)";
  ctx.beginPath();
  ctx.arc(hx - r*0.42, hy + r*0.24, r*0.13, 0, Math.PI*2);
  ctx.arc(hx + r*0.42, hy + r*0.24, r*0.13, 0, Math.PI*2);
  ctx.fill();
}





/* =========================================================
   SOLAR FACE ‚Äî CLEAN / SAFE / PERF
   ‚úî design identique
   ‚úî caches born√©s
   ‚úî sync fxTime
   ‚úî pas de double _q/_qi01 (utilise ceux d√©j√† globaux)
========================================================= */

// ===== CACHES (UNE SEULE FOIS) =====
const _solarGradSkin = new Map();
const _solarGradHalo = new Map();
const _solarGradCore = new Map();
const _solarGradIris = new Map();

function drawSolarFace(ctx, hx, hy, r, vy){
  const t = fxTime;

  // √©nergie
  const sun = 0.6 + Math.sin(t * 0.7) * 0.4;

  // quantisation (perf)
  const rq   = _q(r, 0.25);
  const sIdx = _qi01((sun - 0.2) / 1.0, 14);

  const eyeY      = hy - rq * 0.22;
  const eyeOffset = rq * 0.48;

  // blink (stable)
  const blink = (Math.sin(t * 1.6 + Math.sin(t * 0.25) * 2.5) > 0.92) ? 0.14 : 1;

  /* =========================
     PEAU ‚Äî SOLAIRE
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _solarGradSkin.get(key);
    if (!g){
      const s = 0.2 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.25, rq*0.15, hx, hy, rq*1.4);
      g.addColorStop(0,  `rgb(255, ${235 + s*15}, ${170 + s*10})`);
      g.addColorStop(0.55,`rgb(245, ${200 + s*25}, ${120 + s*15})`);
      g.addColorStop(1,  `rgb(210, ${150 + s*20}, ${80  + s*10})`);

      _solarGradSkin.set(key, g);
      if (_solarGradSkin.size > 180) _solarGradSkin.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.03, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     HALO
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _solarGradHalo.get(key);
    if (!g){
      const s = 0.2 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.3, rq*0.2, hx, hy, rq*1.6);
      g.addColorStop(0,    `rgba(255,220,120,${0.22 * s})`);
      g.addColorStop(0.45, `rgba(255,180,80,${0.18 * s})`);
      g.addColorStop(1,    "rgba(255,200,100,0)");

      _solarGradHalo.set(key, g);
      if (_solarGradHalo.size > 180) _solarGradHalo.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.15, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     CORE
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _solarGradCore.get(key);
    if (!g){
      const s = 0.2 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.15, rq*0.05, hx, hy, rq*0.9);
      g.addColorStop(0, `rgba(255,240,180,${0.22 + s*0.18})`);
      g.addColorStop(1, "rgba(255,255,255,0)");

      _solarGradCore.set(key, g);
      if (_solarGradCore.size > 160) _solarGradCore.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*0.95, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     YEUX
  ========================= */
  function solarEye(x){
    ctx.save();
    ctx.translate(x, eyeY);

    const eyeW = rq * 0.30;
    const eyeH = rq * 0.22 * blink;

    ctx.fillStyle = "#fffdf6";
    ctx.beginPath();
    ctx.ellipse(0, 0, eyeW, eyeH, 0, 0, Math.PI*2);
    ctx.fill();

    // iris (cache)
    {
      const k = _q(eyeW, 0.25);
      let iris = _solarGradIris.get(k);
      if (!iris){
        iris = ctx.createRadialGradient(0,0,0,0,0,k*0.7);
        iris.addColorStop(0, "#fff6b5");
        iris.addColorStop(1, "#ff9800");
        _solarGradIris.set(k, iris);
        if (_solarGradIris.size > 140) _solarGradIris.clear();
      }
      ctx.fillStyle = iris;
      ctx.beginPath();
      ctx.arc(0, 0, eyeW * 0.45, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "#3e2723";
    ctx.beginPath();
    ctx.arc(
      Math.sin(t*0.35) * eyeW * 0.08,
      Math.cos(t*0.3)  * eyeH * 0.08,
      eyeW * 0.20,
      0, Math.PI*2
    );
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(-eyeW*0.18, -eyeH*0.35, eyeW*0.18, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "rgba(120,70,20,0.55)";
    ctx.lineWidth = rq * 0.05;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(-eyeW*0.9, -eyeH*0.6);
    ctx.lineTo( eyeW*0.9, -eyeH*0.6);
    ctx.stroke();

    ctx.restore();
  }

  solarEye(hx - eyeOffset);
  solarEye(hx + eyeOffset);

  /* =========================
     SOURCILS
  ========================= */
  ctx.strokeStyle = "rgba(255,170,70,0.95)";
  ctx.lineWidth = rq * 0.09;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(hx - rq*0.55, eyeY - rq*0.36);
  ctx.lineTo(hx - rq*0.18, eyeY - rq*0.28);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(hx + rq*0.55, eyeY - rq*0.36);
  ctx.lineTo(hx + rq*0.18, eyeY - rq*0.28);
  ctx.stroke();

  /* =========================
     BOUCHE
  ========================= */
  const mouthY = hy + rq * 0.40;
  const mood = Math.sin(t * 0.6) * rq * 0.02;

  ctx.strokeStyle = "rgba(90,55,25,0.7)";
  ctx.lineWidth = rq * 0.09;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(hx - rq*0.20, mouthY);
  ctx.quadraticCurveTo(hx, mouthY + rq*0.08 + mood, hx + rq*0.20, mouthY);
  ctx.stroke();
}



/* =========================================================
   FOREST FACE ‚Äî CLEAN / SAFE / PERF
   ‚úî design identique
   ‚úî caches born√©s
   ‚úî sync fxTime
   ‚úî pas de _fq/_fi01 (utilise _q/_qi01 d√©j√† globaux)
========================================================= */

// ===== CACHES (UNE SEULE FOIS) =====
const _forestGradSkin = new Map();
const _forestGradHalo = new Map();
const _forestGradCore = new Map();
const _forestGradIris = new Map();

function drawForestFace(ctx, hx, hy, r, vy){
  const t = fxTime;

  // s√®ve
  const sap = 0.55 + Math.sin(t * 0.5) * 0.45;

  // quantisation perf
  const rq   = _q(r, 0.25);
  const sIdx = _qi01((sap - 0.1) / 1.0, 14);

  const eyeY      = hy - rq * 0.18;
  const eyeOffset = rq * 0.48;

  const blink = (Math.sin(t * 1.8 + Math.sin(t * 0.35) * 2.6) > 0.90) ? 0.14 : 1;

  /* =========================
     PEAU ‚Äî MOUSSE / √âCORCE
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _forestGradSkin.get(key);
    if (!g){
      const s = 0.1 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.25, rq*0.18, hx, hy, rq*1.5);
      g.addColorStop(0,    `rgb(${145 + s*20}, ${185 + s*25}, ${120 + s*15})`);
      g.addColorStop(0.55, `rgb(${95  + s*30}, ${145 + s*35}, ${80  + s*25})`);
      g.addColorStop(1,    `rgb(${55  + s*25}, ${95  + s*30}, ${55  + s*20})`);

      _forestGradSkin.set(key, g);
      if (_forestGradSkin.size > 180) _forestGradSkin.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.05, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     HALO ‚Äî CANOP√âE
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _forestGradHalo.get(key);
    if (!g){
      const s = 0.1 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.35, rq*0.30, hx, hy, rq*1.7);
      g.addColorStop(0,    `rgba(120,180,130,${0.18 * s})`);
      g.addColorStop(0.45, `rgba(70,120,80,${0.14 * s})`);
      g.addColorStop(1,    "rgba(40,70,45,0)");

      _forestGradHalo.set(key, g);
      if (_forestGradHalo.size > 180) _forestGradHalo.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.2, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     CORE ‚Äî S√àVE INTERNE
  ========================= */
  {
    const key = rq + "|" + sIdx;
    let g = _forestGradCore.get(key);
    if (!g){
      const s = 0.1 + (sIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.12, rq*0.05, hx, hy, rq*0.85);
      g.addColorStop(0, `rgba(190,230,170,${0.20 + s*0.20})`);
      g.addColorStop(1, "rgba(190,230,170,0)");

      _forestGradCore.set(key, g);
      if (_forestGradCore.size > 160) _forestGradCore.clear();
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*0.95, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     YEUX ‚Äî FEUILLE / S√àVE
  ========================= */
  function forestEye(x){
    ctx.save();
    ctx.translate(x, eyeY);

    const eyeW = rq * 0.28;
    const eyeH = rq * 0.22 * blink;

    ctx.fillStyle = "#e6f2e4";
    ctx.beginPath();
    ctx.ellipse(0, 0, eyeW, eyeH, 0, 0, Math.PI*2);
    ctx.fill();

    // iris (cache)
    {
      const k = _q(eyeW, 0.25);
      let iris = _forestGradIris.get(k);
      if (!iris){
        iris = ctx.createRadialGradient(0,0,0,0,0,k*0.7);
        iris.addColorStop(0, "#b6f2c2");
        iris.addColorStop(1, "#1b5e20");
        _forestGradIris.set(k, iris);
        if (_forestGradIris.size > 140) _forestGradIris.clear();
      }
      ctx.fillStyle = iris;
      ctx.beginPath();
      ctx.arc(0, 0, eyeW * 0.46, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "#0b2a14";
    ctx.beginPath();
    ctx.arc(
      Math.sin(t*0.45) * eyeW * 0.10,
      Math.cos(t*0.35) * eyeH * 0.10,
      eyeW * 0.20,
      0, Math.PI*2
    );
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.beginPath();
    ctx.arc(-eyeW*0.16, -eyeH*0.32, eyeW*0.14, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "rgba(20,60,35,0.55)";
    ctx.lineWidth = rq * 0.05;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(-eyeW*0.9, -eyeH*0.6);
    ctx.lineTo( eyeW*0.9, -eyeH*0.6);
    ctx.stroke();

    ctx.restore();
  }

  forestEye(hx - eyeOffset);
  forestEye(hx + eyeOffset);

  /* =========================
     SOURCILS ‚Äî BRANCHES
  ========================= */
  ctx.strokeStyle = "rgba(30,80,45,0.6)";
  ctx.lineWidth = rq * 0.075;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(hx - rq*0.55, eyeY - rq*0.32);
  ctx.quadraticCurveTo(hx - rq*0.35, eyeY - rq*0.42, hx - rq*0.18, eyeY - rq*0.30);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(hx + rq*0.55, eyeY - rq*0.32);
  ctx.quadraticCurveTo(hx + rq*0.35, eyeY - rq*0.42, hx + rq*0.18, eyeY - rq*0.30);
  ctx.stroke();

  /* =========================
     BOUCHE ‚Äî FEUILLE SOUPLE
  ========================= */
  const mouthY = hy + rq * 0.40;
  const mood = Math.sin(t * 0.7) * rq * 0.03;

  ctx.strokeStyle = "rgba(25,70,40,0.7)";
  ctx.lineWidth = rq * 0.08;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(hx - rq*0.20, mouthY);
  ctx.quadraticCurveTo(hx, mouthY + rq*0.10 + mood, hx + rq*0.20, mouthY);
  ctx.stroke();
}




/* =========================================================
   ARCTIC FACE ‚Äî CLEAN / SAFE / PERF
   ‚úî design identique
   ‚úî caches born√©s
   ‚úî sync fxTime
   ‚úî pas de _aq/_ai01 (r√©utilise _q/_qi01 d√©j√† globaux)
========================================================= */

// ===== CACHES (UNE SEULE FOIS) =====
const _arcticGradSkin  = new Map();
const _arcticGradHalo  = new Map();
const _arcticGradCore  = new Map();
const _arcticGradRing  = new Map();
const _arcticGradCrack = new Map(); // linearGradient (mw quantis√©)

function drawArcticFace(ctx, hx, hy, r, vy){
  const t = fxTime;

  const cold = 0.6 + Math.sin(t * 0.55) * 0.4;

  const rq   = _q(r, 0.25);
  const cIdx = _qi01((cold - 0.1) / 1.0, 14);

  const eyeY  = hy - rq * 0.26;
  const eyeDX = rq * 0.50;

  const blink = (Math.sin(t * 1.6) > 0.985) ? 0.10 : 1;
  const gaze  = Math.sin(t * 0.35) * rq * 0.03;

  /* =========================
     PEAU ‚Äî GLACE COMPACTE
  ========================= */
  {
    const key = rq + "|" + cIdx;
    let g = _arcticGradSkin.get(key);
    if (!g){
      const c = 0.1 + (cIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.30, rq*0.18, hx, hy, rq*1.45);
      g.addColorStop(0,    `rgb(${225 + c*15}, ${245 + c*10}, 255)`);
      g.addColorStop(0.55, `rgb(${170 + c*25}, ${215 + c*30}, ${245 + c*20})`);
      g.addColorStop(1,    `rgb(${110 + c*25}, ${160 + c*30}, ${200 + c*20})`);

      _arcticGradSkin.set(key, g);
      if (_arcticGradSkin.size > 180) _arcticGradSkin.clear();
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.05, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     HALO ‚Äî AIR GLACIAL
  ========================= */
  {
    const key = rq + "|" + cIdx;
    let g = _arcticGradHalo.get(key);
    if (!g){
      const c = 0.1 + (cIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.35, rq*0.25, hx, hy, rq*1.7);
      g.addColorStop(0,    `rgba(220,245,255,${0.18 * c})`);
      g.addColorStop(0.45, `rgba(140,200,240,${0.14 * c})`);
      g.addColorStop(1,    "rgba(120,170,210,0)");

      _arcticGradHalo.set(key, g);
      if (_arcticGradHalo.size > 180) _arcticGradHalo.clear();
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.2, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     CORE ‚Äî FROID DENSE
  ========================= */
  {
    const key = rq + "|" + cIdx;
    let g = _arcticGradCore.get(key);
    if (!g){
      const c = 0.1 + (cIdx / 14) * 1.0;

      g = ctx.createRadialGradient(hx, hy - rq*0.15, rq*0.05, hx, hy, rq*0.95);
      g.addColorStop(0, `rgba(245,255,255,${0.22 + c*0.18})`);
      g.addColorStop(1, "rgba(245,255,255,0)");

      _arcticGradCore.set(key, g);
      if (_arcticGradCore.size > 160) _arcticGradCore.clear();
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*0.98, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     YEUX ‚Äî SENTINELLE POLAIRE
  ========================= */
  function arcticEye(x){
    ctx.save();
    ctx.translate(x + gaze, eyeY);

    const w = rq * 0.42;
    const h = rq * 0.18 * blink;

    ctx.fillStyle = "#e9faff";
    ctx.beginPath();
    ctx.ellipse(0, 0, w, h, 0, 0, Math.PI*2);
    ctx.fill();

    // anneau glac√© (CACHE)
    {
      const k = _q(w, 0.25);
      let ring = _arcticGradRing.get(k);
      if (!ring){
        ring = ctx.createRadialGradient(0,0,k*0.18, 0,0,k*0.55);
        ring.addColorStop(0,    "rgba(255,255,255,0)");
        ring.addColorStop(0.35, "#d8f6ff");
        ring.addColorStop(0.6,  "#8bd9ff");
        ring.addColorStop(0.85, "#3c8fc4");
        ring.addColorStop(1,    "#0b2a3d");
        _arcticGradRing.set(k, ring);
        if (_arcticGradRing.size > 140) _arcticGradRing.clear();
      }

      ctx.strokeStyle = ring;
      ctx.lineWidth = rq * 0.13;
      ctx.beginPath();
      ctx.arc(0, 0, w*0.42, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.fillStyle = "#061823";
    ctx.beginPath();
    ctx.arc(0, 0, w*0.12, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "#9fe5ff";
    ctx.lineWidth = rq * 0.14;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(-w*1.15, -h*0.80);
    ctx.lineTo( w*1.15, -h*0.90);
    ctx.stroke();

    ctx.restore();
  }

  arcticEye(hx - eyeDX);
  arcticEye(hx + eyeDX);

  /* =========================
     BOUCHE ‚Äî FISSURE GLAC√âE
  ========================= */
  const mouthY = hy + rq * 0.58;
  const pulse  = (Math.sin(t * 1.3) + 1) * 0.5;

  const mw = rq * 0.36;
  const mh = rq * (0.06 + pulse * 0.035);

  {
    const mwq = _q(mw, 0.5);
    const key = String(mwq);

    let crack = _arcticGradCrack.get(key);
    if (!crack){
      crack = ctx.createLinearGradient(hx - mwq, mouthY, hx + mwq, mouthY);
      crack.addColorStop(0,    "rgba(170,235,255,0)");
      crack.addColorStop(0.45, "rgba(230,250,255,0.95)");
      crack.addColorStop(0.55, "rgba(230,250,255,0.95)");
      crack.addColorStop(1,    "rgba(170,235,255,0)");
      _arcticGradCrack.set(key, crack);
      if (_arcticGradCrack.size > 120) _arcticGradCrack.clear();
    }

    ctx.fillStyle = crack;
    ctx.beginPath();
    ctx.ellipse(hx, mouthY, mw, mh, 0, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     SOUFFLE GLACIAL
  ========================= */
  const breath = Math.max(0, Math.sin(t * 2.1));
  if (breath > 0.4){
    ctx.fillStyle = `rgba(220,245,255,${(breath - 0.4) * 0.35})`;
    ctx.beginPath();
    ctx.ellipse(
      hx,
      mouthY + rq*0.10,
      rq*0.32 * breath,
      rq*0.18 * breath,
      0, 0, Math.PI*2
    );
    ctx.fill();
  }

  /* =========================
     GIVRE ‚Äî POMMETTES
  ========================= */
  ctx.fillStyle = "rgba(200,240,255,0.35)";
  ctx.beginPath();
  ctx.arc(hx - rq*0.58, eyeY + rq*0.15, rq*0.075, 0, Math.PI*2);
  ctx.arc(hx + rq*0.58, eyeY + rq*0.15, rq*0.075, 0, Math.PI*2);
  ctx.fill();
}



/* =========================================================
   NEON FACE ‚Äî CLEAN / SAFE / PERF (DESIGN IDENTIQUE)
   ‚úî pas de changement visuel
   ‚úî √©vite Math.random() chaque frame (flicker stable)
   ‚úî shadowBlur born√© si fps bas / fxCalm bas
   ‚úî roundRect fallback (iOS safe)
========================================================= */

// ===== GLOBAL (UNE SEULE FOIS) =====
let neonFace = 0;
let neonNext = 0;
let neonFlickEnd = 0;

// flicker stable (pas de random par frame)
let _neonFlickSeed = 1337;
function _neonRand(){
  // LCG simple + stable
  _neonFlickSeed = (_neonFlickSeed * 1664525 + 1013904223) >>> 0;
  return _neonFlickSeed / 4294967296;
}

// caches l√©gers (inchang√©)
const _neonPalette = [
  { eye:"#7dfcff", mouth:"#5fb8ff", accent:null },      // HAPPY
  { eye:"#c77dff", mouth:"#7b2cff", accent:"#7dfcff" }, // SAD
  { eye:"#ff3b3b", mouth:"#b30000", accent:null },      // DEAD
  { eye:"#ffe066", mouth:"#7dfcff", accent:"#ff5fa2" }  // WINK
];

// roundRect fallback iOS (si pas support)
function _roundRectPath(ctx, x, y, w, h, r){
  r = Math.max(0, Math.min(r, Math.min(w, h) * 0.5));
  if (ctx.roundRect){
    ctx.roundRect(x, y, w, h, r);
    return;
  }
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
}

function drawNeonFace(ctx, hx, hy, r, vy){
  const t = fxTime;

  /* =========================
     SCHEDULER ENSEIGNE (STABLE)
  ========================= */
  if (t > neonNext){
    neonFace = (neonFace + 1 + ((Math.random()*3)|0)) & 3;
    neonFlickEnd = t + 0.25 + Math.random()*0.25;
    neonNext = t + 2.5 + Math.random()*2.5;
  }

  const inFlicker = t < neonFlickEnd;

  /* =========================
     POWER ‚Äî LISS√â (ANTI JITTER)
     + flicker stable (sans random/frame)
  ========================= */
  let power;
  if (inFlicker){
    // pattern binaire stable ~25%
    power = (_neonRand() < 0.25) ? 0 : 0.55;
  } else {
    power = 0.9 + Math.sin(t * 18) * 0.06 + Math.sin(t * 42) * 0.04;
  }

  // bornage (√©vite glitch alpha)
  if (power < 0) power = 0;
  if (power > 1) power = 1;

  const P = _neonPalette[neonFace];
  const rq = Math.round(r * 4) * 0.25;

  // glow budget (suit ton syst√®me)
  const allowGlow = (typeof fps !== "undefined" ? (fps > 48) : true) && (typeof fxCalm !== "undefined" ? (fxCalm > 0.01) : true);
  const glowMul = allowGlow ? 1 : 0;

  ctx.save();
  ctx.globalAlpha = power;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  /* =========================
     T√äTE ‚Äî TUBE N√âON
  ========================= */
  ctx.strokeStyle = "#3dfcff";
  ctx.lineWidth   = rq * 0.12;

  ctx.shadowColor = "#3dfcff";
  ctx.shadowBlur  = rq * 0.55 * power * glowMul;

  ctx.beginPath();
  ctx.arc(hx, hy, rq * 0.9, 0, Math.PI * 2);
  ctx.stroke();

  /* =========================
     BLINK GLOBAL
  ========================= */
  const blink =
    Math.sin(t * 2.4 + Math.sin(t * 0.6) * 2.2) > 0.94
      ? 0.18
      : 1;

  /* =========================
     YEUX ‚Äî ROBOT N√âON
  ========================= */
  const eyeY  = hy - rq * 0.22;
  const dx    = rq * 0.32;
  const size  = rq * 0.10;
  const inner = size * 0.55;

  function drawEye(x, closed){
    ctx.save();
    ctx.translate(x, eyeY);
    ctx.scale(1, closed ? 0.15 : blink);

    ctx.strokeStyle = P.eye;
    ctx.lineWidth   = rq * 0.045;
    ctx.shadowColor = P.eye;
    ctx.shadowBlur  = rq * 0.45 * power * glowMul;

    ctx.beginPath();
    _roundRectPath(ctx, -size, -size, size*2, size*2, rq*0.04);
    ctx.stroke();

    ctx.lineWidth = rq * 0.018;
    ctx.beginPath();
    _roundRectPath(ctx, -inner, -inner, inner*2, inner*2, rq*0.03);
    ctx.stroke();

    if (neonFace !== 2 && !closed){
      ctx.fillStyle   = "#ffffff";
      ctx.shadowColor = "#ffffff";
      ctx.shadowBlur  = rq * 0.25 * power * glowMul;

      ctx.beginPath();
      ctx.arc(
        Math.sin(t*1.2) * inner * 0.25,
        Math.cos(t*1.1) * inner * 0.25,
        inner * 0.25,
        0, Math.PI*2
      );
      ctx.fill();
    }

    ctx.restore();
  }

  if (neonFace === 3){
    drawEye(hx - dx, true);
    drawEye(hx + dx, false);
  } else {
    drawEye(hx - dx, false);
    drawEye(hx + dx, false);
  }

  /* =========================
     BOUCHE ‚Äî DOUBLE TUBE
  ========================= */
  const my = hy + rq * 0.28;

  ctx.strokeStyle = P.mouth;
  ctx.shadowColor = P.mouth;
  ctx.shadowBlur  = rq * 0.45 * power * glowMul;

  function mouthPath(rad){
    ctx.beginPath();
    if (neonFace === 0){
      ctx.arc(hx, my, rad, 0, Math.PI);
    } else if (neonFace === 1){
      ctx.arc(hx, my + rq*0.14, rad, Math.PI, 0);
    } else if (neonFace === 2){
      ctx.moveTo(hx - rad*0.74, my);
      ctx.lineTo(hx + rad*0.74, my);
    } else {
      ctx.arc(hx, my, rad*0.87, 0, Math.PI);
    }
  }

  ctx.lineWidth = rq * 0.09;
  mouthPath(rq*0.30);
  ctx.stroke();

  ctx.lineWidth = rq * 0.028;
  ctx.shadowBlur = rq * 0.25 * power * glowMul;
  mouthPath(rq*0.30);
  ctx.stroke();

  /* =========================
     LANGUE ‚Äî ACCENT
  ========================= */
  if (neonFace === 3 && P.accent){
    ctx.strokeStyle = P.accent;
    ctx.shadowColor = P.accent;
    ctx.shadowBlur  = rq * 0.35 * power * glowMul;
    ctx.lineWidth   = rq * 0.06;

    ctx.beginPath();
    ctx.moveTo(hx, my + rq*0.06);
    ctx.lineTo(hx, my + rq*0.16);
    ctx.stroke();
  }

  ctx.restore();
}




/* =========================================================
   VOID FACE ‚Äî CLEAN / SAFE / PERF
   ‚úî rendu STRICTEMENT identique
   ‚úî plus de Math.random() en draw
   ‚úî aura 100 % d√©terministe (pr√©-calcul√©e)
   ‚úî aucun objet allou√© par frame
========================================================= */

// ===== GLOBAL (UNE SEULE FOIS) =====
let _voidAuraInit = false;
let _voidAuraPts  = null;   // Float32Array
let _voidAuraMeta = null;   // Uint8Array

function _initVoidAura(){
  if (_voidAuraInit) return;
  _voidAuraInit = true;

  _voidAuraPts  = new Float32Array(22 * 6);
  _voidAuraMeta = new Uint8Array(22 * 2);

  let seed = 912367; // seed fixe (d√©terministe)
  function rnd(){
    seed = (seed * 1664525 + 1013904223) >>> 0;
    return seed / 4294967296;
  }

  for (let i = 0; i < 22; i++){
    const p = i * 6;
    _voidAuraPts[p+0] = rnd() - 0.5;
    _voidAuraPts[p+1] = rnd() - 0.5;
    _voidAuraPts[p+2] = rnd() - 0.5;
    _voidAuraPts[p+3] = rnd() - 0.5;
    _voidAuraPts[p+4] = rnd() - 0.5;
    _voidAuraPts[p+5] = rnd() - 0.5;

    const roll = rnd();
    const colorIdx = roll < 0.25 ? 0 : roll < 0.5 ? 1 : roll < 0.75 ? 2 : 3;
    const widthIdx = (colorIdx === 0) ? 0 : (colorIdx === 1) ? 1 : 2;

    const m = i * 2;
    _voidAuraMeta[m]   = colorIdx;
    _voidAuraMeta[m+1] = widthIdx;
  }
}

function drawVoidFace(ctx, hx, hy, r){
  _initVoidAura();

  const t = fxTime;
  const R = r * 0.9;

  ctx.save();

  /* =========================
     FACE ‚Äî CYCLE 16s
  ========================= */
  const cycle = (Math.sin(t * 0.25) + 1) * 0.5;
  let c1, c2, c3;

  if (cycle < 0.25){
    const k = cycle * 4;
    c1 = `rgb(255,${245-15*k},${210-40*k})`;
    c2 = `rgb(${235-20*k},${205-30*k},${140-60*k})`;
    c3 = `rgb(120,85,25)`;
  } else if (cycle < 0.5){
    const k = (cycle-0.25)*4;
    c1 = `rgb(${230+15*k},${235+15*k},${240+15*k})`;
    c2 = `rgb(${200+20*k},${205+20*k},${210+20*k})`;
    c3 = `rgb(140,145,150)`;
  } else if (cycle < 0.75){
    const k = (cycle-0.5)*4;
    c1 = `rgb(${220+20*k},${190-30*k},255)`;
    c2 = `rgb(${170+20*k},${110-20*k},220)`;
    c3 = `rgb(90,40,140)`;
  } else {
    const k = (cycle-0.75)*4;
    c1 = `rgb(255,255,255)`;
    c2 = `rgb(${245-20*k},${245-20*k},${245-20*k})`;
    c3 = `rgb(${160-40*k},${160-40*k},${160-40*k})`;
  }

  const face = ctx.createRadialGradient(
    hx + Math.sin(t*0.4)*R*0.05,
    hy - R*0.25,
    R*0.15,
    hx, hy, R
  );
  face.addColorStop(0, c1);
  face.addColorStop(0.45, c2);
  face.addColorStop(1, c3);

  ctx.fillStyle = face;
  ctx.beginPath();
  ctx.arc(hx, hy, R, 0, Math.PI*2);
  ctx.fill();

  /* =========================
     INNER GLOW
  ========================= */
  const glow =
    cycle > 0.75 ? 0.38 :
    cycle > 0.5  ? 0.28 : 0.18;

  ctx.globalAlpha = glow;
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath();
  ctx.arc(hx, hy, R*0.72, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  /* =========================
     CROWN
  ========================= */
  const cy = hy - R*0.62;
  const oR = R*0.92, iR = R*0.78;

  const crown = ctx.createLinearGradient(0, cy-R*0.15, 0, cy+R*0.15);
  crown.addColorStop(0,"rgb(255,230,160)");
  crown.addColorStop(0.5,"rgb(200,150,60)");
  crown.addColorStop(1,"rgb(120,85,25)");

  ctx.fillStyle = crown;
  ctx.beginPath();
  ctx.arc(hx, cy, oR, Math.PI*1.05, Math.PI*1.95);
  ctx.arc(hx, cy, iR, Math.PI*1.95, Math.PI*1.05, true);
  ctx.closePath();
  ctx.fill();

  /* =========================
     EYES
  ========================= */
  const blink = Math.abs(Math.sin(t*1.2)) > 0.96 ? 0.25 : 1;
  const ey = hy - R*0.02;
  const dx = R*0.34;
  const ew = R*0.36;
  const eh = R*0.22 * blink;

  function eye(x){
    ctx.save();
    ctx.translate(x, ey);

    ctx.fillStyle = "rgb(245,245,245)";
    ctx.beginPath();
    ctx.ellipse(0,0,ew,eh,0,0,Math.PI*2);
    ctx.fill();

    if (blink > 0.3){
      ctx.fillStyle = "rgb(170,215,255)";
      ctx.beginPath();
      ctx.ellipse(0,0,ew*0.55,eh*0.55,0,0,Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(0,0,ew*0.25,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  eye(hx-dx);
  eye(hx+dx);

  /* =========================
     MOUTH
  ========================= */
  ctx.strokeStyle = "rgba(40,30,10,0.9)";
  ctx.lineWidth = R*0.08;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(hx-R*0.22, hy+R*0.34);
  ctx.lineTo(hx+R*0.22, hy+R*0.34);
  ctx.stroke();

  /* =========================
     AURA (PRECALC)
  ========================= */
  const s = Math.sin(t*0.9)*0.08;
  const c = Math.cos(t*0.9)*0.08;

  const col = [
    "rgba(210,220,230,0.95)",
    "rgba(255,255,255,0.95)",
    "rgba(255,220,140,0.95)",
    "rgba(200,150,255,0.95)"
  ];

  for (let i=0;i<22;i++){
    const a = i*0.73 + Math.sin(t*0.35+i*1.7)*0.08;
    let x = hx + Math.cos(a)*R*1.1;
    let y = hy + Math.sin(a)*R*1.1;

    const m = i*2;
    ctx.strokeStyle = col[_voidAuraMeta[m]];
    ctx.lineWidth =
      _voidAuraMeta[m+1] === 0 ? R*0.04 :
      _voidAuraMeta[m+1] === 1 ? R*0.045 : R*0.05;

    const p = i*6;
    let d1x=_voidAuraPts[p],   d1y=_voidAuraPts[p+1];
    let d2x=_voidAuraPts[p+2], d2y=_voidAuraPts[p+3];
    let d3x=_voidAuraPts[p+4], d3y=_voidAuraPts[p+5];

    d1x+=d1y*s; d1y+=d1x*c;
    d2x+=d2y*s; d2y+=d2x*c;
    d3x+=d3y*s; d3y+=d3x*c;

    ctx.beginPath();
    ctx.moveTo(x,y);
    x+=d1x*R*0.6; y+=d1y*R*0.6; ctx.lineTo(x,y);
    x+=d2x*R*0.6; y+=d2y*R*0.6; ctx.lineTo(x,y);
    x+=d3x*R*0.6; y+=d3y*R*0.6; ctx.lineTo(x,y);
    ctx.stroke();
  }

  ctx.restore();
}



/* =========================================================
   INFERNO FACE ‚Äî CLEAN / SAFE / PERF
   ‚úî rendu VISUEL IDENTIQUE
   ‚úî gradients mis en cache (plus d‚Äôallocs par frame)
   ‚úî aucune logique supprim√©e
   ‚úî sync 100 % sur fxTime
========================================================= */

// ===== CACHES (UNE SEULE FOIS, AU-DESSUS) =====
const _infernoGradSkin = new Map();
const _infernoGradIris = new Map();
const _infernoGradMouth = new Map();

// helpers
function _iq(v, step){ return Math.round(v / step) * step; }
function _ii01(v, steps){
  const x = v < 0 ? 0 : (v > 1 ? 1 : v);
  return (x * steps) | 0;
}

function drawInfernoFace(ctx, hx, hy, r){
  const t = fxTime;

  /* =========================
     HEAT ‚Äî COL√àRE VIVANTE
  ========================= */
  const heat = 0.5 + Math.sin(t * 0.6) * 0.5;

  const rq   = _iq(r, 0.25);
  const hIdx = _ii01(heat, 14);

  /* =========================
     BLINK ‚Äî RARE & NERVEUX
  ========================= */
  const blink =
    Math.sin(t * 3.2 + Math.sin(t * 0.7) * 2.1) > 0.94
      ? 0.12
      : 1;

  /* =========================
     PEAU ‚Äî FEU VIVANT (CACHE)
  ========================= */
  {
    const key = rq + "|" + hIdx;
    let skin = _infernoGradSkin.get(key);
    if (!skin){
      const h = hIdx / 14;

      skin = ctx.createRadialGradient(
        hx, hy - rq*0.2, rq*0.2,
        hx, hy, rq*1.4
      );
      skin.addColorStop(0, `rgb(${180 + h*60}, ${90 - h*40}, ${70 - h*60})`);
      skin.addColorStop(0.6, `rgb(${120 + h*80}, ${50 - h*30}, ${40 - h*40})`);
      skin.addColorStop(1, `rgb(${60 + h*40}, 20, 15)`);

      _infernoGradSkin.set(key, skin);
      if (_infernoGradSkin.size > 160) _infernoGradSkin.clear();
    }

    ctx.fillStyle = skin;
    ctx.beginPath();
    ctx.arc(hx, hy, rq*1.02, 0, Math.PI*2);
    ctx.fill();
  }

  /* =========================
     YEUX ‚Äî ANGRY
  ========================= */
  const eyeY = hy - rq * 0.22;
  const dx   = rq * 0.45;

  function eye(x){
    ctx.save();
    ctx.translate(x, eyeY);

    const w = rq * 0.32;
    const h = rq * (0.12 + heat * 0.06) * blink;

    // base sombre
    ctx.fillStyle = "#2a0000";
    ctx.beginPath();
    ctx.ellipse(0, 0, w, h, 0, 0, Math.PI*2);
    ctx.fill();

    if (blink > 0.2){
      // iris feu (CACHE)
      const key = _iq(w, 0.25);
      let iris = _infernoGradIris.get(key);
      if (!iris){
        iris = ctx.createRadialGradient(0,0,0, 0,0,key*0.6);
        iris.addColorStop(0, "#fff0c0");
        iris.addColorStop(0.4, "#ff5200");
        iris.addColorStop(1, "#600000");
        _infernoGradIris.set(key, iris);
        if (_infernoGradIris.size > 120) _infernoGradIris.clear();
      }

      ctx.fillStyle = iris;
      ctx.beginPath();
      ctx.arc(0, 0, w*0.42, 0, Math.PI*2);
      ctx.fill();

      // pupille fente
      ctx.fillStyle = "#120000";
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.06, h*1.8, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // sourcil agressif
    ctx.strokeStyle = "#200000";
    ctx.lineWidth   = rq * 0.09;
    ctx.lineCap     = "round";
    ctx.beginPath();
    ctx.moveTo(-w, -h * 1.1);
    ctx.lineTo( w, -h * (1.6 + heat * 0.4));
    ctx.stroke();

    ctx.restore();
  }

  eye(hx - dx);
  eye(hx + dx);

  /* =========================
     BOUCHE ‚Äî RICTUS
  ========================= */
  const mouthY = hy + rq * 0.42;
  const mw     = rq * 0.34;

  const curl   = heat * rq * 0.14;
  const twitch = Math.sin(t * 5.5) * rq * 0.012;
  const side   = 1;

  ctx.strokeStyle = "#1a0000";
  ctx.lineWidth   = rq * 0.085;
  ctx.lineCap     = "round";

  ctx.beginPath();
  ctx.moveTo(hx - mw, mouthY + curl * 0.15);
  ctx.quadraticCurveTo(
    hx,
    mouthY - curl * 0.25,
    hx + mw,
    mouthY - curl * 0.9 - twitch
  );
  ctx.stroke();

  // pli du rictus
  ctx.strokeStyle = "rgba(0,0,0,0.45)";
  ctx.lineWidth   = rq * 0.045;
  ctx.beginPath();
  ctx.moveTo(hx + side * mw * 0.55, mouthY - curl * 0.25);
  ctx.lineTo(hx + side * mw * 0.72, mouthY - curl * 0.75);
  ctx.stroke();

  // ombre sous l√®vre
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.lineWidth   = rq * 0.05;
  ctx.beginPath();
  ctx.moveTo(hx - mw * 0.85, mouthY + rq * 0.03);
  ctx.quadraticCurveTo(
    hx,
    mouthY + curl * 0.45,
    hx + mw * 0.8,
    mouthY + rq * 0.02
  );
  ctx.stroke();

  /* =========================
     SOUFFLE CHAUD (CACHE)
  ========================= */
  {
    const key = rq + "|" + hIdx;
    let glow = _infernoGradMouth.get(key);
    if (!glow){
      glow = ctx.createRadialGradient(
        hx + side * mw * 0.55,
        mouthY - rq*0.2,
        rq * 0.05,
        hx,
        mouthY,
        rq * 0.7
      );
      glow.addColorStop(0, `rgba(255,90,40,${0.18 + heat * 0.22})`);
      glow.addColorStop(1, "rgba(0,0,0,0)");
      _infernoGradMouth.set(key, glow);
      if (_infernoGradMouth.size > 120) _infernoGradMouth.clear();
    }

    ctx.fillStyle = glow;
    ctx.fillRect(
      hx - mw * 1.2,
      mouthY - curl * 1.2,
      mw * 2.4,
      curl * 2.4
    );
  }
}






/* =========================================================
   MOONY FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache OK
   ‚úî FIX MAJEUR : ctx.restore() GARANTI
========================================================= */

const _moonyHaloCache = new Map();

function drawMoonyFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è restore toujours garanti
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.5 + bh * 0.1;

  // pulsation douce (inchang√©e)
  const pulse = 0.85 + Math.sin(t * 1.8) * 0.15;

  /* =========================
     HALO LUNAIRE ARRI√àRE
  ========================= */
  const rY = bh * (isPreview ? 1.05 : 1.25);
  const rX = bw * 1.05;

  // cl√© stable (pas de float instable)
  const key = bw + "|" + bh + "|" + (isPreview ? 1 : 0);
  let g = _moonyHaloCache.get(key);

  if (!g){
    g = ctx.createRadialGradient(
      cx, cy, bh * 0.15,
      cx, cy, rY
    );
    g.addColorStop(0.0, "rgba(255,245,210,0.55)");
    g.addColorStop(0.45,"rgba(180,200,255,0.25)");
    g.addColorStop(1.0, "rgba(0,0,0,0)");

    if (_moonyHaloCache.size > 12) _moonyHaloCache.clear();
    _moonyHaloCache.set(key, g);
  }

  ctx.globalAlpha = pulse * (isPreview ? 0.55 : 0.85);
  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.ellipse(cx, cy, rX, rY, 0, 0, Math.PI * 2);
  ctx.fill();

  /* =========================
     PARTICULES ORBITALES
     (runtime uniquement)
  ========================= */
  if (!isPreview){
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = "rgba(255,250,230,0.95)";

    const baseA = t * 0.6;
    const r = bw * 0.55;

    // 4 particules fixes ‚Üí stable / zero random
    for (let i = 0; i < 4; i++){
      const a = baseA + i * (Math.PI * 0.5);
      const px = cx + Math.cos(a) * r;
      const py = cy + Math.sin(a) * r * 0.7;

      ctx.beginPath();
      ctx.arc(px, py, 1.1, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}





/* =========================================================
   FOREST FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache conserv√©
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
========================================================= */

const _forestGradCache = new Map();

function _getForestGrad(ctx, key, maker){
  let g = _forestGradCache.get(key);
  if (!g){
    g = maker();
    if (_forestGradCache.size > 24) _forestGradCache.clear();
    _forestGradCache.set(key, g);
  }
  return g;
}

function drawForestFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.82;

  const time = t * 0.001; // t = fxTime unifi√©
  const I = isPreview ? 0.65 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => Math.max(0, Math.min(1, v));
  const pulse = (s, ph=0)=> 0.5 + 0.5*Math.sin(time*s + ph);
  const hash = n => { const x = Math.sin(n*127.1)*43758.5453; return x - Math.floor(x); };

  function runeStroke(c, x, y, s, rot){
    c.save();
    c.translate(x,y);
    c.rotate(rot);
    c.lineWidth = 1.15 * I;
    c.lineCap = "round";
    c.beginPath();
    c.moveTo(-s*0.6, -s*0.25);
    c.lineTo( s*0.25, -s*0.25);
    c.lineTo( s*0.25,  s*0.55);
    c.moveTo(-s*0.2,  s*0.1);
    c.lineTo( s*0.6,  s*0.1);
    c.stroke();
    c.restore();
  }

  /* ===== 0) FOG / AURA ===== */
  const breathe = 0.86 + 0.14*Math.sin(time*1.7);
  const fog = _getForestGrad(
    ctx,
    `fog_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.10, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(220,255,235,${0.18*I})`);
      g.addColorStop(0.28, `rgba(130,220,170,${0.18*I})`);
      g.addColorStop(0.60, `rgba(35,110,75,${0.20*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = breathe;
  ctx.fillStyle = fog;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 1) VORTEX ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.55 * I;

  const swirl = _getForestGrad(
    ctx,
    `swirl_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0.00, "rgba(255,255,255,0)");
      g.addColorStop(0.35, `rgba(150,255,205,${0.18*I})`);
      g.addColorStop(0.70, `rgba(80,190,130,${0.14*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.save();
  ctx.translate(
    cx + Math.sin(time*1.2)*R*0.02,
    cy + Math.cos(time*1.0)*R*0.02
  );
  ctx.rotate(time*0.22);
  ctx.scale(1.05, 0.82);
  ctx.fillStyle = swirl;
  ctx.beginPath();
  ctx.arc(0, 0, R*1.05, 0, TAU);
  ctx.fill();
  ctx.restore();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 2) RING ===== */
  const ringRot = time * 0.35;
  const ringPulse = 0.75 + 0.25*pulse(2.6, 0.4);

  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = (isPreview ? 0.38 : 0.62) * I * ringPulse;
  ctx.lineWidth = 2.4 * I;

  const ringG = _getForestGrad(
    ctx,
    `ring_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.70, cx, cy, R*1.02);
      g.addColorStop(0.0, `rgba(170,255,220,${0.10*I})`);
      g.addColorStop(0.55,`rgba(110,235,170,${0.42*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.strokeStyle = ringG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.92, 0, TAU);
  ctx.stroke();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 3) RUNES ===== */
  const runeCount = isPreview ? 10 : 16;
  ctx.globalAlpha = (isPreview ? 0.42 : 0.70) * I;
  ctx.strokeStyle = "rgba(200,255,230,0.85)";
  for(let i=0;i<runeCount;i++){
    const a = ringRot + i*(TAU/runeCount);
    runeStroke(
      ctx,
      cx + Math.cos(a)*R*0.83,
      cy + Math.sin(a)*R*0.83*0.86,
      R*(0.06 + 0.01*Math.sin(time*3 + i)),
      a + Math.PI/2
    );
  }

  /* ===== 4) LUCIOLES ===== */
  ctx.globalCompositeOperation = "screen";
  const fireflies = isPreview ? 6 : 14;

  for(let i=0;i<fireflies;i++){
    const seed = i*19.73;
    const a = time*(0.7 + 0.03*i) + seed;
    const rr = R*(0.20 + 0.55*hash(seed+1));
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a*1.18)*rr*0.78;
    const tw = clamp01(0.25 + 0.75*pulse(5.0, i*1.4));
    const r = (isPreview ? 1.4 : 2.0) * (0.7 + tw) * I;

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.fillStyle = "rgba(210,255,235,1)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, TAU);
    ctx.fill();

    ctx.globalAlpha *= 0.25;
    ctx.beginPath();
    ctx.arc(x, y, r*3.0, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) CORE ===== */
  ctx.globalCompositeOperation = "screen";
  const corePulse = 0.55 + 0.45*Math.sin(time*3.1);

  const coreG = _getForestGrad(
    ctx,
    `core_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.46);
      g.addColorStop(0.0, `rgba(235,255,245,${0.22*corePulse*I})`);
      g.addColorStop(0.35,`rgba(170,255,215,${0.14*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = coreG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.46, 0, TAU);
  ctx.fill();

  ctx.restore();
}


/* =========================================================
   SOLAR FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */

const _solarGradCache = new Map();

function _getSolarGrad(key, maker){
  let g = _solarGradCache.get(key);
  if (!g){
    g = maker();
    if (_solarGradCache.size > 32) _solarGradCache.clear();
    _solarGradCache.set(key, g);
  }
  return g;
}

function drawSolarFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.80;

  const time = t * 0.001; // t = fxTime unifi√© (ms)
  const I = isPreview ? 0.65 : 1.0;

  const TAU = Math.PI*2;
  const clamp01 = v => Math.max(0, Math.min(1, v));
  const n1 = x => Math.sin(x)*0.5 + Math.sin(x*2.3+1.2)*0.25 + Math.sin(x*4.7+2.6)*0.15;

  /* ===== 0) SHIMMER ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.10 * I;

  const shimmer = _getSolarGrad(
    `shimmer_${bw}_${bh}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0,   "rgba(120,200,255,0.00)");
      g.addColorStop(0.5, "rgba(255,180,60,0.10)");
      g.addColorStop(1,   "rgba(255,120,20,0.00)");
      return g;
    }
  );

  ctx.fillStyle = shimmer;
  ctx.beginPath();
  ctx.arc(
    cx + Math.sin(time*2.1)*R*0.015,
    cy + Math.cos(time*1.7)*R*0.015,
    R*1.05, 0, TAU
  );
  ctx.fill();

  /* ===== 1) HALOS ===== */
  const breath = 0.78 + 0.22 * (0.5 + 0.5*Math.sin(time*2.2));

  const halo1 = _getSolarGrad(
    `halo1_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.12, cx, cy, R*1.05);
      g.addColorStop(0.00, `rgba(255,255,235,${0.75*I})`);
      g.addColorStop(0.30, `rgba(255,210,120,${0.55*I})`);
      g.addColorStop(0.62, `rgba(255,140,35,${0.32*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 0.95 * breath * (isPreview ? 0.75 : 1);
  ctx.fillStyle = halo1;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.05, 0, TAU);
  ctx.fill();

  const halo2 = _getSolarGrad(
    `halo2_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.35, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(255,180,70,${0.12*I})`);
      g.addColorStop(0.60, `rgba(255,120,25,${0.10*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = halo2;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 2) COURONNE ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.lineCap = "round";

  const coronaPts = isPreview ? 26 : 34;
  const rot = time*0.65;
  const ampBase = isPreview ? 0.055 : 0.085;

  for(let pass=0; pass<2; pass++){
    ctx.lineWidth = (pass===0 ? 2.6 : 1.2) * I;
    ctx.globalAlpha = (pass===0 ? 0.22 : 0.55) * I;
    ctx.strokeStyle = pass===0
      ? "rgba(255,150,35,0.85)"
      : "rgba(255,220,140,0.95)";

    ctx.beginPath();
    for(let i=0;i<=coronaPts;i++){
      const u = i/coronaPts;
      const ang = u*TAU + rot;
      const spiky = Math.max(0, n1(time*2.8 + u*12.0)) * (isPreview?0.5:1.0);
      const wave  = n1(time*1.6 + u*7.5);
      const amp = ampBase + spiky*0.06;
      const rr  = R * (0.90 + wave*amp + Math.sin(time*3.3 + u*TAU*2.0)*0.015);
      const x = cx + Math.cos(ang) * rr;
      const y = cy + Math.sin(ang) * rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  /* ===== 3) RAYONS ===== */
  const rays = isPreview ? 7 : 12;
  const rayBase = time*0.55;

  for(let i=0;i<rays;i++){
    const u = i/rays;
    const ang = rayBase + u*TAU;
    const pulseV = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*3.2 + i*1.7));
    const jitter = n1(time*5.0 + i*2.0) * 0.06;

    const len = R * (1.05 + pulseV*0.55);
    const inner = R * (0.45 + jitter*0.15);

    const x1 = cx + Math.cos(ang)*inner;
    const y1 = cy + Math.sin(ang)*inner;
    const x2 = cx + Math.cos(ang)*len;
    const y2 = cy + Math.sin(ang)*len;

    const g = _getSolarGrad(
      `ray_${bw}_${bh}_${i}`, // (identique)
      ()=> {
        const gg = ctx.createLinearGradient(x1,y1,x2,y2);
        gg.addColorStop(0.00, "rgba(255,230,160,0.00)");
        gg.addColorStop(0.25, `rgba(255,210,110,${0.65*I})`);
        gg.addColorStop(0.55, `rgba(255,140,45,${0.35*I})`);
        gg.addColorStop(1.00, "rgba(255,120,25,0.00)");
        return gg;
      }
    );

    ctx.strokeStyle = g;
    ctx.globalAlpha = (isPreview ? 0.42 : 0.75) * pulseV * I;
    ctx.lineWidth = (isPreview ? 2.0 : 2.8) * I;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.globalAlpha *= 0.75;
    ctx.lineWidth = (isPreview ? 0.9 : 1.3) * I;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(
      x2 + Math.cos(ang-0.9)*R*0.020,
      y2 + Math.sin(ang-0.9)*R*0.020
    );
    ctx.stroke();
  }

  /* ===== 4) PARTICULES ===== */
  const pCount = isPreview ? 6 : 14;
  ctx.fillStyle = "rgba(255,235,180,1)";
  for(let i=0;i<pCount;i++){
    const k = i + 1;
    const a = time*(0.9 + k*0.03) + k*1.85;
    const o = R * (0.52 + 0.18*Math.sin(time*1.3 + k));
    const sx = cx + Math.cos(a) * o;
    const sy = cy + Math.sin(a*1.06) * (o*0.78);
    const tw = 0.35 + 0.65*clamp01(0.5 + 0.5*Math.sin(time*6.2 + k*2.1));
    const rr = (isPreview ? 1.3 : 1.8) * I * (0.8 + tw*0.6);

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.beginPath();
    ctx.arc(sx, sy, rr, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) COEUR ===== */
  const corePulse = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*4.6));

  const core = _getSolarGrad(
    `core_${bw}_${bh}_${I}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.40);
      g.addColorStop(0.00, `rgba(255,255,255,${0.22*I*corePulse})`);
      g.addColorStop(0.25, `rgba(255,245,210,${0.18*I})`);
      g.addColorStop(1.00, "rgba(255,255,255,0)");
      return g;
    }
  );

  ctx.globalAlpha = (isPreview ? 0.55 : 0.9) * I;
  ctx.fillStyle = core;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.40, 0, TAU);
  ctx.fill();

  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}




/* =========================================================
   ARCTIC FX ‚Äî CLEAN / SAFE / MOBILE
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî pas de return apr√®s save()
========================================================= */

const _arcticGradCache = new Map();

function _getArcticGrad(key, maker){
  let g = _arcticGradCache.get(key);
  if (!g){
    g = maker();
    if (_arcticGradCache.size > 24) _arcticGradCache.clear();
    _arcticGradCache.set(key, g);
  }
  return g;
}

function drawArcticFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  /* ===== PREVIEW SAFE (ULTRA LIGHT) ===== */
  if (isPreview){
    c.save();
    c.globalAlpha = 0.6;
    c.fillStyle = "rgba(180,220,255,0.35)";
    c.beginPath();
    c.arc(bx + bw/2, by + bh/2, bw*0.6, 0, Math.PI*2);
    c.fill();
    c.restore();
    return;
  }

  c.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.58;

  /* ===== AURA POLAIRE ===== */
  const breath = Math.sin(time * 1.6) * 0.08;

  const halo = _getArcticGrad(
    `halo_${bw}_${bh}`,
    () => {
      const g = c.createRadialGradient(
        cx, cy, bw * 0.1,
        cx, cy, bw * (1.15 + breath)
      );
      g.addColorStop(0,   "rgba(250,255,255,0.95)");
      g.addColorStop(0.25,"rgba(210,240,255,0.65)");
      g.addColorStop(0.6, "rgba(140,200,255,0.28)");
      g.addColorStop(1,   "rgba(0,0,0,0)");
      return g;
    }
  );

  c.globalCompositeOperation = "screen";
  c.globalAlpha = 1;
  c.fillStyle = halo;
  c.beginPath();
  c.ellipse(cx, cy, bw * 1.15, bh * 1.35, 0, 0, Math.PI * 2);
  c.fill();

  c.globalCompositeOperation = "source-over";

  /* ===== FLOCON ===== */
  function drawSnowflake(x, y, r, rot, seed){
    c.save();
    c.translate(x, y);
    c.rotate(rot);

    const arms = 5 + (seed % 3);
    c.strokeStyle = "rgba(245,252,255,0.95)";
    c.lineWidth = 0.9 + Math.sin(seed) * 0.4;

    for (let a = 0; a < arms; a++){
      c.rotate((Math.PI * 2) / arms);
      const len = r * (0.6 + Math.sin(seed + a) * 0.35);

      c.beginPath();
      c.moveTo(0, 0);
      c.lineTo(0, len);

      if (Math.sin(seed * 1.7 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(len * 0.2, len * 0.65);
      }
      if (Math.cos(seed * 1.3 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(-len * 0.22, len * 0.7);
      }
      c.stroke();
    }

    c.restore();
  }

  /* ===== TEMP√äTE (OPTIMIS√âE) ===== */
  const stormCount = 18;
  for (let i = 0; i < stormCount; i++){
    const seed = i * 13.13;

    const x =
      cx +
      Math.sin(time * 1.7 + seed) * bw * (0.18 + Math.sin(seed) * 0.3) +
      Math.sin(time * 5.5 + seed) * 10;

    const y =
      cy +
      Math.cos(time * 1.3 + seed) * bh * (0.15 + Math.cos(seed) * 0.25) +
      Math.sin(time * 3.8 + seed) * 8;

    const r   = 2.2 + Math.sin(time * 3 + seed) * 1.4;
    const rot = time * (0.35 + Math.sin(seed) * 0.35) + seed;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== BLIZZARD (OPTIMIS√â) ===== */
  c.globalAlpha = 0.8;
  const blizzardCount = 22;

  for (let i = 0; i < blizzardCount; i++){
    const seed = i * 21.7;
    const rise = (time * 48 + seed * 26) % (bh * 1.3);

    const x =
      cx +
      Math.sin(rise * 0.018 + seed) * bw * (0.22 + Math.sin(seed) * 0.3) +
      Math.sin(time * 4.5 + seed) * 12;

    const y =
      by + bh - rise +
      Math.sin(time * 2.8 + seed) * 10;

    const r   = 2 + Math.sin(time * 3.6 + seed) * 1.5;
    const rot = time * (0.7 + Math.cos(seed) * 0.45) + seed * 0.6;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== GIVRE INF√âRIEUR ===== */
  c.globalAlpha = 0.85;
  c.strokeStyle = "rgba(235,250,255,1)";
  c.lineWidth = 1.5;

  for (let i = 0; i < 6; i++){
    const x = bx + bw * (0.22 + i * 0.11);
    const sway = Math.sin(time * 2 + i) * 3.5;
    const h = bh * (0.18 + Math.sin(time * 1.4 + i) * 0.08);

    c.beginPath();
    c.moveTo(x, by + bh * 0.78);
    c.lineTo(x + sway, by + bh * 0.78 + h);
    c.stroke();
  }

  c.restore();
}








/* =========================================================
   INFERNO FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî gradients toujours restaur√©s
========================================================= */

const _infernoGradCache = new Map();
function _g(key, fn){
  let v = _infernoGradCache.get(key);
  if(!v){
    v = fn();
    if(_infernoGradCache.size > 48) _infernoGradCache.clear();
    _infernoGradCache.set(key, v);
  }
  return v;
}

function drawInfernoFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  c.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.92;

  const I = isPreview ? 0.62 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => v<0?0:v>1?1:v;
  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453123);

  const turb = (u, k) =>
    Math.sin(u*3.1 + time*4.8 + k)*0.55 +
    Math.sin(u*7.7 - time*3.4 + k*1.9)*0.30 +
    Math.sin(u*13.3+ time*2.2 + k*2.7)*0.15;

  /* ===== DARK VIGNETTE ===== */
  c.globalCompositeOperation = "source-over";
  c.globalAlpha = (isPreview ? 0.12 : 0.18) * I;
  c.fillStyle = _g(`vig_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, R*0.25, cx, cy, R*1.35);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,1)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*1.35, 0, TAU);
  c.fill();

  /* ===== CORE ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.65 + 0.35*Math.sin(time*5.2);
  c.globalAlpha = (isPreview ? 0.70 : 1.0) * corePulse * I;
  c.fillStyle = _g(`core_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.60);
    g.addColorStop(0.00, "rgba(255,255,255,0.28)");
    g.addColorStop(0.18, "rgba(255,210,150,0.35)");
    g.addColorStop(0.38, "rgba(255,120,55,0.42)");
    g.addColorStop(0.62, "rgba(190,25,20,0.34)");
    g.addColorStop(1.00, "rgba(0,0,0,0)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*0.62, 0, TAU);
  c.fill();

  /* ===== SEAL ===== */
  const sealRot = time*0.55;
  const sealR = R*0.74;
  const ringR = R*0.86;

  c.globalAlpha = (isPreview ? 0.38 : 0.62) * I;
  c.lineWidth = 2.1 * I;
  c.strokeStyle = "rgba(255,70,40,0.55)";
  c.setLineDash([10*I,8*I]);
  c.lineDashOffset = -time*55;
  c.beginPath();
  c.arc(cx, cy, ringR, 0, TAU);
  c.stroke();
  c.setLineDash([]);

  function starPath(r, rot){
    const idx = [0,2,4,1,3,0];
    c.beginPath();
    for(let j=0;j<idx.length;j++){
      const i = idx[j];
      const a = rot + i*(TAU/5) - Math.PI/2;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r*0.94;
      if(j===0) c.moveTo(x,y); else c.lineTo(x,y);
    }
  }

  c.globalAlpha = (isPreview ? 0.42 : 0.78) * I;
  c.lineWidth = 2.6 * I;
  c.strokeStyle = "rgba(255,180,140,0.45)";
  starPath(sealR, sealRot);
  c.stroke();

  c.globalAlpha = (isPreview ? 0.28 : 0.55) * I;
  c.lineWidth = 1.6 * I;
  c.strokeStyle = "rgba(255,60,30,0.85)";
  starPath(sealR*0.98, -sealRot*0.7);
  c.stroke();

  /* ===== FLAME CROWN ===== */
  const tongues = isPreview ? 9 : 16;
  const baseR = R*0.88;
  c.globalCompositeOperation = "screen";

  for(let i=0;i<tongues;i++){
    const u = i/tongues;
    const a = u*TAU + time*0.95;
    const n = turb(u*TAU, i);
    const spike = Math.max(0,n) * (isPreview?0.35:0.75);

    const rr = baseR*(0.92 + 0.07*Math.sin(time*2.6+i) + spike*0.22);
    const fx = cx + Math.cos(a)*rr;
    const fy = cy + Math.sin(a)*rr*0.78;

    const h = R*(0.22 + 0.18*(0.5+0.5*Math.sin(time*6+i*0.9)) + spike*0.35);
    const w = R*(0.06 + 0.03*(0.5+0.5*Math.sin(time*4.2+i*1.3)));

    const grad = c.createLinearGradient(fx, fy, fx, fy-h);
    grad.addColorStop(0,"rgba(255,90,20,0.75)");
    grad.addColorStop(0.25,"rgba(255,170,60,0.60)");
    grad.addColorStop(0.55,"rgba(255,240,190,0.34)");
    grad.addColorStop(1,"rgba(255,255,255,0)");

    c.globalAlpha = (isPreview ? 0.40 : 0.75) * I;
    c.fillStyle = grad;

    const bend = (Math.sin(time*7.5+i*1.4)*0.55 + n*0.35) * w;

    c.beginPath();
    c.moveTo(fx,fy);
    c.bezierCurveTo(
      fx+w+bend, fy-h*0.25,
      fx+w*0.25, fy-h*0.92,
      fx+bend*0.25, fy-h
    );
    c.bezierCurveTo(
      fx-w*0.25, fy-h*0.92,
      fx-w+bend*0.2, fy-h*0.25,
      fx,fy
    );
    c.fill();
  }

  /* ===== EMBERS ===== */
  const embers = isPreview ? 7 : 18;
  for(let i=0;i<embers;i++){
    const seed=i*33.7;
    const a=time*(0.9+hash(seed)*1.2)+seed;
    const rr=R*(0.22+0.68*hash(seed+1))+Math.sin(time*2+i)*R*0.03;

    const x=cx+Math.cos(a)*rr;
    const y=cy+Math.sin(a*1.05)*rr*0.78;

    const tw=0.35+0.65*(0.5+0.5*Math.sin(time*7+i*1.7));
    const r=(isPreview?1.4:2.6)*(0.65+tw)*I;

    if(!isPreview){
      c.globalAlpha=0.16*tw*I;
      c.fillStyle="rgba(255,140,70,1)";
      c.beginPath(); c.arc(x-Math.cos(a)*12,y-Math.sin(a)*12,r*2.2,0,TAU); c.fill();
    }

    c.globalAlpha=(isPreview?0.55:0.85)*tw*I;
    c.fillStyle="rgba(255,220,170,1)";
    c.beginPath(); c.arc(x,y,r,0,TAU); c.fill();

    c.globalAlpha*=0.22;
    c.beginPath(); c.arc(x,y,r*3,0,TAU); c.fill();
  }

  c.globalCompositeOperation="source-over";
  c.globalAlpha=1;
  c.restore();
}


/* =========================================================
   NEON FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî clip toujours restaur√©
========================================================= */

const _neonGradCache = new Map();
function _ng(key, fn){
  let v = _neonGradCache.get(key);
  if(!v){
    v = fn();
    if(_neonGradCache.size > 64) _neonGradCache.clear();
    _neonGradCache.set(key, v);
  }
  return v;
}

function drawNeonFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const time = t * 0.001;          // t = fxTime (ms)
  const I = isPreview ? 0.7 : 1.0;
  const TAU = Math.PI * 2;

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.85;

  c.save();

  c.beginPath();
  c.arc(cx, cy, R*0.95, 0, TAU);
  c.clip();

  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453);

  /* ===== STREAKS ===== */
  const streaks = isPreview ? 4 : 9;

  for(let i=0;i<streaks;i++){
    const seed = i*21.7;
    const life = fract(time*0.6 + hash(seed));

    const angle = seed + life*TAU;
    const dist  = R*(1.3 - life*1.6);

    const x = cx + Math.cos(angle)*dist;
    const y = cy + Math.sin(angle)*dist*0.75;

    const dx = Math.cos(angle);
    const dy = Math.sin(angle)*0.75;

    const L = R*(0.18 + 0.25*(1-life));

    const k = `${(x*0.1)|0}_${(y*0.1)|0}_${(L*10)|0}_${isPreview?1:0}`;
    const grad = _ng(k, ()=>{
      const g = c.createLinearGradient(x,y, x - dx*L, y - dy*L);
      g.addColorStop(0.00, "rgba(255,255,255,0.95)");
      g.addColorStop(0.35, "rgba(0,255,255,0.85)");
      g.addColorStop(1.00, "rgba(0,255,255,0)");
      return g;
    });

    c.strokeStyle = grad;
    c.lineWidth = (isPreview ? 1.4 : 2.2) * I;
    c.globalAlpha = (1-life) * (isPreview ? 0.7 : 1.0);

    c.beginPath();
    c.moveTo(x,y);
    c.lineTo(x - dx*L, y - dy*L);
    c.stroke();
  }

  /* ===== CORE FLASH ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.5 + 0.5*Math.sin(time*6.2);
  c.globalAlpha = (isPreview ? 0.25 : 0.45) * corePulse * I;

  c.fillStyle = _ng(`core_${bw}_${bh}_${isPreview?1:0}`, ()=>{
    const g = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.35);
    g.addColorStop(0.00, "rgba(255,255,255,0.4)");
    g.addColorStop(0.35, "rgba(0,255,255,0.35)");
    g.addColorStop(1.00, "rgba(0,0,0,0)");
    return g;
  });

  c.beginPath();
  c.arc(cx, cy, R*0.35, 0, TAU);
  c.fill();

  c.restore();
}



/* =========================================================
   VOIDWALKER FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */

const _voidGradCache = new Map();
function _vg(key, fn){
  let v = _voidGradCache.get(key);
  if(!v){
    v = fn();
    if(_voidGradCache.size > 32) _voidGradCache.clear();
    _voidGradCache.set(key, v);
  }
  return v;
}

function drawVoidwalkerFrontFX(c, bx, by, bw, bh, t){
  if (skipHeavyFX) return;

  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw,bh)*0.46;

  // jitter d√©terministe (t en ms)
  const jx = (((t*0.012)|0)&1 ? -1 : 1) * 1.2;
  const jy = (((t*0.009)|0)&1 ?  1 : -1) * 0.8;

  const pulse = 0.85 + 0.15*Math.sin(t*0.0034);

  c.save();

  c.globalCompositeOperation = "screen";
  c.globalAlpha = 0.55 * pulse;

  c.strokeStyle = _vg(`halo_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, R*0.6, cx, cy, R*1.1);
    g.addColorStop(0, "rgba(200,160,255,0)");
    g.addColorStop(0.55,"rgba(170,120,255,0.45)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    return g;
  });

  c.lineWidth = 1.2;
  c.beginPath();
  c.arc(cx + jx, cy + jy, R, 0, Math.PI*2);
  c.stroke();

  c.globalCompositeOperation = "source-over";
  c.globalAlpha = 0.95;
  c.strokeStyle = "rgba(255,255,255,1)";
  c.lineWidth = 1;

  for(let i=0;i<2;i++){
    const ex = cx + (i===0?-5:5);
    const ey = cy + jy*0.4;
    c.beginPath();
    c.moveTo(ex, ey);
    c.lineTo(ex + jx*6, ey + jy*3);
    c.stroke();
  }

  c.restore();
}

function drawVoidwalkerFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw, bh) * 0.72;

  const gk = (((t*0.006)|0)&1) ? 1 : -1;

  c.save();

  /* ===== GLITCH RING ===== */
  c.globalCompositeOperation = "screen";
  c.globalAlpha = isPreview ? 0.55 : 0.9;
  c.strokeStyle = "rgba(200,150,255,0.85)";
  c.lineWidth = 1.4;

  for(let i=0;i<10;i++){
    if(i%4===0) continue;
    const a = (i/10)*Math.PI*2;
    const rr = R*0.56 + gk*2;
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a)*rr*0.75;
    c.beginPath();
    c.rect(x-3.5, y-3.5, 7, 7);
    c.stroke();
  }

  /* ===== GLOW ===== */
  c.globalAlpha = isPreview ? 0.25 : 0.45;
  c.fillStyle = _vg(`fog_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, R*0.2, cx, cy, R*1.2);
    g.addColorStop(0, "rgba(160,110,255,0.18)");
    g.addColorStop(0.6,"rgba(90,40,200,0.14)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*1.2, 0, Math.PI*2);
  c.fill();

  /* ===== BUG PARTICLES ===== */
  c.globalCompositeOperation = "source-over";
  c.globalAlpha = 0.85;
  c.fillStyle = "rgba(255,255,255,1)";

  const p = isPreview ? 3 : 6;
  for(let i=0;i<p;i++){
    const a = t*0.0015 + i*2.3;
    const rr = R*(0.35 + ((t*0.001+i)%1)*0.55);
    const px = cx + Math.cos(a)*rr;
    const py = cy + Math.sin(a)*rr*0.6;

    c.fillRect(px, py, 2, 2);

    if(!isPreview){
      c.globalAlpha = 0.25;
      c.fillRect(px-1, py-1, 4, 4);
      c.globalAlpha = 0.85;
    }
  }

  c.restore();
}







// =====================================================
// OBSTACLE FX CACHES (ANTI-LAG / STABLE)
// =====================================================
const _obFX = {
  rectBody: new Map(),
  rectBeamTop: new Map(),
  rectBeamBot: new Map(),
  rectHaloTop: new Map(),
  rectHaloBot: new Map(),

  circleHalo: new Map(),
  circleRing: new Map(),
  circleCore: new Map(),

  rotbarBeam: new Map(),

  turretBody: new Map(),
  turretEye: new Map(),

  bulletHalo: new Map()
};

function _qKey(v, step = 0.5){
  return (Math.round(v / step) * step).toFixed(2);
}
function _hash01(a){
  return (Math.sin(a) * 43758.5453123) % 1;
}
function _hash01pos(a){
  const v = _hash01(a);
  return v < 0 ? v + 1 : v;
}

// =====================================================
// PERF HELPERS
// =====================================================
let fxFrame = 0;

function _getArcPath(r){
  const rq = Math.max(1, Math.round(r * 2) / 2);
  const key = rq.toFixed(2);
  let p = _arcPathCache.get(key);
  if (!p){
    p = new Path2D();
    p.arc(0, 0, rq, 0, Math.PI * 2);
    _arcPathCache.set(key, p);
  }
  return p;
}

// rounded-rect Path2D (SAFE iOS) ‚Äî no roundRect()
function _getRectPath(w, h, r = 8){
  const wi = w | 0, hi = h | 0;
  const ri = Math.max(0, Math.min(r, Math.min(wi, hi) * 0.5)) | 0;
  const key = `${wi}x${hi}r${ri}`;

  let p = _rectPathCache.get(key);
  if (p) return p;

  p = new Path2D();

  if (ri <= 0){
    p.rect(0, 0, wi, hi);
    _rectPathCache.set(key, p);
    return p;
  }

  const rr = ri;
  const x0 = 0, y0 = 0, x1 = wi, y1 = hi;

  p.moveTo(x0 + rr, y0);
  p.lineTo(x1 - rr, y0);
  p.arcTo(x1, y0, x1, y0 + rr, rr);

  p.lineTo(x1, y1 - rr);
  p.arcTo(x1, y1, x1 - rr, y1, rr);

  p.lineTo(x0 + rr, y1);
  p.arcTo(x0, y1, x0, y1 - rr, rr);

  p.lineTo(x0, y0 + rr);
  p.arcTo(x0, y0, x0 + rr, y0, rr);

  p.closePath();

  _rectPathCache.set(key, p);
  return p;
}
const CULL_PAD = 160;
// =====================================================
// DRAW OBSTACLES (CROP SAFE + iOS SAFE)
// =====================================================
/* =====================================================
   DRAW OBSTACLES (OPTIMIS√â : CACHE FIX & INT KEYS)
===================================================== */
function drawObstacles(){
  fxFrame++;
  const fxSkip = (fxFrame & 1);

  // Temps moteur
  const tNow = renderTime;
  const sin4 = Math.sin(tNow * 4);

  // Limites de vue (Culling)
  const VIEW_L = -OFF_X;
  const VIEW_R = WORLD_W + OFF_X;

  for (let oi = 0, ol = obstacles.length; oi < ol; oi++){
    const ob = obstacles[oi];

    // =============================
    // RECT / MOVING / SWEEPER
    // =============================
    if (ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "sweeper"){
      const x = (ob.x || 0), y = ob.y, w = ob.width, h = ob.height;

      // Culling
      if (x + w < VIEW_L - CULL_PAD || x > VIEW_R + CULL_PAD) continue;

      const pulse = 0.85 + sin4 * 0.15;
      const seed  = (ob._seed ??= (x*0.13 + y*0.27 + w*0.19 + h*0.31));
      const isTop = (ob.type === "top");

      // üî• OPTIMISATION : Cl√© Enti√®re (Integer) pour le cache
      const hInt = Math.round(h); 
      const wInt = Math.round(w);

      ctx.save();
      ctx.translate(x, y);

      // --- BODY ---
      // On utilise hInt au lieu de h pour le cache
      let body = _obFX.rectBody.get(hInt);
      if (!body){
        body = ctx.createLinearGradient(0,0,0,hInt);
        body.addColorStop(0,"rgba(8,14,32,0.95)");
        body.addColorStop(1,"rgba(2,6,16,0.95)");
        _obFX.rectBody.set(hInt, body);
      }
      
      // Path cache optimis√©
      const rectPath = _getRectPath(w, h, 8);
      ctx.fillStyle = body;
      ctx.fill(rectPath);

      // --- BEAM ---
      ctx.globalCompositeOperation = "screen";
      const beamCache = isTop ? _obFX.rectBeamTop : _obFX.rectBeamBot;
      
      // Cache sur hInt
      let beam = beamCache.get(hInt);
      if (!beam){
        beam = ctx.createLinearGradient(0,0,0,hInt);
        beam.addColorStop(0,"rgba(255,255,255,0.04)");
        beam.addColorStop(0.25, isTop ? "rgba(120,220,255,0.95)" : "rgba(255,120,220,0.95)");
        beam.addColorStop(0.5,  isTop ? "rgba(200,245,255,1)"     : "rgba(255,170,230,1)");
        beam.addColorStop(0.75, isTop ? "rgba(120,220,255,0.95)" : "rgba(255,120,220,0.95)");
        beam.addColorStop(1,"rgba(255,255,255,0.04)");
        beamCache.set(hInt, beam);
      }
      
      // ShadowBlur est lourd : on le r√©duit l√©g√®rement si mobile
      ctx.shadowColor = isTop ? "rgba(140,240,255,1)" : "rgba(255,140,230,1)";
      ctx.shadowBlur  = (FXQuality.isMobile ? 12 : 34) * pulse; 
      
      ctx.fillStyle   = beam;
      ctx.fillRect(w * 0.32, 0, w * 0.36, h);

      // --- HALO ---
      // Cl√© combin√©e enti√®re
      const haloKey = (wInt << 16) | hInt;
      const haloCache = isTop ? _obFX.rectHaloTop : _obFX.rectHaloBot;
      
      let halo = haloCache.get(haloKey);
      if (!halo){
        // Cr√©ation unique
        halo = ctx.createRadialGradient(w/2, h/2, w*0.2, w/2, h/2, w*1.2);
        halo.addColorStop(0, isTop ? "rgba(120,220,255,0.45)" : "rgba(255,120,220,0.45)");
        halo.addColorStop(1,"rgba(0,0,0,0)");
        haloCache.set(haloKey, halo);
      }
      
      ctx.shadowBlur = 0; // Reset shadow pour le halo
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = halo;
      ctx.fillRect(-w, 0, w * 3, h);
      ctx.globalAlpha = 1;

      // --- MICRO SPARKS (L√©ger) ---
      if (!fxSkip && _hash01pos(seed + tNow * 2.3) < 0.08){
        const ry = _hash01pos(seed * 3.17 + tNow * 5.1) * h;
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = "#fff";
        ctx.fillRect(w * 0.4, ry, w * 0.2, 2);
        ctx.globalAlpha = 1;
      }

      // --- OUTLINE ---
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = "rgba(200,235,255,0.22)";
      ctx.lineWidth = 1.2;
      ctx.stroke(rectPath);

      ctx.restore();
      continue;
    }

    // =============================
    // CIRCLE
    // =============================
    if (ob.kind === "circle"){
      const r = ob.r;
      if (ob.x + r < VIEW_L - 40 || ob.x - r > VIEW_R + 40) continue;

      ctx.save();
      ctx.translate(ob.x, ob.y);

      // Cache Core (Cl√© arrondie)
      const rInt = Math.round(r);
      let core = _obFX.circleCore.get(rInt);
      if (!core){
        core = ctx.createRadialGradient(0,0,0, 0,0,r);
        core.addColorStop(0.0, "rgba(0,0,0,1)");
        core.addColorStop(0.55,"rgba(0,0,0,0.95)");
        core.addColorStop(0.8, "rgba(0,0,0,0.6)");
        core.addColorStop(1.0, "rgba(0,0,0,0)");
        _obFX.circleCore.set(rInt, core);
      }

      ctx.fillStyle = core;
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fill();

      // Halo Soft
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = 0.25;

      let halo = _obFX.circleHalo.get(rInt);
      if (!halo){
        halo = ctx.createRadialGradient(0,0,r*0.6, 0,0,r*1.8);
        halo.addColorStop(0,"rgba(120,180,255,0.25)");
        halo.addColorStop(1,"rgba(0,0,0,0)");
        _obFX.circleHalo.set(rInt, halo);
      }

      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(0,0,r*1.8,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
      continue;
    }

    // =============================
    // ROTBAR
    // =============================
    if (ob.kind === "rotbar"){
      const w = (ob.half || 7) * 2;
      const h = ob.len * 2;
      const approxX = ob.cx;
      const approxR = h * 0.55;
      
      if (approxX + approxR < VIEW_L - CULL_PAD || approxX - approxR > VIEW_R + CULL_PAD) continue;

      // Cl√© enti√®re
      const key = Math.round(h);

      ctx.save();
      ctx.translate(ob.cx, ob.cy);
      ctx.rotate(ob.angle);

      ctx.globalCompositeOperation = "screen";
      ctx.shadowColor = "rgba(120,220,255,0.95)";
      ctx.shadowBlur  = FXQuality.isMobile ? 12 : 26; // R√©duit sur mobile

      let beam = _obFX.rotbarBeam.get(key);
      if (!beam){
        beam = ctx.createLinearGradient(0, -h/2, 0, h/2);
        beam.addColorStop(0,"rgba(255,255,255,0.08)");
        beam.addColorStop(0.25,"rgba(120,220,255,0.9)");
        beam.addColorStop(0.5,"rgba(180,90,255,0.7)");
        beam.addColorStop(0.75,"rgba(120,220,255,0.9)");
        beam.addColorStop(1,"rgba(255,255,255,0.08)");
        _obFX.rotbarBeam.set(key, beam);
      }

      ctx.fillStyle = beam;
      ctx.fillRect(-w/2, -h/2, w, h);

      ctx.restore();
      continue;
    }

    // =============================
    // TURRET
    // =============================
    if (ob.kind === "turret"){
      const x = ob.x, y = ob.y, w = ob.w, h = ob.h;
      if (x + w < VIEW_L - CULL_PAD || x > VIEW_R + CULL_PAD) continue;

      const wInt = Math.round(w);
      const hInt = Math.round(h);
      const key = (wInt << 16) | hInt;

      ctx.save();
      ctx.translate(x, y - h/2);

      let body = _obFX.turretBody.get(key);
      if (!body){
        body = ctx.createLinearGradient(0,0,w,h);
        body.addColorStop(0,"rgba(10,18,40,0.95)");
        body.addColorStop(1,"rgba(4,8,18,0.95)");
        _obFX.turretBody.set(key, body);
      }
      // Utilisation du cache de path rectangulaire
      const turretPath = _getRectPath(w, h, 8);
      ctx.fillStyle = body;
      ctx.fill(turretPath);

      ctx.globalCompositeOperation = "screen";
      
      // Cache Eye
      let eye = _obFX.turretEye.get(20);
      if (!eye){
        eye = ctx.createRadialGradient(0,0,2, 0,0,20);
        eye.addColorStop(0,"rgba(255,255,255,0.95)");
        eye.addColorStop(0.4,"rgba(120,220,255,0.85)");
        eye.addColorStop(1,"rgba(0,0,0,0)");
        _obFX.turretEye.set(20, eye);
      }
      ctx.fillStyle = eye;
      ctx.beginPath();
      ctx.arc(w * 0.82, h / 2, 20, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalCompositeOperation = "source-over";
      ctx.restore();
      continue;
    }
  }

  // =============================
  // BULLETS (Optimis√©)
  // =============================
  for (let i = 0, l = bullets.length; i < l; i++){
    const b = bullets[i];
    if (b.x < VIEW_L - 80 || b.x > VIEW_R + 80) continue;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.globalCompositeOperation = "screen";

    const key = _qKey(b.r, 0.5); // Arrondi plus large
    let g = _obFX.bulletHalo.get(key);
    if (!g){
      g = ctx.createRadialGradient(0,0,0, 0,0, b.r + 12);
      g.addColorStop(0,"rgba(255,255,255,0.95)");
      g.addColorStop(0.35,"rgba(120,220,255,0.85)");
      g.addColorStop(0.75,"rgba(180,90,255,0.35)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      _obFX.bulletHalo.set(key, g);
    }

    ctx.fillStyle = g;
    ctx.fill(_getArcPath(b.r + 12));

    ctx.restore();
  }
}




const _particleColCache = new Map();

function drawParticles(){
  for (let i = 0; i < particles.length; i++){
    const p = particles[i];

    const lifeRatio = 1 - (p.age / p.life);
    if (lifeRatio <= 0) continue;

    // quantize alpha (0..15)
    const aQ = Math.max(0, Math.min(15, (lifeRatio * 15) | 0));
    const alpha = 0.2 + 0.7 * (aQ / 15);

    // cache couleur
    let colMap = _particleColCache.get(p.col);
    if (!colMap){
      colMap = new Map();
      _particleColCache.set(p.col, colMap);
    }

    let fill = colMap.get(aQ);
    if (!fill){
      // extraction RGB safe (une seule fois)
      const rgb = p.col.slice(0, p.col.lastIndexOf(","));
      fill = rgb + "," + alpha.toFixed(3) + ")";
      colMap.set(aQ, fill);

      if (colMap.size > 20) colMap.clear();
    }

    ctx.fillStyle = fill;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.sz * lifeRatio, 0, Math.PI * 2);
    ctx.fill();
  }
}


// =========================
// EXPLOSION FX (OPTIMIS√â)
// =========================

// cache gradients bloom
let _bloomGrad = null;
let _bloomOx = 0;
let _bloomOy = 0;

function drawExplosionFX(){
  const ox = deathOrigin
    ? deathOrigin.x
    : player.x + player.width / 2;

  const oy = deathOrigin
    ? deathOrigin.y
    : player.y + player.height / 2;

  // ===== SHOCKWAVE =====
  if (shockwave){
    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${shockwave.alpha})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ox, oy, shockwave.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  // ===== BLOOM =====
  if (bloom){
    ctx.save();

    const r = 140;

    // recr√©ation SAFE (seulement si n√©cessaire)
    if (!_bloomGrad || _bloomOx !== ox || _bloomOy !== oy){
      _bloomGrad = ctx.createRadialGradient(ox, oy, 0, ox, oy, r);
      _bloomGrad.addColorStop(0, "rgba(255,255,255,1)");
      _bloomGrad.addColorStop(1, "rgba(255,255,255,0)");
      _bloomOx = ox;
      _bloomOy = oy;
    }

    ctx.globalAlpha = bloom.a;
    ctx.fillStyle = _bloomGrad;
    ctx.beginPath();
    ctx.arc(ox, oy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}


  

/* ================= BACKGROUND NOISE (GPU SAFE) ================= */
function drawBackgroundNoise(){
  if (!noiseCanvas) return;

  const a = fps >= 58 ? 0.04 : fps >= 52 ? 0.025 : 0;
  if (a <= 0) return;

  const sw = canvas.width  / currentDPR;
  const sh = canvas.height / currentDPR;

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  ctx.globalAlpha = a;

  ctx.drawImage(
    noiseCanvas,
    0, 0, noiseCanvas.width, noiseCanvas.height,
    0, 0, sw, sh
  );

  ctx.restore();
}


/* =========================
   GRADIENT CACHES (GLOBAL)
========================== */
let hazeGradientCache = null;
let hazeH = 0;

let fadeGradientCache = null;
let fadeH = 0;

let coinGradientCache = null;
let coinGradR = 0;

function draw(){

  /* =================================================
     1Ô∏è‚É£ RESET ABSOLU
  ================================================= */
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";

  /* =================================================
     2Ô∏è‚É£ FOND √âCRAN
  ================================================= */
  ctx.fillStyle = "#05060a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  /* =================================================
     3Ô∏è‚É£ DPR ‚Äî SCREEN SPACE
  ================================================= */
  ctx.setTransform(currentDPR, 0, 0, currentDPR, 0, 0);

  /* =================================================
     4Ô∏è‚É£ FX √âCRAN (FULLSCREEN)
  ================================================= */
  // drawBackgroundNoise(); // D√©sactiv√© pour les perfs

  /* =================================================
     5Ô∏è‚É£ CAMERA ‚Äî BACKGROUND
  ================================================= */
  const camX = cameraOffsetX + (shakeX || 0);
  const camY = cameraOffsetY + (shakeY || 0);

  ctx.save();
  ctx.translate(camX, camY);
  ctx.scale(cameraScale, cameraScale);

  drawBG(bgScroll);

  ctx.restore();

  /* =================================================
     6Ô∏è‚É£ CAMERA ‚Äî GAMEPLAY
  ================================================= */
  ctx.save();
  ctx.translate(camX, camY);
  ctx.scale(cameraScale, cameraScale);

  const now = renderTime;

  /* =================================================
     üå´Ô∏è HAZE (Brouillard bas) ‚Äî INFINI
  ================================================= */
  if (!hazeGradientCache || hazeH !== BASE_H){
    hazeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.72, 0, BASE_H);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.32)");
    hazeGradientCache = g;
  }
  ctx.fillStyle = hazeGradientCache;
  
  // ‚úÖ CORRECTION : On dessine TR√àS large (-1000 √† +2000) pour couvrir tout ratio
  ctx.fillRect(-1000, BASE_H * 0.72, BASE_W + 2000, BASE_H * 0.28);

  /* =================================================
     üåò FADE BAS (Ombre bas √©cran) ‚Äî INFINI
  ================================================= */
  if (!fadeGradientCache || fadeH !== BASE_H){
    fadeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.45, 0, BASE_H);
    g.addColorStop(0, "rgba(10,18,40,0)");
    g.addColorStop(1, "rgba(10,18,40,0.22)");
    fadeGradientCache = g;
  }
  ctx.fillStyle = fadeGradientCache;
  
  // ‚úÖ CORRECTION : Largeur infinie
  ctx.fillRect(-1000, BASE_H * 0.45, BASE_W + 2000, BASE_H * 0.55);

  /* =================================================
     ü™ô COINS
  ================================================= */
  if (coins.length){
    const baseR = Math.round(coins[0].r * 1.15 * 2) / 2;

    if (!coinGradientCache || coinGradR !== baseR){
      coinGradR = baseR;
      const g = ctx.createRadialGradient(
        -baseR * 0.4, -baseR * 0.4, baseR * 0.3,
        0, 0, baseR
      );
      g.addColorStop(0.0, "rgba(255,245,180,1)");
      g.addColorStop(0.4, "rgba(255,210,90,1)");
      g.addColorStop(0.75,"rgba(230,165,30,1)");
      g.addColorStop(1.0, "rgba(160,110,20,1)");
      coinGradientCache = g;
    }

    const coinBudget = (fps < 58) ? 6 : 9999;
    let drawn = 0;

    for (const c of coins){
      if (++drawn > coinBudget) break;

      ctx.save();
      ctx.translate(c.x, c.y);
      const r = c.r * 1.15;

      ctx.fillStyle = coinGradientCache;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.arc(-r * 0.35, -r * 0.35, r * 0.25, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.strokeStyle = "rgba(255,200,80,0.55)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }
  }

  /* =================================================
     üéÆ GAMEPLAY OBJECTS
  ================================================= */
  drawObstacles(now);
  drawPlayerParticles(ctx);
  drawPlayer();
  drawParticles();
  drawExplosionFX();

  /* =================================================
     üîì FIN GAMEPLAY
  ================================================= */
  ctx.restore();

  /* =================================================
     7Ô∏è‚É£ RESET FINAL
  ================================================= */
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}
// ================= LOOP (AAA STABLE / LOW JITTER) =================

// ================= LOOP (AAA STABLE / MOBILE SAFE) =================

// √©tats globaux
let loopStarted = false;
let accTime   = 0;
let drawAcc  = 0;
let fxTick   = 0;
let lastTS   = 0;
// ================= FPS TRACKING =================
let fps = 60;

// temps moteur (UNIQUE SOURCE)
let renderTime = 0;

// constantes
const STEP    = 1000 / 60;   // logique fixe
const DRAW_60 = 1000 / 60;
const DRAW_30 = 1000 / 30;
const MAX_DRAWS_PER_FRAME = 2; // üîí anti-freeze mobile


function loop(ts){
  if (!loopStarted) return;

  // init frame
  if (!lastTS) lastTS = ts;

  let delta = ts - lastTS;
  lastTS = ts;

  // clamp anti-spike (mobile / onglet)
  if (delta > 50) delta = 50;
  if (delta < 0)  delta = 0;
// ================= FPS COMPUTE (STABLE) =================
if (delta > 0) {
  fps = Math.min(60, 1000 / delta);
}

  // ‚è±Ô∏è TEMPS MOTEUR MONOTONE
  renderTime += delta;
fxTime = renderTime * 0.001;
  // ================= UPDATE LOGIQUE FIXE =================
  accTime += delta;
  while (accTime >= STEP){
    update(STEP, renderTime);
    accTime -= STEP;
  }

  // ================= FX QUALITY (THROTTLED) =================
  fxTick += delta;
  if (fxTick >= 120){
    FXQuality.update(renderTime);
    updateFXState();
    fxTick = 0;
  }

  // ================= DRAW SAFE =================
  drawAcc += delta;

  const drawStep = (fps < 58) ? DRAW_30 : DRAW_60;
  let draws = 0;

  while (drawAcc >= drawStep && draws < MAX_DRAWS_PER_FRAME){
    drawAcc -= drawStep;
    draw();
    draws++;
  }

  // backlog trop grand ‚Üí drop hard (√©vite freeze iOS)
  if (draws === MAX_DRAWS_PER_FRAME){
    drawAcc = 0;
  }

  requestAnimationFrame(loop);
}


// ================= START / STOP =================

function startLoop(){
  if (loopStarted) return;

  // üîí mobile = tier forc√©
  if (FXQuality.isMobile){
    FXQuality.setForceTier(0);
  }

  loopStarted = true;
  lastTS     = 0;
  accTime    = 0;
  drawAcc    = 0;
  fxTick     = 0;
  renderTime = 0;

  requestAnimationFrame(loop);
}

function stopLoop(){
  loopStarted = false;
}


// ================= PAUSE / RESUME (ZERO JITTER) =================

function pauseLoop(){
  gameRunning = false;
  stopLoop(); // RAF OFF COMPLET
}

function resumeLoop(){
  gameRunning = true;
  startLoop(); // RAF ON PROPRE
}







// ================= INPUT JET =================
function jetStart(){
  if (gameState !== "playing") return;
  jetOn = true;
}
function jetStop(){
  jetOn = false;
}


// ================= RUN RESET =================
function resetRun(){
  player.x = 100;
  player.y = BASE_H / 2;            // ‚úÖ pas HEIGHT (source d'√©cart selon layout)
  player.width  = BASE_PLAYER_W;
  player.height = BASE_PLAYER_H;
  player.vy = 0;

  jetOn = false;
if (playerParticles) playerParticles.length = 0;

  obstacles.length = 0;
  coins.length = 0;
  bullets.length = 0;
  particles.length = 0;

  score = 0;
  coinsCollected = 0;
  combo = 1;
  overdriveActive = false;
  overdriveTimer = 0;

  lastCoinTime = 0;
  lastSpawn = 0;
  obstacleSpeed = 3.3;
  lastType = null;
  lastBarTime = 0;

  dyingTimer = 0;
  dyingFromCircle = null;

  shake = 0;
  shockwave = null;
  bloom = null;

  // ===== RESET UI (SAFE) =====
  if (UI?.score)     UI.score.textContent = "0";
  if (UI?.coins)     UI.coins.textContent = "0";
  if (UI?.combo)     UI.combo.textContent = "1";
  if (UI?.overCount) UI.overCount.textContent = "0";
}


// ================= LOOP TIMERS RESET (UNIFI√â) =================
// ‚ö†Ô∏è IMPORTANT : on ne touche pas au "renderTime" sauf quand on d√©marre un NOUVEAU run.
function resetLoopTimers(hard = false){
  lastTS  = 0;
  accTime = 0;
  drawAcc = 0;
  fxTick  = 0;

  if (hard){
    renderTime = 0; // ‚úÖ seulement au lancement d‚Äôun run neuf
  }
}


// ================= GAME OVER / MENU =================
function goToMenu(){
  setUIState("menu");
  document.body.classList.remove("playing");
  gameOverTriggered = false;
}

function onGameOverCleanup(){
  gameRunning = false;
  stopLoop();               // ‚úÖ coupe RAF
  resetLoopTimers(false);   // ‚úÖ pas de reset renderTime ici (sinon jitter menu/fx)
  fxCalm = 0;
}


// ================= NOISE INIT =================
function initNoise(){
  noiseCanvas = document.createElement("canvas");
  noiseCanvas.width = 256;
  noiseCanvas.height = 256;

  const nctx = noiseCanvas.getContext("2d", { alpha: true });
  const img = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);

  for(let i = 0; i < img.data.length; i += 4){
    const v = (Math.random() * 255) | 0;
    img.data[i]   = v;
    img.data[i+1] = v;
    img.data[i+2] = v;
    img.data[i+3] = 40; // alpha l√©ger
  }

  nctx.putImageData(img, 0, 0);
}


// ================= MENU VIDEO (GPU SAFE) =================
const MENU_VIDEO_SRC = menuVideo?.dataset?.src || "";

function startMenuVideo(){
  if (!menuVideo || !MENU_VIDEO_SRC) return;

  if (!menuVideo.src){
    menuVideo.src = MENU_VIDEO_SRC;
    menuVideo.load();
  }

  menuVideo.currentTime = 0;
  const p = menuVideo.play();
  if (p && p.catch) p.catch(()=>{});
}

function stopMenuVideo(){
  if (!menuVideo) return;

  menuVideo.pause();
  menuVideo.currentTime = 0;

  menuVideo.removeAttribute("src");
  menuVideo.load(); // üî• lib√®re le GPU
}


// ================= START RUN (PROPRE) =================
function startRun(e){
  if (e){
    e.preventDefault();
    e.stopPropagation();
  }

  // cache "new record"
  const nr = document.getElementById("newRecord");
  if (nr){
    nr.style.display = "none";
    nr.style.opacity = "0";
    nr.style.transform = "scale(1)";
  }

  // reset flags
  gameOverTriggered = false;

  // reset continue/revive
  canContinueThisRun = true;
  hideContinuePopup();

  if (continueTimeout) clearTimeout(continueTimeout);
  if (continueInterval) clearInterval(continueInterval);
  continueTimeout = null;
  continueInterval = null;

  const box = document.getElementById("continueTimer");
  if (box) box.style.display = "none";

  // stop menu stuff
  stopShopPreviewLoop?.();
  stopMenuVideo();

  // bind UI si besoin
  if (!UI?.score) bindUI?.();

  // init noise si besoin
  if (!noiseCanvas) initNoise();

  // √©tat jeu
  uiState = "playing";
  gameState = "playing";
  gameRunning = true;
  document.body.classList.add("playing");

  // reset run + timers moteur (HARD = run neuf)
  resetRun();
  resetLoopTimers(true);

  fxCalm = 1;

  // relance RAF propre
  startLoop();
}


// ================= STOP GAME LOOP (GPU FRIENDLY) =================
function stopGameLoop(){
  gameRunning = false;
  stopLoop();
  resetLoopTimers(false);

  // lib√®re le canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  fxCalm = 0.6;
}


// ================= MENU ENTRY =================
function startMenu(){
  uiState = "menu";
  gameState = "menu";
  gameRunning = false;

  document.body.classList.remove("playing");

  stopGameLoop();
  startMenuVideo();

  hideMenuAdPopup?.();

  if (canWatchAd?.()){
    setTimeout(() => {
      if (uiState === "menu") showMenuAdPopup?.();
    }, 900);
  }
}


// ================= FX FLAGS =================
let skipHeavyFX = false;

// ================= SHOP NAV =================
function switchSkin(dir){
  const list = Object.keys(SKINS);
  if (!list.length) return;
  let i = list.indexOf(previewSkin);
  if (i === -1) i = 0;
  i = (i + dir + list.length) % list.length;
  previewSkin = list[i];
  buildShop();
}


/* =========================================================
   MENU + SHOP + OPTIONS (UI ONLY)
   - NO AUDIO
   - NO GAME LOOP
   - SHOP = RAF UNIQUE
========================================================= */

const menuOverlayEl  = document.getElementById("menuOverlay");
const menuButtonsEl2 = document.getElementById("menuButtons");
const shopPanelEl2   = document.getElementById("shopPanel");
const shopBackBtnEl2 = document.getElementById("shopBackBtn");

// üîí SAFETY CHECK
if (!menuOverlayEl)  console.warn("[UI] menuOverlayEl manquant");
if (!menuButtonsEl2) console.warn("[UI] menuButtonsEl2 manquant");
if (!shopPanelEl2)   console.warn("[UI] shopPanelEl2 manquant");
if (!shopBackBtnEl2) console.warn("[UI] shopBackBtnEl2 manquant");


/* ================= MENU STATS ================= */
function updateMenuStats(){
  const best  = Number(localStorage.getItem("bestScore")  || 0);
  const coins = Number(localStorage.getItem("coinsBank") || 0);

  const sb = document.getElementById("shopBest");
  const sc = document.getElementById("shopCoins");
  const mb = document.getElementById("menuBest");
  const mc = document.getElementById("menuCoins");

  if (sb) sb.textContent = best.toLocaleString();
  if (sc) sc.textContent = coins.toLocaleString();
  if (mb) mb.textContent = best.toLocaleString();
  if (mc) mc.textContent = coins.toLocaleString();
}


/* =========================================================
   SHOP PREVIEW SYSTEM (SINGLE RAF / ZERO LEAK)
========================================================= */

/* =========================================================
   SHOP PREVIEW SYSTEM (CORRIG√â : ANIMATIONS ACTIVES)
========================================================= */

// canvas -> { ctx, skinId }
const shopPreviews = new Map();

let shopPreviewRAF = 0;
let previewTime = 0;
let _prevTS = 0;

function startShopPreviewLoop(){
  if (shopPreviewRAF) return;

  previewTime = 0;
  _prevTS = 0;
  
  // On reset les timers sp√©cifiques pour que l'anim d√©marre tout de suite
  neonNext = 0; 
  blinkPhase = 0;

  const step = (ts) => {
    if (uiState !== "shop"){
      stopShopPreviewLoop();
      return;
    }

    if (!_prevTS) _prevTS = ts;
    let dt = (ts - _prevTS) * 0.001; // dt en secondes
    _prevTS = ts;

    // s√©curit√© temps
    if (dt < 0) dt = 0;
    if (dt > 0.05) dt = 0.016;

    previewTime += dt; 

    // ‚úÖ CRUCIAL 1 : On met √† jour la variable GLOBALE fxTime
    // Les visages (drawNeonFace, etc.) lisent cette variable en Secondes.
    fxTime = previewTime; 

    for (const [canvas, item] of shopPreviews){
      if (!canvas || !canvas.isConnected) continue;

      const ctx = item.ctx;
      const skinId = item.skinId;
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // --- DESSIN DU PERSONNAGE ---
      // ‚úÖ CRUCIAL 2 : On passe le temps en MILLISECONDES (x1000)
      // Les effets arri√®res (drawInfernoFX, drawArcticFX) divisent par 1000 en interne.
      // Si on envoyait juste 'previewTime', ils seraient 1000x trop lents (fig√©s).
      
      drawPlayerPreview(ctx, skinId, previewTime * 1000);

      // --- FX AVANT (Voidwalker masque) ---
      if (skinId === "voidwalker" && !skipHeavyFX){
        // On passe aussi le temps en MS pour le jitter
        // On r√©cup√®re les coordonn√©es exactes utilis√©es dans drawPlayerPreview
        const bw = 80; 
        const bh = 70;
        const bx = (w - bw) * 0.5;
        const by = (h - bh) * 0.45;
        
        drawVoidwalkerFrontFX(ctx, bx, by, bw, bh, previewTime * 1000);
      }
    }

    shopPreviewRAF = requestAnimationFrame(step);
  };

  shopPreviewRAF = requestAnimationFrame(step);
}

function stopShopPreviewLoop(){
  if (!shopPreviewRAF) return;

  cancelAnimationFrame(shopPreviewRAF);
  shopPreviewRAF = 0;
  _prevTS = 0;
  previewTime = 0;
}

// ================= SHOP NAV =================
let previewSkin = localStorage.getItem("currentSkin") || "moony";

/* =====================================================
   SHOP BUILDER ‚Äî CHARACTER SHOWCASE (AAA DESIGN)
===================================================== */

function buildShop(){
  if (!SKINS || !shopPanel) return;

  /* ================= RESET UI ================= */
  stopShopPreviewLoop();           // üîí stop RAF AVANT
  shopPanel.innerHTML = "";
  shopPreviews.clear();            // ‚úÖ SAFE ici

  /* ================= STATE ================= */
  coinsBank  = Number(localStorage.getItem("coinsBank") || 0);
  ownedSkins = JSON.parse(localStorage.getItem("ownedSkins") || '["moony"]');

  if (!ownedSkins.includes("moony")) ownedSkins.push("moony");
  if (!SKINS[previewSkin]) previewSkin = equippedSkin;

  const skin       = SKINS[previewSkin];
  const catId      = skin.category;
  const owned      = ownedSkins.includes(previewSkin);
  const isEquipped = previewSkin === equippedSkin;
  const enough     = coinsBank >= skin.price;

  /* =====================================================
     AD BLOCK ‚Äî COINS ONLY (SAFE)
  ===================================================== */
  const shopAd = document.createElement("div");
  shopAd.id = "shopAdBlock";
  shopAd.style.display = "none";
  // Design plus discret pour ne pas cacher le perso
  shopAd.style.cssText = `
    position:absolute;
    top:16px;
    right:16px;
    z-index:30;
    padding:8px 14px;
    border-radius:12px;
    text-align:right;
    background:rgba(0,20,10,0.6);
    border:1px solid rgba(80,255,160,0.3);
    backdrop-filter:blur(8px);
    transform:scale(0.9);
    transform-origin:top right;
  `;

  shopAd.innerHTML = `
    <div style="font-size:10px;letter-spacing:1px;color:#9fffd1;opacity:0.8;margin-bottom:2px;">
      NEED COINS?
    </div>
    <div id="shopAdBtn" style="
      font-size:11px;
      font-weight:800;
      color:#fff;
      cursor:pointer;
      text-decoration:underline;
    ">+${AD_REWARD_COINS} (WATCH AD)</div>
  `;

  shopAd.querySelector("#shopAdBtn").onclick = ()=>{
    if (!canWatchAd()) return;
    watchAdForCoins("shop");
  };

  shopPanel.appendChild(shopAd);

  /* =====================================================
     SCENE CONTAINER
  ===================================================== */
  const catDiv = document.createElement("div");
  catDiv.className = "shopCategory";

  /* =====================================================
     SKIN CARD (Invisible Wrapper)
  ===================================================== */
  const list = document.createElement("div");
  list.className = "skinList";

  const card = document.createElement("div");
  // On ajoute les classes pour g√©rer le style du 'spotlight' en CSS
  card.className = "skinCard " + catId + (owned ? " owned" : "");

  /* =====================================================
     CANVAS ‚Äî THE HERO
  ===================================================== */
  const canvas = document.createElement("canvas");
  // R√âSOLUTION √âLEV√âE pour un rendu net
  canvas.width = 400;
  canvas.height = 400;
  canvas.className = "skinPreview";
  card.appendChild(canvas);

  shopPreviews.set(canvas,{
    ctx: canvas.getContext("2d",{alpha:true}),
    skinId: previewSkin
  });

  list.appendChild(card);
  catDiv.appendChild(list);

  /* =====================================================
     INFO UI (BOTTOM)
  ===================================================== */
  
  // Nom du Skin
  const name = document.createElement("div");
  name.className = "skinName";
  name.textContent = skin.name;
  
  // Raret√©
  const rarity = document.createElement("div");
  rarity.className = "skinRarityLabel " + catId;
  rarity.textContent = SKIN_CATEGORIES[catId]?.label || catId;

  // Prix
  const price = document.createElement("div");
  price.className = "skinPrice";
  if (isEquipped) {
    price.textContent = "CURRENTLY EQUIPPED";
    price.style.color = "#a0ffc0";
  } else if (owned) {
    price.textContent = "OWNED";
    price.style.color = "#a0c0ff";
  } else {
    price.textContent = skin.price > 0 ? skin.price.toLocaleString() + " COINS" : "FREE";
  }

  // Ajout au DOM principal (pas dans la card)
  catDiv.appendChild(name);
  catDiv.appendChild(rarity);
  catDiv.appendChild(price);

  /* =====================================================
     ACTION BUTTON (CORRIG√â : CONNECT√â AU JEU)
  ===================================================== */
  const btn = document.createElement("button");
  btn.className = "skinButton " + catId;

  if (!owned && !enough){
    // --- CAS 1 : PAS ASSEZ D'ARGENT -> PUB ---
    btn.textContent = "GET COINS (AD)";
    btn.classList.add("adCTA");
    btn.onclick = ()=>{
      if (!canWatchAd()) return;
      watchAdForCoins("shop");
    };

  } else if (!owned){
    // --- CAS 2 : ACHAT ---
    btn.textContent = "UNLOCK";
    btn.onclick = ()=>{
      if (coinsBank < skin.price) return;

      // 1. Transaction
      coinsBank -= skin.price;
      ownedSkins.push(previewSkin);
      
      // 2. √âquipement imm√©diat
      equippedSkin = previewSkin;
      currentSkin  = previewSkin; // <--- C'EST LA LIGNE MANQUANTE (Connexion au jeu)

      // 3. Sauvegarde
      localStorage.setItem("coinsBank", coinsBank);
      localStorage.setItem("ownedSkins", JSON.stringify(ownedSkins));
      localStorage.setItem("currentSkin", currentSkin);

      // 4. Refresh UI
      buildShop();
      updateMenuStats();
    };

  } else {
    // --- CAS 3 : D√âJ√Ä POSS√âD√â ---
    if (!isEquipped) {
      btn.textContent = "EQUIP";
      btn.onclick = ()=>{
        // 1. √âquipement
        equippedSkin = previewSkin;
        currentSkin  = previewSkin; // <--- C'EST LA LIGNE MANQUANTE (Connexion au jeu)

        // 2. Sauvegarde
        localStorage.setItem("currentSkin", currentSkin);
        
        // 3. Refresh UI
        buildShop();
        updateMenuStats();
      };
    } else {
      // D√©j√† √©quip√©
      btn.textContent = "SELECTED";
      btn.classList.add("disabled");
      btn.style.opacity = "0.5";
      btn.style.cursor = "default";
    }
  }

  catDiv.appendChild(btn);
  shopPanel.appendChild(catDiv);
  /* =====================================================
     NAV ARROWS (MODERN)
  ===================================================== */
  const nav = document.createElement("div");
  nav.style.cssText = `position:absolute; inset:0; pointer-events:none; z-index:20;`;

  const arrow = (txt, dir, side) => {
    const b = document.createElement("div");
    b.textContent = txt;
    // On utilise les classes CSS .navArrow .left / .right
    b.className = `navArrow ${side}`; 
    b.onclick = () => switchSkin(dir);
    b.style.pointerEvents = "auto";
    return b;
  };

  nav.appendChild(arrow("‚Äπ", -1, "left"));
  nav.appendChild(arrow("‚Ä∫", 1, "right"));
  shopPanel.appendChild(nav);

  /* =====================================================
     AD VISIBILITY CHECK
  ===================================================== */
  if (!owned){
    const missing = skin.price - coinsBank;
    if (missing > 0 && missing <= AD_REWARD_COINS && canWatchAd()){
      shopAd.style.display = "block";
    }
  }

  updateMenuStats();
  updateDailyAdsUI();

  if (uiState === "shop"){
    startShopPreviewLoop(); // ‚úÖ safe maintenant
  }
}


/* =========================================================
   UI STATE CENTRAL ‚Äî VERSION CLEAN / ZERO ERREUR
========================================================= */
let _menuAdTimer = 0;

let uiState = "menu"; // intro | menu | shop | options | playing | gameover

function setUIState(state){
  uiState = state;

  // === SYNC GAME STATE (CRITIQUE) ===
  if (state === "playing") gameState = "playing";
  else if (state === "gameover") gameState = "gameover";
  else gameState = "menu";

  const overlayMenuEl = document.getElementById("menuOverlay");
  const shopStats     = document.getElementById("shopStats");
  const menuStats     = document.getElementById("menuStats");
  const gc            = document.getElementById("gameContainer");

  // === RESET GLOBAL (STRICT) ===
  if (overlayMenuEl){
    overlayMenuEl.style.display = "none";
    overlayMenuEl.style.visibility = "hidden";
    overlayMenuEl.style.pointerEvents = "none";
  }

  if (shopPanelEl2){
    shopPanelEl2.style.display = "none";
    shopPanelEl2.classList.remove("visible");
  }

  if (optionsPanelEl){
    optionsPanelEl.style.display = "none";
    optionsPanelEl.style.visibility = "hidden";
    optionsPanelEl.style.pointerEvents = "none";
  }

  if (overlayGameOver){
    overlayGameOver.classList.remove("visible");
    overlayGameOver.style.display = "none";
    overlayGameOver.style.visibility = "hidden";
    overlayGameOver.style.pointerEvents = "none";
  }

  if (shopBackBtnEl2) shopBackBtnEl2.style.display = "none";
  if (shopStats)      shopStats.style.display = "none";
  if (menuStats)      menuStats.style.display = "none";

  if (gc) gc.style.pointerEvents = "auto";

  // stop input jet hors gameplay
  jetOn = false;

  // cache shop ad par d√©faut
  const shopAd = document.getElementById("shopAdBlock");
  if (shopAd) shopAd.style.display = "none";

  // === √âTATS ===
  switch(state){

    case "menu":{
      stopShopPreviewLoop();
      startMenuVideo();

      if (overlayMenuEl){
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
        overlayMenuEl.style.pointerEvents = "auto";
      }

      if (menuStats) menuStats.style.display = "flex";

      playMusic("menu");

      // üéÅ MENU AD
      hideMenuAdPopup();
      if (_menuAdTimer){ clearTimeout(_menuAdTimer); _menuAdTimer = 0; }

      if (canWatchAd()){
        _menuAdTimer = setTimeout(() => {
          if (uiState === "menu") showMenuAdPopup();
        }, 900);
      }
      break;
    }

    case "shop":{
      startMenuVideo();

      if (overlayMenuEl){
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
        overlayMenuEl.style.pointerEvents = "auto";
      }

      if (shopPanelEl2){
        shopPanelEl2.style.display = "block";
        shopPanelEl2.classList.add("visible");
      }

      if (shopBackBtnEl2) shopBackBtnEl2.style.display = "flex";
      // On cache les stats globales du shop car on a le prix int√©gr√© au design
      if (shopStats)      shopStats.style.display = "flex";

      // ‚úÖ buildShop() = autorit√© unique
      buildShop();

      playMusic("menu");
      break;
    }

    case "options":{
      stopShopPreviewLoop();
      startMenuVideo();

      if (overlayMenuEl){
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
        overlayMenuEl.style.pointerEvents = "auto";
      }

      if (optionsPanelEl){
        optionsPanelEl.style.display = "flex";
        optionsPanelEl.style.visibility = "visible";
        optionsPanelEl.style.pointerEvents = "auto";
      }

      if (gc) gc.style.pointerEvents = "none";
      playMusic("menu");
      break;
    }

    case "playing":{
      stopShopPreviewLoop();
      stopMenuVideo();

      if (overlayMenuEl){
        overlayMenuEl.style.display = "none";
        overlayMenuEl.style.pointerEvents = "none";
      }

      if (gc) gc.style.pointerEvents = "auto";
      playMusic("game");
      break;
    }

    case "gameover":{
      stopShopPreviewLoop();
      startMenuVideo();

      if (overlayGameOver){
        overlayGameOver.style.display = "flex";
        overlayGameOver.classList.add("visible");
        overlayGameOver.style.visibility = "visible";
        overlayGameOver.style.pointerEvents = "auto";
      }

      if (overlayMenuEl) overlayMenuEl.style.pointerEvents = "none";
      if (gc) gc.style.pointerEvents = "none";

      playMusic("menu");
      break;
    }
  }
}


/* =========================================================
   DOM READY ‚Äî BINDINGS / SWIPES / INIT
========================================================= */
document.addEventListener("DOMContentLoaded", () => {

  // === SWIPE SHOP (ONE-SKIN FOCUS) ===
  let touchX = 0;

  if (shopPanelEl2){
    shopPanelEl2.addEventListener("touchstart", (e)=>{
      if (!e.touches || !e.touches.length) return;
      touchX = e.touches[0].clientX;
    }, { passive:true });

    shopPanelEl2.addEventListener("touchend", (e)=>{
      if (!e.changedTouches || !e.changedTouches.length) return;
      const dx = e.changedTouches[0].clientX - touchX;
      if (Math.abs(dx) > 60){
        switchSkin(dx < 0 ? 1 : -1);
      }
    }, { passive:true });
  }

  // === MENU AD BTN ===
  document.getElementById("menuAdBtn")?.addEventListener("click", () => {
    if (!canWatchAd()) return;
    watchAdForCoins("menu");
  });

  // ‚ö†Ô∏è IMPORTANT : pas de listener global shopAdBtn ici
  // buildShop() attache d√©j√† onclick sur #shopAdBtn (quand il existe)

  // init daily ads UI
  initDailyAds();
  updateDailyAdsUI();

  // ---------- SHOP ----------
  function openShop(){ setUIState("shop"); }
  function closeShop(){ setUIState("menu"); }

  // ---------- OPTIONS ----------
  function openOptions(){ setUIState("options"); }
  function closeOptions(){ setUIState("menu"); }

  // ---------- BOUTONS MENU ----------
  document.getElementById("btnShop")?.addEventListener("click", openShop);
  document.getElementById("btnOptions")?.addEventListener("click", openOptions);
  document.getElementById("shopBackBtn")?.addEventListener("click", closeShop);
  document.getElementById("optBack")?.addEventListener("click", closeOptions);

  // ---------- BOUTON JOUER ----------
  const btnPlay = document.getElementById("btnPlay");
  if (btnPlay){
    btnPlay.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      gameOverTriggered = false;
      startRun(e);
      setUIState("playing");
    });
  }

  // ---------- GAME OVER BUTTONS ----------
  const restartBtnGO = document.getElementById("restartBtn");
  const menuBtnGO    = document.getElementById("menuBtn");

  if (restartBtnGO){
    restartBtnGO.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      gameOverTriggered = false;
      startRun();
      setUIState("playing");
    });
  }

  if (menuBtnGO){
    menuBtnGO.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      gameOverTriggered = false;

      stopGameLoop();
      document.body.classList.remove("playing");

      setUIState("menu");
      if (typeof showMenu === "function") showMenu();
    });
  }

  // ---------- INPUT JEU ----------
  window.addEventListener("keydown", (e)=>{
    if (e.repeat) return;
    if (uiState !== "playing") return;

    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "KeyZ"){
      e.preventDefault();
      jetStart();
    }
  });

  window.addEventListener("keyup", (e)=>{
    if (uiState !== "playing") return;

    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "KeyZ"){
      e.preventDefault();
      jetStop();
    }
  });

  // ---------- INIT ----------
  bindUI();
  setUIState("menu");  // √©tat initial

});

FXQuality.setForceTier(0); // 0 = Mode Low (Pas d'ombres, pas de particules lourdes)

</script>

</body>
</html>   
